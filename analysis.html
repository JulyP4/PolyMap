<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Root multi-parameter analysis</title>
  <style>
    :root {
      --bg: #0b1221;
      --panel: #0f172a;
      --panel2: #111827;
      --border: #1f2937;
      --accent: #60a5fa;
      --text: #e5e7eb;
      --muted: #9ca3af;
    }
    body { margin:0; background: radial-gradient(circle at top, #161c2a 0, #0b1221 60%); color: var(--text); font-family: system-ui, -apple-system, "Segoe UI", sans-serif; min-height:100vh; }
    header { padding:0.8rem 1rem; border-bottom:1px solid var(--border); backdrop-filter: blur(6px); position:sticky; top:0; background:rgba(12,18,32,0.92); z-index:10; }
    h1 { margin:0; font-size:1.1rem; letter-spacing:0.06em; color:#bfdbfe; }
    main { display:grid; grid-template-columns: 320px minmax(0,1.5fr); gap:0.8rem; padding:0.8rem; }
    @media (max-width: 1080px) { main { grid-template-columns: minmax(0,1fr); } }
    .panel { background:var(--panel); border:1px solid var(--border); border-radius:0.75rem; padding:0.8rem; }
    .panel h3 { margin:0 0 0.2rem 0; font-size:0.95rem; letter-spacing:0.04em; color:#cbd5f5; }
    .panel small { color:var(--muted); }
    .pill { display:inline-flex; align-items:center; gap:0.35rem; border:1px solid var(--border); padding:0.18rem 0.55rem; border-radius:999px; font-size:0.78rem; color:var(--muted); background:var(--panel2); }
    .grid { display:grid; grid-template-columns: repeat(auto-fit, minmax(240px,1fr)); gap:0.6rem; }
    .card { border:1px solid var(--border); border-radius:0.65rem; padding:0.6rem; background:var(--panel2); }
    .card h4 { margin:0 0 0.2rem 0; font-size:0.85rem; color:#e5e7eb; }
    .text-muted { color:var(--muted); font-size:0.82rem; }
    .tag { display:inline-block; padding:0.15rem 0.45rem; border-radius:0.45rem; border:1px solid var(--border); font-size:0.75rem; color:#cbd5f5; }
    table { width:100%; border-collapse:collapse; font-size:0.85rem; }
    th, td { padding:0.35rem 0.25rem; text-align:left; border-bottom:1px dashed #1f2937; }
    th { color:#cbd5f5; font-weight:600; }
    .bar { height:8px; border-radius:999px; background:linear-gradient(90deg,#3b82f6,#14b8a6); }
    .heatmap { display:grid; gap:2px; }
    .heat-cell { padding:6px; text-align:center; border-radius:4px; font-size:0.8rem; }
    .controls { display:flex; gap:0.4rem; flex-wrap:wrap; margin:0.4rem 0; }
    select, input[type=number] { background:var(--panel2); border:1px solid var(--border); color:var(--text); border-radius:0.45rem; padding:0.3rem 0.5rem; }
    .info-list { display:flex; flex-wrap:wrap; gap:0.35rem; }
  </style>
</head>
<body>
  <header>
    <h1>Root multi-parameter analysis workspace</h1>
    <div class="pill">接口式布局：可扩展新的分析模块</div>
  </header>
  <main>
    <section class="panel" id="controlPanel">
      <h3>Data settings</h3>
      <small id="metaSummary"></small>
      <div class="controls">
        <label>Choose index
          <select id="indexSelector"></select>
        </label>
        <label>Bins along z
          <input type="number" id="binInput" min="3" max="50" value="10" />
        </label>
        <label>k for clustering
          <input type="number" id="clusterInput" min="2" max="12" value="3" />
        </label>
        <label>Color by
          <select id="colorSelector"></select>
        </label>
      </div>
      <div class="info-list" id="metaBadges"></div>
    </section>
    <section class="panel" id="analysisPanel">
      <div id="analysisGrid" class="grid"></div>
    </section>
  </main>
  <script>
    const payloadStr = sessionStorage.getItem('rootAnalysisPayload');
    let payload = null;
    try {
      payload = JSON.parse(payloadStr || 'null');
    } catch (err) {
      console.error('Failed to parse payload', err);
    }
    const rows = payload?.rows || [];
    const indexColumns = payload?.indices || [];
    const metaCols = payload?.columns ? payload.columns.filter(c => !indexColumns.includes(c)) : [];

    const grid = document.getElementById('analysisGrid');

    function mean(arr){
      if (!arr.length) return NaN;
      return arr.reduce((a,b)=>a+b,0)/arr.length;
    }

    function quantile(arr, q){
      if (!arr.length) return NaN;
      const sorted = [...arr].sort((a,b)=>a-b);
      const pos = (sorted.length - 1) * q;
      const base = Math.floor(pos);
      const rest = pos - base;
      if (sorted[base+1] !== undefined) return sorted[base] + rest * (sorted[base+1] - sorted[base]);
      return sorted[base];
    }

    function groupBy(key){
      const map = new Map();
      rows.forEach(r => {
        const k = r[key] || '(missing)';
        if (!map.has(k)) map.set(k, []);
        map.get(k).push(r);
      });
      return map;
    }

    function makeCard(title, content){
      const div = document.createElement('div');
      div.className = 'card';
      div.innerHTML = `<h4>${title}</h4>${content}`;
      return div;
    }

    function renderMeta(){
      const meta = document.getElementById('metaSummary');
      meta.textContent = `${rows.length} rows · ${indexColumns.length} indices · metadata: ${metaCols.join(', ')}`;
      const idxSel = document.getElementById('indexSelector');
      indexColumns.forEach(c => {
        const opt = document.createElement('option');
        opt.value = c; opt.textContent = c; idxSel.appendChild(opt);
      });
      const colorSel = document.getElementById('colorSelector');
      ['label','zone','layer','treatment','batch'].filter(c => metaCols.includes(c)).forEach(c => {
        const opt = document.createElement('option');
        opt.value = c; opt.textContent = c; colorSel.appendChild(opt);
      });
      const badges = document.getElementById('metaBadges');
      metaCols.forEach(c => {
        const span = document.createElement('span');
        span.className = 'tag';
        span.textContent = c;
        badges.appendChild(span);
      });
    }

    function renderQC(index){
      const vals = rows.map(r => Number(r[index])).filter(v => !isNaN(v));
      const q1 = quantile(vals,0.25), q3 = quantile(vals,0.75);
      const iqr = q3 - q1;
      const low = q1 - 1.5*iqr, high = q3 + 1.5*iqr;
      const outliers = vals.filter(v => v < low || v > high).length;
      const content = `
        <div class="text-muted">IQR: ${iqr.toFixed(3)} · Whisker: [${low.toFixed(3)}, ${high.toFixed(3)}] · Outliers: ${outliers}</div>
        <div class="bar" style="width:${Math.min(100, (vals.length/rows.length)*100)}%"></div>
      `;
      return makeCard('基础 QC / outlier', content);
    }

    function renderDistributions(index){
      const vals = rows.map(r => Number(r[index])).filter(v => !isNaN(v));
      if (!vals.length) return makeCard('分布 (histogram-like)', '<div class="text-muted">No numeric values</div>');
      const bins = 12;
      const min = Math.min(...vals), max = Math.max(...vals);
      const step = (max-min || 1)/bins;
      const counts = Array.from({length:bins}, ()=>0);
      vals.forEach(v => { const i=Math.min(bins-1, Math.floor((v-min)/step)); counts[i]++; });
      const maxCount = Math.max(...counts,1);
      const bars = counts.map((c,i)=>{
        const w = (c/maxCount)*100;
        return `<div class="text-muted">Bin ${i+1}: ${c}</div><div class="bar" style="width:${w}%; margin-bottom:6px;"></div>`;
      }).join('');
      return makeCard('分布 (histogram-like)', bars);
    }

    function renderGrouped(index){
      const groups = ['zone','layer','treatment'].filter(k => metaCols.includes(k));
      if (!groups.length) return makeCard('分组统计', '<div class="text-muted">No zone/layer/treatment columns.</div>');
      const tables = groups.map(g => {
        const map = groupBy(g);
        const rowsHtml = Array.from(map.entries()).map(([key,list]) => {
          const vals = list.map(r => Number(r[index])).filter(v=>!isNaN(v));
          return `<tr><td>${key}</td><td>${quantile(vals,0.25).toFixed(2)}</td><td>${quantile(vals,0.5).toFixed(2)}</td><td>${quantile(vals,0.75).toFixed(2)}</td><td>${vals.length}</td></tr>`;
        }).join('');
        return `<div class="text-muted" style="margin:0.2rem 0;">${g}</div><table><thead><tr><th>${g}</th><th>Q1</th><th>Median</th><th>Q3</th><th>n</th></tr></thead><tbody>${rowsHtml}</tbody></table>`;
      }).join('');
      return makeCard('按 zone/layer/treatment 盒须信息', tables);
    }

    function renderGradient(index, bins){
      const zVals = rows.map(r => Number(r.z_position)).filter(v => !isNaN(v));
      if (!zVals.length) return makeCard('梯度分析', '<div class="text-muted">z_position 缺失</div>');
      const min = Math.min(...zVals), max = Math.max(...zVals);
      const step = (max-min || 1)/bins;
      const series = Array.from({length:bins}, (_,i)=>({
        bin: i+1,
        start: min + i*step,
        end: min + (i+1)*step,
        values: []
      }));
      rows.forEach(r => {
        const z = Number(r.z_position);
        const v = Number(r[index]);
        if (isNaN(z) || isNaN(v)) return;
        const idx = Math.min(bins-1, Math.floor((z-min)/step));
        series[idx].values.push(v);
      });
      const points = series.map(s => ({
        bin: s.bin,
        mean: s.values.length ? mean(s.values) : NaN
      }));
      const spark = points.map(p => isNaN(p.mean)?'' : `${p.bin},${p.mean.toFixed(3)}`).filter(Boolean).join(' | ');
      const list = series.map(s => `<div class="text-muted">Bin ${s.bin} (${s.start.toFixed(2)}-${s.end.toFixed(2)}): n=${s.values.length}, mean=${s.values.length?mean(s.values).toFixed(3):'NA'}</div>`).join('');
      return makeCard('沿根轴梯度 (z binned)', `<div class="tag">${spark}</div>${list}`);
    }

    function correlationMatrix(features){
      const n = features.length;
      const vals = features.map(f => rows.map(r => Number(r[f])).filter(v=>!isNaN(v)));
      const means = vals.map(v => mean(v));
      const mat = Array.from({length:n}, ()=>Array(n).fill(0));
      for (let i=0;i<n;i++){
        for (let j=i;j<n;j++){
          let num=0, denomA=0, denomB=0;
          for (let k=0;k<rows.length;k++){
            const a = Number(rows[k][features[i]]);
            const b = Number(rows[k][features[j]]);
            if (isNaN(a) || isNaN(b)) continue;
            num += (a-means[i])*(b-means[j]);
            denomA += (a-means[i])**2;
            denomB += (b-means[j])**2;
          }
          const corr = num / Math.sqrt((denomA||1)*(denomB||1));
          mat[i][j] = mat[j][i] = corr;
        }
      }
      return mat;
    }

    function renderCorrelation(features){
      const mat = correlationMatrix(features);
      const cells = [];
      for (let i=0;i<features.length;i++){
        for (let j=0;j<features.length;j++){
          const v = mat[i][j];
          const color = `rgba(59,130,246,${Math.abs(v)})`;
          cells.push(`<div class="heat-cell" style="background:${color};">${v.toFixed(2)}</div>`);
        }
      }
      return makeCard('相关矩阵 (前 10 个指数)', `<div class="heatmap" style="grid-template-columns: repeat(${features.length}, 1fr);">${cells.join('')}</div>`);
    }

    function centerAndScale(arr){
      const m = mean(arr);
      const s = Math.sqrt(mean(arr.map(v => (v-m)**2)) || 1);
      return arr.map(v => (v-m)/s);
    }

    function pca(features, dataset = rows){
      if (features.length < 2) return null;
      const filtered = dataset.filter(r => features.every(f => !isNaN(Number(r[f]))));
      if (!filtered.length) return null;
      const matrix = filtered.map(r => features.map(f => Number(r[f])));
      const cols = features.map((_, idx) => matrix.map(row => row[idx]));
      const data = cols.map(col => centerAndScale(col));
      const n = features.length;
      const len = filtered.length;
      const cov = Array.from({length:n}, ()=>Array(n).fill(0));
      for (let i=0;i<n;i++){
        for (let j=i;j<n;j++){
          let c=0;
          for (let k=0;k<len;k++) c += data[i][k]*data[j][k];
          cov[i][j] = cov[j][i] = c/(len-1 || 1);
        }
      }
      const valsDiag = cov.map((row,i)=>({
        eigen: row[i],
        vector: Array.from({length:n}, (_,k)=> (k===i?1:0))
      }));
      valsDiag.sort((a,b)=>b.eigen - a.eigen);
      return {eigvals: valsDiag.map(v=>v.eigen), eigvecs: valsDiag.map(v=>v.vector), len, rows: filtered, features};
    }

    function renderPCA(features, k, dataset = rows){
      const res = pca(features, dataset);
      if (!res || res.len < 2) return makeCard('PCA', '<div class="text-muted">至少 2 个指数才能做 PCA</div>');
      const pc1 = res.eigvecs[0];
      const pc2 = res.eigvecs[1] || res.eigvecs[0];
      const scores = [];
      for (let i=0;i<res.len;i++){
        const vals = features.map(f => Number(res.rows[i][f]));
        const s1 = vals.reduce((sum,v,idx)=> sum + v*pc1[idx], 0);
        const s2 = vals.reduce((sum,v,idx)=> sum + v*pc2[idx], 0);
        scores.push([s1,s2]);
      }
      const centroids = Array.from({length:k}, ()=>[0,0,0]);
      scores.forEach((s,i)=>{ const c = centroids[i%k]; c[0]+=s[0]; c[1]+=s[1]; c[2]++; });
      centroids.forEach(c=>{ c[0]/=c[2] || 1; c[1]/=c[2] || 1; });
      const assignments = scores.map(s => {
        let best=0, bestDist=Infinity;
        centroids.forEach((c,idx)=>{
          const d=(s[0]-c[0])**2 + (s[1]-c[1])**2;
          if (d<bestDist) {bestDist=d; best=idx;}
        });
        return best+1;
      });
      const clusters = Array.from({length:k}, ()=>({count:0}));
      assignments.forEach(a => clusters[a-1].count++);
      const list = clusters.map((c,idx)=>`<div class="text-muted">Cluster ${idx+1}: n=${c.count}</div>`).join('');
      return makeCard('PCA + k-means (scores)', `<div class="tag">PC1/PC2 scores</div>${list}`);
    }

    function renderLabelCohorts(index){
      const map = groupBy('label');
      if (!map.size) return makeCard('Label cohorts', '<div class="text-muted">No label information found.</div>');
      const rowsHtml = Array.from(map.entries()).map(([label, list]) => {
        const vals = list.map(r => Number(r[index])).filter(v => !isNaN(v));
        const q1 = quantile(vals,0.25), med = quantile(vals,0.5), q3 = quantile(vals,0.75);
        const meanVal = mean(vals);
        const fmt = v => isNaN(v) ? 'NA' : v.toFixed(3);
        return `<tr><td>${label}</td><td>${list.length}</td><td>${fmt(meanVal)}</td><td>${fmt(q1)}</td><td>${fmt(med)}</td><td>${fmt(q3)}</td></tr>`;
      }).join('');
      const table = `<table><thead><tr><th>Label</th><th>n</th><th>Mean</th><th>Q1</th><th>Median</th><th>Q3</th></tr></thead><tbody>${rowsHtml}</tbody></table>`;
      return makeCard('同标签内部的分布概览', table);
    }

    function renderCrossLabelMultivariate(){
      const map = groupBy('label');
      const labelsOnly = Array.from(map.entries()).filter(([key]) => key !== '(missing)');
      if (labelsOnly.length < 2) return makeCard('跨标签多指数分析', '<div class="text-muted">至少需要两个标签才能比较。</div>');
      const aggregated = labelsOnly.map(([label, list]) => {
        const obj = { label };
        indexColumns.forEach(idx => {
          const vals = list.map(r => Number(r[idx])).filter(v => !isNaN(v));
          obj[idx] = vals.length ? mean(vals) : NaN;
        });
        return obj;
      });
      const usable = indexColumns.filter(idx => aggregated.some(a => !isNaN(a[idx])));
      if (usable.length < 2) return makeCard('跨标签多指数分析', '<div class="text-muted">需要至少两个可用的 index 才能进行多维比较。</div>');
      const res = pca(usable, aggregated);
      if (!res) return makeCard('跨标签多指数分析', '<div class="text-muted">数据不足以运行 PCA。</div>');
      const pc1 = res.eigvecs[0];
      const pc2 = res.eigvecs[1] || res.eigvecs[0];
      const scores = res.rows.map(row => {
        const vals = usable.map(f => Number(row[f]));
        const s1 = vals.reduce((sum,v,idx)=> sum + v*pc1[idx], 0);
        const s2 = vals.reduce((sum,v,idx)=> sum + v*pc2[idx], 0);
        return { label: row.label, s1, s2 };
      });
      const list = scores.map(s => `<div class="text-muted">${s.label}: PC1=${s.s1.toFixed(3)}, PC2=${s.s2.toFixed(3)}</div>`).join('');
      return makeCard('跨标签多指数分析 (标签均值 PCA)', `<div class="tag">标签 → 指数均值 → PCA</div>${list}`);
    }

    function renderModuleScores(features){
      const modules = [
        ['Density','Bundling'],
        ['Connectivity','Branching'],
        ['Anisotropy']
      ];
      const cards = modules.map(mod => {
        const used = mod.filter(m => features.includes(m));
        if (!used.length) return `<div class="text-muted">${mod.join(' / ')} 缺少指数</div>`;
        const vals = used.map(m => rows.map(r => Number(r[m])).filter(v=>!isNaN(v)));
        const scores = vals.map(v => mean(v));
        return `<div class="text-muted">${used.join(', ')} → score ${mean(scores).toFixed(3)}</div>`;
      }).join('');
      return makeCard('模块 score（可替代多指标）', cards);
    }

    function renderAll(){
      grid.innerHTML = '';
      if (!rows.length) {
        grid.appendChild(makeCard('No data found', '<div class="text-muted">从 index 页面加载 CSV/TSV 后再打开本页面。</div>'));
        return;
      }
      if (!indexColumns.length) {
        grid.appendChild(makeCard('No numeric indices', '<div class="text-muted">请在表格中提供至少一个指数列。</div>'));
        return;
      }
      const index = document.getElementById('indexSelector').value || indexColumns[0];
      const bins = Number(document.getElementById('binInput').value) || 10;
      const k = Number(document.getElementById('clusterInput').value) || 3;
      grid.appendChild(renderLabelCohorts(index));
      grid.appendChild(renderQC(index));
      grid.appendChild(renderDistributions(index));
      grid.appendChild(renderGrouped(index));
      grid.appendChild(renderGradient(index, bins));
      grid.appendChild(renderCorrelation(indexColumns.slice(0,10)));
      grid.appendChild(renderCrossLabelMultivariate());
      grid.appendChild(renderPCA(indexColumns, k));
      grid.appendChild(renderModuleScores(indexColumns));
    }

    if (rows.length) {
      renderMeta();
      document.getElementById('indexSelector').addEventListener('change', renderAll);
      document.getElementById('binInput').addEventListener('change', renderAll);
      document.getElementById('clusterInput').addEventListener('change', renderAll);
      renderAll();
    } else {
      renderAll();
    }
  </script>
</body>
</html>
