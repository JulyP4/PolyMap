<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Root multi-parameter analysis</title>
  <style>
    :root {
      --bg: #0b1221;
      --panel: #0f172a;
      --panel2: #111827;
      --border: #1f2937;
      --accent: #60a5fa;
      --text: #e5e7eb;
      --muted: #9ca3af;
    }
    body { margin:0; background: radial-gradient(circle at top, #161c2a 0, #0b1221 60%); color: var(--text); font-family: system-ui, -apple-system, "Segoe UI", sans-serif; min-height:100vh; }
    header { padding:0.8rem 1rem; border-bottom:1px solid var(--border); backdrop-filter: blur(6px); position:sticky; top:0; background:rgba(12,18,32,0.92); z-index:10; }
    h1 { margin:0; font-size:1.1rem; letter-spacing:0.06em; color:#bfdbfe; }
    main { display:grid; grid-template-columns: 320px minmax(0,1.3fr) 420px; gap:0.8rem; padding:0.8rem; align-items:start; }
    @media (max-width: 1280px) { main { grid-template-columns: 320px minmax(0,1.2fr); grid-template-rows:auto auto; } }
    @media (max-width: 1024px) { main { grid-template-columns: minmax(0,1fr); grid-template-rows:auto; } }
    .panel { background:var(--panel); border:1px solid var(--border); border-radius:0.75rem; padding:0.8rem; }
    .panel h3 { margin:0 0 0.2rem 0; font-size:0.95rem; letter-spacing:0.04em; color:#cbd5f5; }
    .panel small { color:var(--muted); }
    .pill { display:inline-flex; align-items:center; gap:0.35rem; border:1px solid var(--border); padding:0.18rem 0.55rem; border-radius:999px; font-size:0.78rem; color:var(--muted); background:var(--panel2); }
    .grid { display:grid; grid-template-columns: repeat(auto-fit, minmax(240px,1fr)); gap:0.6rem; }
    .card { border:1px solid var(--border); border-radius:0.65rem; padding:0.6rem; background:var(--panel2); }
    .card h4 { margin:0 0 0.2rem 0; font-size:0.85rem; color:#e5e7eb; }
    .text-muted { color:var(--muted); font-size:0.82rem; }
    .tag { display:inline-block; padding:0.15rem 0.45rem; border-radius:0.45rem; border:1px solid var(--border); font-size:0.75rem; color:#cbd5f5; }
    table { width:100%; border-collapse:collapse; font-size:0.85rem; }
    th, td { padding:0.35rem 0.25rem; text-align:left; border-bottom:1px dashed #1f2937; }
    th { color:#cbd5f5; font-weight:600; }
    .bar { height:8px; border-radius:999px; background:linear-gradient(90deg,#3b82f6,#14b8a6); }
    .heatmap { display:grid; gap:2px; }
    .heat-cell { padding:6px; text-align:center; border-radius:4px; font-size:0.8rem; }
    .controls { display:flex; gap:0.4rem; flex-wrap:wrap; margin:0.4rem 0; }
    select, input[type=number] { background:var(--panel2); border:1px solid var(--border); color:var(--text); border-radius:0.45rem; padding:0.3rem 0.5rem; }
    .info-list { display:flex; flex-wrap:wrap; gap:0.35rem; }
    .map-frame { background:#0b1530; border:1px solid var(--border); border-radius:0.65rem; padding:0.5rem; }
    .map-frame svg { width:100%; height:auto; display:block; }
    .legend { display:flex; align-items:center; gap:0.4rem; margin-top:0.4rem; font-size:0.8rem; color:var(--muted); }
    .legend-bar { flex:1; height:10px; background:linear-gradient(90deg, #1e3a8a, #22d3ee, #f59e0b, #ef4444); border-radius:999px; border:1px solid var(--border); }
  </style>
</head>
<body>
  <header>
    <h1>Root multi-parameter analysis workspace</h1>
    <div class="pill">接口式布局：可扩展新的分析模块</div>
  </header>
  <main>
    <section class="panel" id="controlPanel">
      <h3>Data settings</h3>
      <small id="metaSummary"></small>
      <div class="controls">
        <label>Choose index
          <select id="indexSelector"></select>
        </label>
        <label>k for clustering
          <input type="number" id="clusterInput" min="2" max="12" value="3" />
        </label>
      </div>
      <div class="info-list" id="metaBadges"></div>
    </section>
    <section class="panel" id="analysisPanel">
      <div id="analysisGrid" class="grid"></div>
    </section>
    <section class="panel" id="mapPanel">
      <h3>Map heatmap</h3>
      <small id="mapStatus" class="text-muted">Waiting for index selection…</small>
      <div class="map-frame" id="mapHost"></div>
      <div class="legend"><span>Low</span><div class="legend-bar"></div><span>High</span></div>
    </section>
  </main>
  <script>
    const payloadStr = sessionStorage.getItem('rootAnalysisPayload');
    let payload = null;
    try {
      payload = JSON.parse(payloadStr || 'null');
    } catch (err) {
      console.error('Failed to parse payload', err);
    }
    const rows = payload?.rows || [];
    const indexColumns = payload?.indices || [];
    const metaCols = payload?.columns ? payload.columns.filter(c => !indexColumns.includes(c)) : [];

    const grid = document.getElementById('analysisGrid');
    const mapHost = document.getElementById('mapHost');
    const mapStatus = document.getElementById('mapStatus');

    function mean(arr){
      if (!arr.length) return NaN;
      return arr.reduce((a,b)=>a+b,0)/arr.length;
    }

    function quantile(arr, q){
      if (!arr.length) return NaN;
      const sorted = [...arr].sort((a,b)=>a-b);
      const pos = (sorted.length - 1) * q;
      const base = Math.floor(pos);
      const rest = pos - base;
      if (sorted[base+1] !== undefined) return sorted[base] + rest * (sorted[base+1] - sorted[base]);
      return sorted[base];
    }

    function groupBy(key){
      const map = new Map();
      rows.forEach(r => {
        const k = r[key] || '(missing)';
        if (!map.has(k)) map.set(k, []);
        map.get(k).push(r);
      });
      return map;
    }

    function computeLabelMeans(index){
      const byLabel = groupBy('label');
      const entries = Array.from(byLabel.entries()).map(([label,list]) => {
        const vals = list.map(r => Number(r[index])).filter(v => !isNaN(v));
        return { label, mean: mean(vals), n: vals.length };
      }).filter(d => !isNaN(d.mean));
      if (!entries.length) return null;
      const min = Math.min(...entries.map(e => e.mean));
      const max = Math.max(...entries.map(e => e.mean));
      return { entries, min, max };
    }

    function computeMapLabelMeans(index){
      const defs = payload?.map?.labels || [];
      if (!defs.length) return computeLabelMeans(index);
      const byLabel = new Map();
      defs.forEach(d => {
        const key = (d.name || d.id || '').trim();
        if (key) byLabel.set(key, { id: d.id, name: key, vals: [] });
      });
      rows.forEach(r => {
        const lbl = (r.label || '').trim();
        if (!lbl) return;
        byLabel.forEach((entry, key) => {
          if (lbl === key || lbl === entry.id) {
            const v = Number(r[index]);
            if (!isNaN(v)) entry.vals.push(v);
          }
        });
      });
      const entries = Array.from(byLabel.values()).map(e => ({
        id: e.id,
        label: e.name,
        mean: mean(e.vals),
        n: e.vals.length
      })).filter(e => !isNaN(e.mean));
      if (!entries.length) return null;
      const min = Math.min(...entries.map(e => e.mean));
      const max = Math.max(...entries.map(e => e.mean));
      return { entries, min, max };
    }

    function makeCard(title, content){
      const div = document.createElement('div');
      div.className = 'card';
      div.innerHTML = `<h4>${title}</h4>${content}`;
      return div;
    }

    function renderMeta(){
      const meta = document.getElementById('metaSummary');
      meta.textContent = `${rows.length} rows · ${indexColumns.length} indices · metadata: ${metaCols.join(', ')}`;
      const idxSel = document.getElementById('indexSelector');
      indexColumns.forEach(c => {
        const opt = document.createElement('option');
        opt.value = c; opt.textContent = c; idxSel.appendChild(opt);
      });
      const badges = document.getElementById('metaBadges');
      metaCols.forEach(c => {
        const span = document.createElement('span');
        span.className = 'tag';
        span.textContent = c;
        badges.appendChild(span);
      });
    }

    function correlationMatrix(features){
      const n = features.length;
      const vals = features.map(f => rows.map(r => Number(r[f])).filter(v=>!isNaN(v)));
      const means = vals.map(v => mean(v));
      const mat = Array.from({length:n}, ()=>Array(n).fill(0));
      for (let i=0;i<n;i++){
        for (let j=i;j<n;j++){
          let num=0, denomA=0, denomB=0;
          for (let k=0;k<rows.length;k++){
            const a = Number(rows[k][features[i]]);
            const b = Number(rows[k][features[j]]);
            if (isNaN(a) || isNaN(b)) continue;
            num += (a-means[i])*(b-means[j]);
            denomA += (a-means[i])**2;
            denomB += (b-means[j])**2;
          }
          const corr = num / Math.sqrt((denomA||1)*(denomB||1));
          mat[i][j] = mat[j][i] = corr;
        }
      }
      return mat;
    }

    function renderCorrelation(features){
      const mat = correlationMatrix(features);
      const cells = [];
      for (let i=0;i<features.length;i++){
        for (let j=0;j<features.length;j++){
          const v = mat[i][j];
          const color = `rgba(59,130,246,${Math.abs(v)})`;
          cells.push(`<div class="heat-cell" style="background:${color};">${v.toFixed(2)}</div>`);
        }
      }
      return makeCard('相关矩阵 (前 10 个指数)', `<div class="heatmap" style="grid-template-columns: repeat(${features.length}, 1fr);">${cells.join('')}</div>`);
    }

    function centerAndScale(arr){
      const m = mean(arr);
      const s = Math.sqrt(mean(arr.map(v => (v-m)**2)) || 1);
      return arr.map(v => (v-m)/s);
    }

    function pca(features, dataset = rows){
      if (features.length < 2) return null;
      const filtered = dataset.filter(r => features.every(f => !isNaN(Number(r[f]))));
      if (!filtered.length) return null;
      const matrix = filtered.map(r => features.map(f => Number(r[f])));
      const cols = features.map((_, idx) => matrix.map(row => row[idx]));
      const data = cols.map(col => centerAndScale(col));
      const n = features.length;
      const len = filtered.length;
      const cov = Array.from({length:n}, ()=>Array(n).fill(0));
      for (let i=0;i<n;i++){
        for (let j=i;j<n;j++){
          let c=0;
          for (let k=0;k<len;k++) c += data[i][k]*data[j][k];
          cov[i][j] = cov[j][i] = c/(len-1 || 1);
        }
      }
      const valsDiag = cov.map((row,i)=>({
        eigen: row[i],
        vector: Array.from({length:n}, (_,k)=> (k===i?1:0))
      }));
      valsDiag.sort((a,b)=>b.eigen - a.eigen);
      return {eigvals: valsDiag.map(v=>v.eigen), eigvecs: valsDiag.map(v=>v.vector), len, rows: filtered, features};
    }

    function renderPCA(features, k, dataset = rows){
      const res = pca(features, dataset);
      if (!res || res.len < 2) return makeCard('PCA', '<div class="text-muted">至少 2 个指数才能做 PCA</div>');
      const pc1 = res.eigvecs[0];
      const pc2 = res.eigvecs[1] || res.eigvecs[0];
      const scores = [];
      for (let i=0;i<res.len;i++){
        const vals = features.map(f => Number(res.rows[i][f]));
        const s1 = vals.reduce((sum,v,idx)=> sum + v*pc1[idx], 0);
        const s2 = vals.reduce((sum,v,idx)=> sum + v*pc2[idx], 0);
        scores.push([s1,s2]);
      }
      const centroids = Array.from({length:k}, ()=>[0,0,0]);
      scores.forEach((s,i)=>{ const c = centroids[i%k]; c[0]+=s[0]; c[1]+=s[1]; c[2]++; });
      centroids.forEach(c=>{ c[0]/=c[2] || 1; c[1]/=c[2] || 1; });
      const assignments = scores.map(s => {
        let best=0, bestDist=Infinity;
        centroids.forEach((c,idx)=>{
          const d=(s[0]-c[0])**2 + (s[1]-c[1])**2;
          if (d<bestDist) {bestDist=d; best=idx;}
        });
        return best+1;
      });
      const clusters = Array.from({length:k}, ()=>({count:0}));
      assignments.forEach(a => clusters[a-1].count++);
      const xs = scores.map(s => s[0]);
      const ys = scores.map(s => s[1]);
      const minX = Math.min(...xs), maxX = Math.max(...xs);
      const minY = Math.min(...ys), maxY = Math.max(...ys);
      const width=320, height=240, padding=46;
      const scaleX = (v)=> padding + ((v - minX)/((maxX-minX)||1))*(width-padding*1.5);
      const scaleY = (v)=> height-padding - ((v - minY)/((maxY-minY)||1))*(height-padding*1.5);
      const palette = ['#60a5fa','#34d399','#f472b6','#fbbf24','#a78bfa','#f97316'];
      const dots = scores.map((s,idx)=>{
        const c = palette[(assignments[idx]-1)%palette.length];
        return `<circle cx="${scaleX(s[0])}" cy="${scaleY(s[1])}" r="4" fill="${c}" fill-opacity="0.8" />`;
      }).join('');
      const axis = `<line x1="${padding}" y1="${height-padding}" x2="${width-padding/2}" y2="${height-padding}" stroke="#475569" />
                    <line x1="${padding}" y1="${padding/2}" x2="${padding}" y2="${height-padding}" stroke="#475569" />`;
      const xTicks = [0,0.25,0.5,0.75,1].map(t=>{
        const x = padding + t*(width-padding*1.5);
        const v = (minX + (maxX-minX)*t).toFixed(2);
        return `<line x1="${x}" y1="${height-padding}" x2="${x}" y2="${height-padding+6}" stroke="#475569" />
                <text x="${x}" y="${height-padding+18}" text-anchor="middle" font-size="10" fill="#cbd5f5">${v}</text>`;
      }).join('');
      const yTicks = [0,0.25,0.5,0.75,1].map(t=>{
        const y = height-padding - t*(height-padding*1.5);
        const v = (minY + (maxY-minY)*t).toFixed(2);
        return `<line x1="${padding-6}" y1="${y}" x2="${padding}" y2="${y}" stroke="#475569" />
                <text x="${padding-10}" y="${y+3}" text-anchor="end" font-size="10" fill="#cbd5f5">${v}</text>`;
      }).join('');
      const legend = clusters.map((c,idx)=>`<div class="text-muted">Cluster ${idx+1}: n=${c.count}</div>`).join('');
      const svg = `<svg width="${width}" height="${height}" style="background:#0b1530;border:1px solid #1f2937;border-radius:6px;">${axis}${xTicks}${yTicks}${dots}
        <text x="${width/2}" y="${height-8}" text-anchor="middle" font-size="11" fill="#cbd5f5">PC1 score</text>
        <text x="14" y="${height/2}" transform="rotate(-90 14 ${height/2})" font-size="11" fill="#cbd5f5">PC2 score</text>
      </svg>`;
      return makeCard('PCA + k-means (scores)', svg + legend);
    }

    function renderLabelCohorts(index){
      const map = groupBy('label');
      if (!map.size) return makeCard('Label cohorts', '<div class="text-muted">No label information found.</div>');
      const rowsHtml = Array.from(map.entries()).map(([label, list]) => {
        const vals = list.map(r => Number(r[index])).filter(v => !isNaN(v));
        const q1 = quantile(vals,0.25), med = quantile(vals,0.5), q3 = quantile(vals,0.75);
        const meanVal = mean(vals);
        const fmt = v => isNaN(v) ? 'NA' : v.toFixed(3);
        return `<tr><td>${label}</td><td>${list.length}</td><td>${fmt(meanVal)}</td><td>${fmt(q1)}</td><td>${fmt(med)}</td><td>${fmt(q3)}</td></tr>`;
      }).join('');
      const table = `<table><thead><tr><th>Label</th><th>n</th><th>Mean</th><th>Q1</th><th>Median</th><th>Q3</th></tr></thead><tbody>${rowsHtml}</tbody></table>`;
      return makeCard('同标签内部的分布概览', table);
    }

    function renderLabelBars(index){
      const stat = computeLabelMeans(index);
      if (!stat) return makeCard('Label means', '<div class="text-muted">No label information found.</div>');
      const stats = stat.entries.sort((a,b)=>b.mean-a.mean);
      const width = 320, height = 200, padding = 40;
      const barHeight = (height - padding*2) / stats.length;
      const maxVal = Math.max(...stats.map(s=>s.mean));
      const axis = `<line x1="${padding}" y1="${padding}" x2="${padding}" y2="${height-padding}" stroke="#475569" stroke-width="1" />
                    <line x1="${padding}" y1="${height-padding}" x2="${width-10}" y2="${height-padding}" stroke="#475569" stroke-width="1" />`;
      const bars = stats.map((s,i)=>{
        const y = padding + i*barHeight + barHeight*0.15;
        const w = maxVal ? (s.mean/maxVal)*(width-padding*1.5) : 0;
        return `
          <rect x="${padding}" y="${y}" width="${w}" height="${barHeight*0.7}" fill="#60a5fa" fill-opacity="0.8" />
          <text x="${padding-6}" y="${y+barHeight*0.5}" text-anchor="end" dominant-baseline="middle" font-size="11" fill="#e5e7eb">${s.label}</text>
          <text x="${padding+w+4}" y="${y+barHeight*0.5}" dominant-baseline="middle" font-size="10" fill="#cbd5f5">${s.mean.toFixed(3)} (n=${s.n})</text>
        `;
      }).join('');
      const ticks = [0,0.25,0.5,0.75,1].map(t=>{
        const x = padding + t*(width-padding*1.5);
        const v = (maxVal*t).toFixed(2);
        return `<line x1="${x}" y1="${height-padding}" x2="${x}" y2="${height-padding+6}" stroke="#475569" />
                <text x="${x}" y="${height-padding+18}" text-anchor="middle" font-size="10" fill="#cbd5f5">${v}</text>`;
      }).join('');
      const svg = `<svg width="${width}" height="${height}" style="background:#0b1530;border:1px solid #1f2937;border-radius:6px;">${axis}${bars}${ticks}
        <text x="${width/2}" y="${height-6}" text-anchor="middle" font-size="11" fill="#cbd5f5">Mean ${index}</text>
      </svg>`;
      return makeCard('Label means', svg);
    }

    function renderLabelIndexHeatmap(){
      const map = groupBy('label');
      const labels = Array.from(map.keys()).filter(l => l !== '(missing)').slice(0,8);
      const indices = indexColumns.slice(0,6);
      if (!labels.length || !indices.length) return makeCard('Label × index heatmap', '<div class="text-muted">需要标签与指数。</div>');
      const cells = [];
      let globalMin = Infinity, globalMax = -Infinity;
      const gridData = labels.map(lbl => {
        const rowsList = map.get(lbl) || [];
        const vals = indices.map(idx => {
          const arr = rowsList.map(r => Number(r[idx])).filter(v=>!isNaN(v));
          const m = arr.length ? mean(arr) : NaN;
          if (!isNaN(m)) { globalMin = Math.min(globalMin, m); globalMax = Math.max(globalMax, m); }
          return m;
        });
        return { label: lbl, vals };
      });
      const scale = (v) => {
        if (!isFinite(globalMin) || !isFinite(globalMax)) return '#111827';
        if (isNaN(v)) return '#111827';
        const t = (v - globalMin)/((globalMax-globalMin)||1);
        const r = Math.round(255*t);
        const b = Math.round(255*(1-t));
        return `rgb(${r},${Math.round(120+60*t)},${b})`;
      };
      gridData.forEach(row => {
        cells.push(`<div class="heat-cell" style="background:#0b1530;font-weight:600;">${row.label}</div>`);
        row.vals.forEach(v => cells.push(`<div class="heat-cell" style="background:${scale(v)};">${isNaN(v)?'NA':v.toFixed(2)}</div>`));
      });
      const header = ['Label', ...indices].map(t => `<div class="heat-cell" style="background:#0b1530;font-weight:600;">${t}</div>`).join('');
      return makeCard('Label × index heatmap', `<div class="heatmap" style="grid-template-columns: repeat(${indices.length+1},1fr);">${header}${cells.join('')}</div>`);
    }

    function valueToHeatColor(val, min, max){
      const t = (val - min) / ((max - min) || 1);
      const r = Math.round(30 + 180 * t);
      const g = Math.round(80 + 140 * t);
      const b = Math.round(200 - 140 * t);
      return `rgb(${r},${g},${b})`;
    }

    function renderMapHeat(index){
      const status = document.getElementById('mapStatus');
      const host = document.getElementById('mapHost');
      if (!payload?.map || !payload.map.svg){
        status.textContent = 'No map snapshot available from index page.';
        host.innerHTML = '';
        return;
      }
      const stats = computeMapLabelMeans(index);
      if (!stats){
        status.textContent = 'No numeric values for this index.';
        host.innerHTML = '';
        return;
      }
      host.innerHTML = payload.map.svg;
      const svg = host.querySelector('svg');
      if (!svg){
        status.textContent = 'Map snapshot missing <svg> root.';
        return;
      }
      const labelMap = new Map((payload.map.labels||[]).map(l => [l.id, l]));
      const valueMap = new Map();
      stats.entries.forEach(e => {
        valueMap.set(e.label, e.mean);
        if (e.id) valueMap.set(e.id, e.mean);
      });
      host.querySelectorAll('path').forEach(p => {
        const roiId = p.id;
        const labId = payload.map.assignments?.[roiId];
        const labName = labId ? (labelMap.get(labId)?.name || labId) : null;
        const v = labName ? valueMap.get(labName) : null;
        p.setAttribute('fill', v!=null ? valueToHeatColor(v, stats.min, stats.max) : '#1f2937');
        p.setAttribute('stroke', '#000');
        p.setAttribute('stroke-width', '1');
      });
      status.textContent = `Index: ${index} · labels=${stats.entries.length}`;
    }

    function renderAll(){
      grid.innerHTML = '';
      if (!rows.length) {
        grid.appendChild(makeCard('No data found', '<div class="text-muted">从 index 页面加载 CSV/TSV 后再打开本页面。</div>'));
        return;
      }
      if (!indexColumns.length) {
        grid.appendChild(makeCard('No numeric indices', '<div class="text-muted">请在表格中提供至少一个指数列。</div>'));
        return;
      }
      const index = document.getElementById('indexSelector').value || indexColumns[0];
      const k = Number(document.getElementById('clusterInput').value) || 3;
      grid.appendChild(renderLabelCohorts(index));
      grid.appendChild(renderLabelBars(index));
      grid.appendChild(renderLabelIndexHeatmap());
      grid.appendChild(renderCorrelation(indexColumns.slice(0,10)));
      grid.appendChild(renderPCA(indexColumns, k));
      renderMapHeat(index);
    }

    if (rows.length) {
      renderMeta();
      const idxSel = document.getElementById('indexSelector');
      if (indexColumns.length && !idxSel.value) idxSel.value = indexColumns[0];
      idxSel.addEventListener('change', () => {
        renderAll();
      });
      document.getElementById('clusterInput').addEventListener('change', renderAll);
      renderAll();
    } else {
      renderAll();
    }
  </script>
</body>
</html>
