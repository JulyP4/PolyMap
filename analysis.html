<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Root multi-parameter analysis</title>
  <style>
    :root {
      --bg: #0b1221;
      --panel: #0f172a;
      --panel2: #111827;
      --border: #1f2937;
      --accent: #60a5fa;
      --text: #e5e7eb;
      --muted: #9ca3af;
    }
    body { margin:0; background: radial-gradient(circle at top, #161c2a 0, #0b1221 60%); color: var(--text); font-family: system-ui, -apple-system, "Segoe UI", sans-serif; min-height:100vh; }
    header { padding:0.8rem 1rem; border-bottom:1px solid var(--border); backdrop-filter: blur(6px); position:sticky; top:0; background:rgba(12,18,32,0.92); z-index:10; }
    h1 { margin:0; font-size:1.1rem; letter-spacing:0.06em; color:#bfdbfe; }
    main { display:grid; grid-template-columns: 320px minmax(0,1.3fr) 420px; gap:0.8rem; padding:0.8rem; align-items:start; }
    @media (max-width: 1280px) { main { grid-template-columns: 320px minmax(0,1.2fr); grid-template-rows:auto auto; } }
    @media (max-width: 1024px) { main { grid-template-columns: minmax(0,1fr); grid-template-rows:auto; } }
    .panel { background:var(--panel); border:1px solid var(--border); border-radius:0.75rem; padding:0.8rem; }
    .panel h3 { margin:0 0 0.2rem 0; font-size:0.95rem; letter-spacing:0.04em; color:#cbd5f5; }
    .panel small { color:var(--muted); }
    .pill { display:inline-flex; align-items:center; gap:0.35rem; border:1px solid var(--border); padding:0.18rem 0.55rem; border-radius:999px; font-size:0.78rem; color:var(--muted); background:var(--panel2); }
    .grid { display:grid; grid-template-columns: repeat(auto-fit, minmax(240px,1fr)); gap:0.6rem; }
    .card { border:1px solid var(--border); border-radius:0.65rem; padding:0.6rem; background:var(--panel2); }
    .card h4 { margin:0 0 0.2rem 0; font-size:0.85rem; color:#e5e7eb; }
    .text-muted { color:var(--muted); font-size:0.82rem; }
    .tag { display:inline-block; padding:0.15rem 0.45rem; border-radius:0.45rem; border:1px solid var(--border); font-size:0.75rem; color:#cbd5f5; }
    table { width:100%; border-collapse:collapse; font-size:0.85rem; }
    th, td { padding:0.35rem 0.25rem; text-align:left; border-bottom:1px dashed #1f2937; }
    th { color:#cbd5f5; font-weight:600; }
    .bar { height:8px; border-radius:999px; background:linear-gradient(90deg,#3b82f6,#14b8a6); }
    .heatmap { display:grid; gap:2px; }
    .heat-cell { padding:6px; text-align:center; border-radius:4px; font-size:0.8rem; }
    .controls { display:flex; gap:0.4rem; flex-wrap:wrap; margin:0.4rem 0; }
    select, input[type=number] { background:var(--panel2); border:1px solid var(--border); color:var(--text); border-radius:0.45rem; padding:0.3rem 0.5rem; }
    .info-list { display:flex; flex-wrap:wrap; gap:0.35rem; }
    .map-frame { background:#0b1530; border:1px solid var(--border); border-radius:0.65rem; padding:0.5rem; }
    .map-frame svg { width:100%; height:auto; display:block; }
    .legend { display:flex; align-items:center; gap:0.4rem; margin-top:0.4rem; font-size:0.8rem; color:var(--muted); }
    .legend-bar { flex:1; height:10px; background:linear-gradient(90deg, #1e3a8a, #22d3ee, #f59e0b, #ef4444); border-radius:999px; border:1px solid var(--border); }
    .analysis-stack { display:flex; flex-direction:column; gap:0.8rem; }
    .panel .panel-body { margin-top:0.4rem; }
  </style>
</head>
<body>
  <header>
    <h1>Root multi-parameter analysis workspace</h1>
    <div class="pill">接口式布局：可扩展新的分析模块</div>
  </header>
  <main>
    <section class="panel" id="controlPanel">
      <h3>Data settings</h3>
      <small id="metaSummary"></small>
      <div class="controls">
        <label>Choose index
          <select id="indexSelector"></select>
        </label>
        <label>k for clustering
          <input type="number" id="clusterInput" min="2" max="12" value="3" />
        </label>
        <label>Map palette
          <select id="colorScale"></select>
        </label>
      </div>
      <div class="info-list" id="metaBadges"></div>
    </section>
    <section class="analysis-stack" id="analysisPanel">
      <section class="panel" id="summaryPanel">
        <h3>Summary</h3>
        <small>描述性统计与标签分组概览</small>
        <div class="panel-body" id="summaryBody"></div>
      </section>
      <section class="panel" id="testsPanel">
        <h3>Per-index tests</h3>
        <small>单因素 ANOVA（按 label 分组）</small>
        <div class="panel-body" id="testsBody"></div>
      </section>
      <section class="panel" id="univariatePanel">
        <h3>Univariate distribution</h3>
        <small>当前 index 的直方图与分位数</small>
        <div class="panel-body" id="univariateBody"></div>
      </section>
      <section class="panel" id="correlationPanel">
        <h3>Correlation</h3>
        <small>指数相关矩阵</small>
        <div class="panel-body" id="correlationBody"></div>
      </section>
      <section class="panel" id="pcaPanel">
        <h3>PCA + clustering</h3>
        <small>多指标降维与聚类概览</small>
        <div class="panel-body" id="pcaBody"></div>
      </section>
      <section class="panel" id="profilePanel">
        <h3>Label profiles</h3>
        <small>标签 × 指数 heatmap</small>
        <div class="panel-body" id="profileBody"></div>
      </section>
    </section>
    <section class="panel" id="mapPanel">
      <h3>Map heatmap</h3>
      <small id="mapStatus" class="text-muted">Waiting for index selection…</small>
      <div class="map-frame" id="mapHost"></div>
      <div class="legend"><span>Low</span><div class="legend-bar"></div><span>High</span></div>
    </section>
  </main>
  <script>
    const payloadStr = sessionStorage.getItem('rootAnalysisPayload');
    let payload = null;
    try {
      payload = JSON.parse(payloadStr || 'null');
    } catch (err) {
      console.error('Failed to parse payload', err);
    }
    const rows = payload?.rows || [];
    const indexColumns = payload?.indices || [];
    const metaCols = payload?.columns ? payload.columns.filter(c => !indexColumns.includes(c)) : [];

    const summaryBody = document.getElementById('summaryBody');
    const testsBody = document.getElementById('testsBody');
    const univariateBody = document.getElementById('univariateBody');
    const correlationBody = document.getElementById('correlationBody');
    const pcaBody = document.getElementById('pcaBody');
    const profileBody = document.getElementById('profileBody');
    const mapHost = document.getElementById('mapHost');
    const mapStatus = document.getElementById('mapStatus');
    const paletteSelector = document.getElementById('colorScale');

    const colorScales = [
      { id: 'ocean', name: 'Ocean', stops: ['#1e3a8a', '#22d3ee', '#f59e0b'] },
      { id: 'magma', name: 'Magma', stops: ['#0f172a', '#a855f7', '#f97316'] },
      { id: 'forest', name: 'Forest', stops: ['#064e3b', '#22c55e', '#fde047'] },
      { id: 'sunset', name: 'Sunset', stops: ['#0f172a', '#ef4444', '#facc15'] }
    ];

    function mean(arr){
      if (!arr.length) return NaN;
      return arr.reduce((a,b)=>a+b,0)/arr.length;
    }

    function stddev(arr){
      if (arr.length < 2) return NaN;
      const m = mean(arr);
      const v = mean(arr.map(v => (v - m) ** 2));
      return Math.sqrt(v);
    }

    function minMax(arr){
      if (!arr.length) return { min: NaN, max: NaN };
      return { min: Math.min(...arr), max: Math.max(...arr) };
    }

    function quantile(arr, q){
      if (!arr.length) return NaN;
      const sorted = [...arr].sort((a,b)=>a-b);
      const pos = (sorted.length - 1) * q;
      const base = Math.floor(pos);
      const rest = pos - base;
      if (sorted[base+1] !== undefined) return sorted[base] + rest * (sorted[base+1] - sorted[base]);
      return sorted[base];
    }

    function groupBy(key){
      const map = new Map();
      rows.forEach(r => {
        const k = r[key] || '(missing)';
        if (!map.has(k)) map.set(k, []);
        map.get(k).push(r);
      });
      return map;
    }

    function computeLabelMeans(index){
      const byLabel = groupBy('label');
      const entries = Array.from(byLabel.entries()).map(([label,list]) => {
        const vals = list.map(r => Number(r[index])).filter(v => !isNaN(v));
        return { label, mean: mean(vals), n: vals.length };
      }).filter(d => !isNaN(d.mean));
      if (!entries.length) return null;
      const min = Math.min(...entries.map(e => e.mean));
      const max = Math.max(...entries.map(e => e.mean));
      return { entries, min, max };
    }

    function computeMapLabelMeans(index){
      const defs = payload?.map?.labels || [];
      if (!defs.length) return computeLabelMeans(index);
      const byLabel = new Map();
      defs.forEach(d => {
        const key = (d.name || d.id || '').trim();
        if (key) byLabel.set(key, { id: d.id, name: key, vals: [] });
      });
      rows.forEach(r => {
        const lbl = (r.label || '').trim();
        if (!lbl) return;
        byLabel.forEach((entry, key) => {
          if (lbl === key || lbl === entry.id) {
            const v = Number(r[index]);
            if (!isNaN(v)) entry.vals.push(v);
          }
        });
      });
      const entries = Array.from(byLabel.values()).map(e => ({
        id: e.id,
        label: e.name,
        mean: mean(e.vals),
        n: e.vals.length
      })).filter(e => !isNaN(e.mean));
      if (!entries.length) return null;
      const min = Math.min(...entries.map(e => e.mean));
      const max = Math.max(...entries.map(e => e.mean));
      return { entries, min, max };
    }

    function makeCard(title, content){
      const div = document.createElement('div');
      div.className = 'card';
      div.innerHTML = `<h4>${title}</h4>${content}`;
      return div;
    }

    function renderMeta(){
      const meta = document.getElementById('metaSummary');
      meta.textContent = `${rows.length} rows · ${indexColumns.length} indices · metadata: ${metaCols.join(', ')}`;
      const idxSel = document.getElementById('indexSelector');
      indexColumns.forEach(c => {
        const opt = document.createElement('option');
        opt.value = c; opt.textContent = c; idxSel.appendChild(opt);
      });
      colorScales.forEach(scale => {
        const opt = document.createElement('option');
        opt.value = scale.id;
        opt.textContent = scale.name;
        paletteSelector.appendChild(opt);
      });
      const badges = document.getElementById('metaBadges');
      metaCols.forEach(c => {
        const span = document.createElement('span');
        span.className = 'tag';
        span.textContent = c;
        badges.appendChild(span);
      });
    }

    function correlationMatrix(features){
      const n = features.length;
      const vals = features.map(f => rows.map(r => Number(r[f])).filter(v=>!isNaN(v)));
      const means = vals.map(v => mean(v));
      const mat = Array.from({length:n}, ()=>Array(n).fill(0));
      for (let i=0;i<n;i++){
        for (let j=i;j<n;j++){
          let num=0, denomA=0, denomB=0;
          for (let k=0;k<rows.length;k++){
            const a = Number(rows[k][features[i]]);
            const b = Number(rows[k][features[j]]);
            if (isNaN(a) || isNaN(b)) continue;
            num += (a-means[i])*(b-means[j]);
            denomA += (a-means[i])**2;
            denomB += (b-means[j])**2;
          }
          const corr = num / Math.sqrt((denomA||1)*(denomB||1));
          mat[i][j] = mat[j][i] = corr;
        }
      }
      return mat;
    }

    function renderCorrelation(features){
      const mat = correlationMatrix(features);
      const cells = [];
      for (let i=0;i<features.length;i++){
        for (let j=0;j<features.length;j++){
          const v = mat[i][j];
          const color = `rgba(59,130,246,${Math.abs(v)})`;
          cells.push(`<div class="heat-cell" style="background:${color};">${v.toFixed(2)}</div>`);
        }
      }
      return makeCard('相关矩阵 (前 10 个指数)', `<div class="heatmap" style="grid-template-columns: repeat(${features.length}, 1fr);">${cells.join('')}</div>`);
    }

    function histogram(values, bins = 12){
      if (!values.length) return null;
      const { min, max } = minMax(values);
      const width = (max - min) || 1;
      const counts = Array(bins).fill(0);
      values.forEach(v => {
        const t = (v - min) / width;
        const idx = Math.min(bins - 1, Math.max(0, Math.floor(t * bins)));
        counts[idx] += 1;
      });
      return { min, max, counts };
    }

    function centerAndScale(arr){
      const m = mean(arr);
      const s = Math.sqrt(mean(arr.map(v => (v-m)**2)) || 1);
      return arr.map(v => (v-m)/s);
    }

    function pca(features, dataset = rows){
      if (features.length < 2) return null;
      const filtered = dataset.filter(r => features.every(f => !isNaN(Number(r[f]))));
      if (!filtered.length) return null;
      const matrix = filtered.map(r => features.map(f => Number(r[f])));
      const cols = features.map((_, idx) => matrix.map(row => row[idx]));
      const data = cols.map(col => centerAndScale(col));
      const n = features.length;
      const len = filtered.length;
      const cov = Array.from({length:n}, ()=>Array(n).fill(0));
      for (let i=0;i<n;i++){
        for (let j=i;j<n;j++){
          let c=0;
          for (let k=0;k<len;k++) c += data[i][k]*data[j][k];
          cov[i][j] = cov[j][i] = c/(len-1 || 1);
        }
      }
      const valsDiag = cov.map((row,i)=>({
        eigen: row[i],
        vector: Array.from({length:n}, (_,k)=> (k===i?1:0))
      }));
      valsDiag.sort((a,b)=>b.eigen - a.eigen);
      return {eigvals: valsDiag.map(v=>v.eigen), eigvecs: valsDiag.map(v=>v.vector), len, rows: filtered, features};
    }

    function renderPCA(features, k, dataset = rows){
      const res = pca(features, dataset);
      if (!res || res.len < 2) return makeCard('PCA', '<div class="text-muted">至少 2 个指数才能做 PCA</div>');
      const pc1 = res.eigvecs[0];
      const pc2 = res.eigvecs[1] || res.eigvecs[0];
      const scores = [];
      for (let i=0;i<res.len;i++){
        const vals = features.map(f => Number(res.rows[i][f]));
        const s1 = vals.reduce((sum,v,idx)=> sum + v*pc1[idx], 0);
        const s2 = vals.reduce((sum,v,idx)=> sum + v*pc2[idx], 0);
        scores.push([s1,s2]);
      }
      const centroids = Array.from({length:k}, ()=>[0,0,0]);
      scores.forEach((s,i)=>{ const c = centroids[i%k]; c[0]+=s[0]; c[1]+=s[1]; c[2]++; });
      centroids.forEach(c=>{ c[0]/=c[2] || 1; c[1]/=c[2] || 1; });
      const assignments = scores.map(s => {
        let best=0, bestDist=Infinity;
        centroids.forEach((c,idx)=>{
          const d=(s[0]-c[0])**2 + (s[1]-c[1])**2;
          if (d<bestDist) {bestDist=d; best=idx;}
        });
        return best+1;
      });
      const clusters = Array.from({length:k}, ()=>({count:0}));
      assignments.forEach(a => clusters[a-1].count++);
      const xs = scores.map(s => s[0]);
      const ys = scores.map(s => s[1]);
      const minX = Math.min(...xs), maxX = Math.max(...xs);
      const minY = Math.min(...ys), maxY = Math.max(...ys);
      const width=320, height=240, padding=46;
      const scaleX = (v)=> padding + ((v - minX)/((maxX-minX)||1))*(width-padding*1.5);
      const scaleY = (v)=> height-padding - ((v - minY)/((maxY-minY)||1))*(height-padding*1.5);
      const palette = ['#60a5fa','#34d399','#f472b6','#fbbf24','#a78bfa','#f97316'];
      const dots = scores.map((s,idx)=>{
        const c = palette[(assignments[idx]-1)%palette.length];
        return `<circle cx="${scaleX(s[0])}" cy="${scaleY(s[1])}" r="4" fill="${c}" fill-opacity="0.8" />`;
      }).join('');
      const axis = `<line x1="${padding}" y1="${height-padding}" x2="${width-padding/2}" y2="${height-padding}" stroke="#475569" />
                    <line x1="${padding}" y1="${padding/2}" x2="${padding}" y2="${height-padding}" stroke="#475569" />`;
      const xTicks = [0,0.25,0.5,0.75,1].map(t=>{
        const x = padding + t*(width-padding*1.5);
        const v = (minX + (maxX-minX)*t).toFixed(2);
        return `<line x1="${x}" y1="${height-padding}" x2="${x}" y2="${height-padding+6}" stroke="#475569" />
                <text x="${x}" y="${height-padding+18}" text-anchor="middle" font-size="10" fill="#cbd5f5">${v}</text>`;
      }).join('');
      const yTicks = [0,0.25,0.5,0.75,1].map(t=>{
        const y = height-padding - t*(height-padding*1.5);
        const v = (minY + (maxY-minY)*t).toFixed(2);
        return `<line x1="${padding-6}" y1="${y}" x2="${padding}" y2="${y}" stroke="#475569" />
                <text x="${padding-10}" y="${y+3}" text-anchor="end" font-size="10" fill="#cbd5f5">${v}</text>`;
      }).join('');
      const legend = clusters.map((c,idx)=>`<div class="text-muted">Cluster ${idx+1}: n=${c.count}</div>`).join('');
      const svg = `<svg width="${width}" height="${height}" style="background:#0b1530;border:1px solid #1f2937;border-radius:6px;">${axis}${xTicks}${yTicks}${dots}
        <text x="${width/2}" y="${height-8}" text-anchor="middle" font-size="11" fill="#cbd5f5">PC1 score</text>
        <text x="14" y="${height/2}" transform="rotate(-90 14 ${height/2})" font-size="11" fill="#cbd5f5">PC2 score</text>
      </svg>`;
      return makeCard('PCA + k-means (scores)', svg + legend);
    }

    function renderLabelCohorts(index){
      const map = groupBy('label');
      if (!map.size) return makeCard('Label cohorts', '<div class="text-muted">No label information found.</div>');
      const rowsHtml = Array.from(map.entries()).map(([label, list]) => {
        const vals = list.map(r => Number(r[index])).filter(v => !isNaN(v));
        const q1 = quantile(vals,0.25), med = quantile(vals,0.5), q3 = quantile(vals,0.75);
        const meanVal = mean(vals);
        const fmt = v => isNaN(v) ? 'NA' : v.toFixed(3);
        return `<tr><td>${label}</td><td>${list.length}</td><td>${fmt(meanVal)}</td><td>${fmt(q1)}</td><td>${fmt(med)}</td><td>${fmt(q3)}</td></tr>`;
      }).join('');
      const table = `<table><thead><tr><th>Label</th><th>n</th><th>Mean</th><th>Q1</th><th>Median</th><th>Q3</th></tr></thead><tbody>${rowsHtml}</tbody></table>`;
      return makeCard('同标签内部的分布概览', table);
    }

    function renderSummary(index){
      const vals = rows.map(r => Number(r[index])).filter(v => !isNaN(v));
      const stats = {
        mean: mean(vals),
        median: quantile(vals, 0.5),
        std: stddev(vals),
        ...minMax(vals)
      };
      const fmt = v => isNaN(v) ? 'NA' : v.toFixed(4);
      const summary = `
        <table>
          <thead><tr><th>Index</th><th>Mean</th><th>Median</th><th>Std</th><th>Min</th><th>Max</th></tr></thead>
          <tbody><tr><td>${index}</td><td>${fmt(stats.mean)}</td><td>${fmt(stats.median)}</td><td>${fmt(stats.std)}</td><td>${fmt(stats.min)}</td><td>${fmt(stats.max)}</td></tr></tbody>
        </table>
      `;
      const labelCard = renderLabelCohorts(index).outerHTML;
      return summary + labelCard;
    }

    function logGamma(z){
      const p = [
        676.5203681218851, -1259.1392167224028, 771.32342877765313,
        -176.61502916214059, 12.507343278686905, -0.13857109526572012,
        9.9843695780195716e-6, 1.5056327351493116e-7
      ];
      if (z < 0.5) {
        return Math.log(Math.PI) - Math.log(Math.sin(Math.PI*z)) - logGamma(1 - z);
      }
      z -= 1;
      let x = 0.99999999999980993;
      for (let i = 0; i < p.length; i++) x += p[i] / (z + i + 1);
      const t = z + p.length - 0.5;
      return 0.5 * Math.log(2 * Math.PI) + (z + 0.5) * Math.log(t) - t + Math.log(x);
    }

    function betacf(a, b, x){
      const MAX_ITER = 200;
      const EPS = 3e-7;
      let qab = a + b;
      let qap = a + 1;
      let qam = a - 1;
      let c = 1;
      let d = 1 - qab * x / qap;
      if (Math.abs(d) < 1e-30) d = 1e-30;
      d = 1 / d;
      let h = d;
      for (let m = 1; m <= MAX_ITER; m++) {
        let m2 = 2 * m;
        let aa = m * (b - m) * x / ((qam + m2) * (a + m2));
        d = 1 + aa * d;
        if (Math.abs(d) < 1e-30) d = 1e-30;
        c = 1 + aa / c;
        if (Math.abs(c) < 1e-30) c = 1e-30;
        d = 1 / d;
        h *= d * c;
        aa = -(a + m) * (qab + m) * x / ((a + m2) * (qap + m2));
        d = 1 + aa * d;
        if (Math.abs(d) < 1e-30) d = 1e-30;
        c = 1 + aa / c;
        if (Math.abs(c) < 1e-30) c = 1e-30;
        d = 1 / d;
        const del = d * c;
        h *= del;
        if (Math.abs(del - 1.0) < EPS) break;
      }
      return h;
    }

    function betai(a, b, x){
      if (x <= 0) return 0;
      if (x >= 1) return 1;
      const bt = Math.exp(logGamma(a + b) - logGamma(a) - logGamma(b) + a * Math.log(x) + b * Math.log(1 - x));
      if (x < (a + 1) / (a + b + 2)) {
        return bt * betacf(a, b, x) / a;
      }
      return 1 - bt * betacf(b, a, 1 - x) / b;
    }

    function fCdf(x, d1, d2){
      if (x <= 0) return 0;
      const xx = (d1 * x) / (d1 * x + d2);
      return betai(d1 / 2, d2 / 2, xx);
    }

    function oneWayAnova(index){
      const groups = groupBy('label');
      const entries = Array.from(groups.entries())
        .map(([label, list]) => ({
          label,
          values: list.map(r => Number(r[index])).filter(v => !isNaN(v))
        }))
        .filter(e => e.values.length);
      const k = entries.length;
      const n = entries.reduce((sum, e) => sum + e.values.length, 0);
      if (k < 2 || n <= k) return null;
      const overall = mean(entries.flatMap(e => e.values));
      let ssb = 0;
      let ssw = 0;
      entries.forEach(e => {
        const m = mean(e.values);
        ssb += e.values.length * (m - overall) ** 2;
        e.values.forEach(v => { ssw += (v - m) ** 2; });
      });
      const dfb = k - 1;
      const dfw = n - k;
      const msb = ssb / dfb;
      const msw = ssw / dfw;
      const f = msw ? msb / msw : NaN;
      const p = isFinite(f) ? 1 - fCdf(f, dfb, dfw) : NaN;
      const eta2 = (ssb + ssw) ? ssb / (ssb + ssw) : NaN;
      return { f, p, dfb, dfw, eta2, k, n };
    }

    function renderPerIndexTests(){
      const rowsHtml = indexColumns.map(idx => {
        const res = oneWayAnova(idx);
        if (!res) {
          return `<tr><td>${idx}</td><td colspan="5">NA (labels不足)</td></tr>`;
        }
        const fmt = v => isNaN(v) ? 'NA' : v.toFixed(4);
        return `
          <tr>
            <td>${idx}</td>
            <td>F(${res.dfb}, ${res.dfw})=${fmt(res.f)}</td>
            <td>p=${fmt(res.p)}</td>
            <td>η²=${fmt(res.eta2)}</td>
            <td>k=${res.k}</td>
            <td>n=${res.n}</td>
          </tr>
        `;
      }).join('');
      return `
        <table>
          <thead>
            <tr><th>Index</th><th>F-stat</th><th>p-value</th><th>Effect</th><th>Groups</th><th>Samples</th></tr>
          </thead>
          <tbody>${rowsHtml}</tbody>
        </table>
      `;
    }

    function renderUnivariate(index){
      const vals = rows.map(r => Number(r[index])).filter(v => !isNaN(v));
      if (!vals.length) return '<div class="text-muted">No numeric values available.</div>';
      const hist = histogram(vals, 12);
      const maxCount = Math.max(...hist.counts);
      const width = 360;
      const height = 180;
      const padding = 30;
      const barWidth = (width - padding * 2) / hist.counts.length;
      const bars = hist.counts.map((c, i) => {
        const h = (c / (maxCount || 1)) * (height - padding * 2);
        const x = padding + i * barWidth;
        const y = height - padding - h;
        return `<rect x="${x}" y="${y}" width="${barWidth * 0.9}" height="${h}" fill="#38bdf8" fill-opacity="0.75" />`;
      }).join('');
      const xLabels = [0, 0.5, 1].map(t => {
        const v = (hist.min + (hist.max - hist.min) * t).toFixed(2);
        const x = padding + t * (width - padding * 2);
        return `<text x="${x}" y="${height - 8}" text-anchor="middle" font-size="10" fill="#cbd5f5">${v}</text>`;
      }).join('');
      const svg = `<svg width="${width}" height="${height}" style="background:#0b1530;border:1px solid #1f2937;border-radius:6px;">
        ${bars}
        <line x1="${padding}" y1="${height - padding}" x2="${width - padding}" y2="${height - padding}" stroke="#475569" />
        <line x1="${padding}" y1="${padding}" x2="${padding}" y2="${height - padding}" stroke="#475569" />
        ${xLabels}
      </svg>`;
      const stats = `
        <div class="text-muted">n=${vals.length} · mean=${mean(vals).toFixed(3)} · median=${quantile(vals,0.5).toFixed(3)} · std=${stddev(vals).toFixed(3)}</div>
      `;
      return `${svg}${stats}`;
    }

    function renderLabelBars(index){
      const stat = computeLabelMeans(index);
      if (!stat) return makeCard('Label means', '<div class="text-muted">No label information found.</div>');
      const stats = stat.entries.sort((a,b)=>b.mean-a.mean);
      const width = 320, height = 200, padding = 40;
      const barHeight = (height - padding*2) / stats.length;
      const maxVal = Math.max(...stats.map(s=>s.mean));
      const axis = `<line x1="${padding}" y1="${padding}" x2="${padding}" y2="${height-padding}" stroke="#475569" stroke-width="1" />
                    <line x1="${padding}" y1="${height-padding}" x2="${width-10}" y2="${height-padding}" stroke="#475569" stroke-width="1" />`;
      const bars = stats.map((s,i)=>{
        const y = padding + i*barHeight + barHeight*0.15;
        const w = maxVal ? (s.mean/maxVal)*(width-padding*1.5) : 0;
        return `
          <rect x="${padding}" y="${y}" width="${w}" height="${barHeight*0.7}" fill="#60a5fa" fill-opacity="0.8" />
          <text x="${padding-6}" y="${y+barHeight*0.5}" text-anchor="end" dominant-baseline="middle" font-size="11" fill="#e5e7eb">${s.label}</text>
          <text x="${padding+w+4}" y="${y+barHeight*0.5}" dominant-baseline="middle" font-size="10" fill="#cbd5f5">${s.mean.toFixed(3)} (n=${s.n})</text>
        `;
      }).join('');
      const ticks = [0,0.25,0.5,0.75,1].map(t=>{
        const x = padding + t*(width-padding*1.5);
        const v = (maxVal*t).toFixed(2);
        return `<line x1="${x}" y1="${height-padding}" x2="${x}" y2="${height-padding+6}" stroke="#475569" />
                <text x="${x}" y="${height-padding+18}" text-anchor="middle" font-size="10" fill="#cbd5f5">${v}</text>`;
      }).join('');
      const svg = `<svg width="${width}" height="${height}" style="background:#0b1530;border:1px solid #1f2937;border-radius:6px;">${axis}${bars}${ticks}
        <text x="${width/2}" y="${height-6}" text-anchor="middle" font-size="11" fill="#cbd5f5">Mean ${index}</text>
      </svg>`;
      return makeCard('Label means', svg);
    }

    function renderLabelIndexHeatmap(){
      const map = groupBy('label');
      const labels = Array.from(map.keys()).filter(l => l !== '(missing)').slice(0,8);
      const indices = indexColumns.slice(0,6);
      if (!labels.length || !indices.length) return makeCard('Label × index heatmap', '<div class="text-muted">需要标签与指数。</div>');
      const cells = [];
      let globalMin = Infinity, globalMax = -Infinity;
      const gridData = labels.map(lbl => {
        const rowsList = map.get(lbl) || [];
        const vals = indices.map(idx => {
          const arr = rowsList.map(r => Number(r[idx])).filter(v=>!isNaN(v));
          const m = arr.length ? mean(arr) : NaN;
          if (!isNaN(m)) { globalMin = Math.min(globalMin, m); globalMax = Math.max(globalMax, m); }
          return m;
        });
        return { label: lbl, vals };
      });
      const scale = (v) => {
        if (!isFinite(globalMin) || !isFinite(globalMax)) return '#111827';
        if (isNaN(v)) return '#111827';
        const t = (v - globalMin)/((globalMax-globalMin)||1);
        const r = Math.round(255*t);
        const b = Math.round(255*(1-t));
        return `rgb(${r},${Math.round(120+60*t)},${b})`;
      };
      gridData.forEach(row => {
        cells.push(`<div class="heat-cell" style="background:#0b1530;font-weight:600;">${row.label}</div>`);
        row.vals.forEach(v => cells.push(`<div class="heat-cell" style="background:${scale(v)};">${isNaN(v)?'NA':v.toFixed(2)}</div>`));
      });
      const header = ['Label', ...indices].map(t => `<div class="heat-cell" style="background:#0b1530;font-weight:600;">${t}</div>`).join('');
      return makeCard('Label × index heatmap', `<div class="heatmap" style="grid-template-columns: repeat(${indices.length+1},1fr);">${header}${cells.join('')}</div>`);
    }

    function hexToRgb(hex){
      const clean = hex.replace('#', '');
      const num = parseInt(clean, 16);
      return { r: (num >> 16) & 255, g: (num >> 8) & 255, b: num & 255 };
    }

    function mixColor(a, b, t){
      const ar = hexToRgb(a);
      const br = hexToRgb(b);
      const r = Math.round(ar.r + (br.r - ar.r) * t);
      const g = Math.round(ar.g + (br.g - ar.g) * t);
      const bch = Math.round(ar.b + (br.b - ar.b) * t);
      return `rgb(${r},${g},${bch})`;
    }

    function valueToHeatColor(val, min, max){
      const scaleId = paletteSelector.value || colorScales[0].id;
      const scale = colorScales.find(s => s.id === scaleId) || colorScales[0];
      const t = (val - min) / ((max - min) || 1);
      if (scale.stops.length === 2) {
        return mixColor(scale.stops[0], scale.stops[1], t);
      }
      if (t <= 0.5) {
        return mixColor(scale.stops[0], scale.stops[1], t * 2);
      }
      return mixColor(scale.stops[1], scale.stops[2], (t - 0.5) * 2);
    }

    function renderMapHeat(index){
      const status = document.getElementById('mapStatus');
      const host = document.getElementById('mapHost');
      if (!payload?.map || !payload.map.svg){
        status.textContent = 'No map snapshot available from index page.';
        host.innerHTML = '';
        return;
      }
      const stats = computeMapLabelMeans(index);
      if (!stats){
        status.textContent = 'No numeric values for this index.';
        host.innerHTML = '';
        return;
      }
      host.innerHTML = payload.map.svg;
      const svg = host.querySelector('svg');
      if (!svg){
        status.textContent = 'Map snapshot missing <svg> root.';
        return;
      }
      const labelMap = new Map((payload.map.labels||[]).map(l => [l.id, l]));
      const valueMap = new Map();
      stats.entries.forEach(e => {
        valueMap.set(e.label, e.mean);
        if (e.id) valueMap.set(e.id, e.mean);
      });
      host.querySelectorAll('path').forEach(p => {
        const roiId = p.id;
        const labId = payload.map.assignments?.[roiId];
        const labName = labId ? (labelMap.get(labId)?.name || labId) : null;
        const v = labName ? valueMap.get(labName) : null;
        p.setAttribute('fill', v!=null ? valueToHeatColor(v, stats.min, stats.max) : '#1f2937');
        p.setAttribute('stroke', '#000');
        p.setAttribute('stroke-width', '1');
      });
      status.textContent = `Index: ${index} · labels=${stats.entries.length}`;
    }

    function renderAll(){
      if (!rows.length) {
        summaryBody.innerHTML = makeCard('No data found', '<div class="text-muted">从 index 页面加载 CSV/TSV 后再打开本页面。</div>').outerHTML;
        testsBody.innerHTML = '';
        univariateBody.innerHTML = '';
        correlationBody.innerHTML = '';
        pcaBody.innerHTML = '';
        profileBody.innerHTML = '';
        return;
      }
      if (!indexColumns.length) {
        summaryBody.innerHTML = makeCard('No numeric indices', '<div class="text-muted">请在表格中提供至少一个指数列。</div>').outerHTML;
        testsBody.innerHTML = '';
        univariateBody.innerHTML = '';
        correlationBody.innerHTML = '';
        pcaBody.innerHTML = '';
        profileBody.innerHTML = '';
        return;
      }
      const index = document.getElementById('indexSelector').value || indexColumns[0];
      const k = Number(document.getElementById('clusterInput').value) || 3;
      summaryBody.innerHTML = renderSummary(index);
      testsBody.innerHTML = renderPerIndexTests();
      univariateBody.innerHTML = renderUnivariate(index);
      correlationBody.innerHTML = renderCorrelation(indexColumns.slice(0, 10)).outerHTML;
      pcaBody.innerHTML = `${renderLabelBars(index).outerHTML}${renderPCA(indexColumns, k).outerHTML}`;
      profileBody.innerHTML = renderLabelIndexHeatmap().outerHTML;
      renderMapHeat(index);
    }

    if (rows.length) {
      renderMeta();
      const idxSel = document.getElementById('indexSelector');
      if (indexColumns.length && !idxSel.value) idxSel.value = indexColumns[0];
      idxSel.addEventListener('change', renderAll);
      document.getElementById('clusterInput').addEventListener('change', renderAll);
      paletteSelector.addEventListener('change', renderAll);
      renderAll();
    } else {
      renderAll();
    }
  </script>
</body>
</html>
