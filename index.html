<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Root SVG Map Labeler</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    :root {
      --bg: #020617;
      --panel: #0f172a;
      --panel2: #111827;
      --border: #1f2937;
      --accent: #3b82f6;
      --accent-soft: rgba(59, 130, 246, 0.16);
      --text: #e5e7eb;
      --muted: #9ca3af;
      --danger: #f97373;
    }
    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: radial-gradient(circle at top, #111827 0, #020617 55%);
      color: var(--text);
      height: 100vh;
      display: flex;
      flex-direction: column;
    }

    header {
      padding: 0.6rem 1rem;
      border-bottom: 1px solid var(--border);
      background: rgba(15, 23, 42, 0.95);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    header h1 {
      margin: 0;
      font-size: 1rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: #93c5fd;
    }
    header span {
      font-size: 0.8rem;
      color: var(--muted);
    }

    .pill {
      font-size: 0.75rem;
      padding: 0.2rem 0.6rem;
      border-radius: 999px;
      border: 1px solid var(--border);
      color: var(--muted);
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
      background: rgba(15, 23, 42, 0.85);
    }

    main {
      flex: 1;
      display: grid;
      grid-template-columns: 260px minmax(0, 1.6fr) 260px;
      gap: 0.6rem;
      padding: 0.6rem;
      min-height: 0;
    }
    @media (max-width: 1024px) {
      main {
        grid-template-columns: minmax(0, 1fr);
        grid-template-rows: auto auto auto;
      }
    }

    .panel {
      background: var(--panel);
      border-radius: 0.75rem;
      border: 1px solid var(--border);
      padding: 0.7rem;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }
    .panel-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 0.5rem;
    }
    .panel-title {
      font-size: 0.85rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--muted);
    }
    .panel-subtitle {
      font-size: 0.75rem;
      color: var(--muted);
    }
    .panel-body {
      flex: 1;
      overflow: auto;
      padding-right: 0.3rem;
    }

    .section {
      margin-bottom: 0.8rem;
      padding-bottom: 0.6rem;
      border-bottom: 1px dashed #1f2937;
    }
    .section:last-child {
      border-bottom: none;
      margin-bottom: 0;
      padding-bottom: 0;
    }
    .section-title {
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: var(--muted);
      margin-bottom: 0.3rem;
    }

    label {
      display: block;
      font-size: 0.8rem;
      color: var(--muted);
      margin-bottom: 0.2rem;
    }

    input[type="file"],
    input[type="text"] {
      width: 100%;
      font-size: 0.8rem;
      padding: 0.3rem 0.4rem;
      border-radius: 0.45rem;
      border: 1px solid var(--border);
      background: var(--panel2);
      color: var(--text);
      outline: none;
    }
    input[type="file"] { padding: 0.2rem 0.3rem; }
    input[type="text"]:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 1px var(--accent-soft);
    }
    input[type="color"] {
      width: 100%;
      height: 1.8rem;
      border-radius: 0.4rem;
      border: 1px solid var(--border);
      background: transparent;
      padding: 0;
      cursor: pointer;
    }

    .button {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 0.8rem;
      padding: 0.28rem 0.6rem;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: #020617;
      color: var(--text);
      cursor: pointer;
      gap: 0.3rem;
      transition: all 0.12s ease;
    }
    .button.small { font-size: 0.75rem; padding: 0.18rem 0.5rem; }
    .button.primary {
      background: linear-gradient(135deg, #2563eb, #4f46e5);
      border-color: transparent;
      color: white;
    }
    .button.danger {
      border-color: rgba(248, 113, 113, 0.8);
      color: #fecaca;
    }
    .button:hover {
      border-color: var(--accent);
      background: #020617;
    }
    .button.primary:hover {
      box-shadow: 0 10px 25px rgba(37, 99, 235, 0.6);
      transform: translateY(-1px);
    }
    .button.danger:hover {
      background: rgba(185, 28, 28, 0.45);
    }
    .button.mode-active {
      border-color: var(--accent);
      background: rgba(37,99,235,0.18);
      color: #bfdbfe;
    }

    .row {
      display: flex;
      gap: 0.4rem;
      margin-bottom: 0.4rem;
    }
    .row > * { flex: 1; }

    .hint {
      font-size: 0.72rem;
      color: var(--muted);
      line-height: 1.4;
      margin-top: 0.25rem;
    }

    /* SVG 视区 */
    #svgViewport {
      flex: 1;
      min-height: 0;
      border-radius: 0.7rem;
      border: 1px solid var(--border);
      background: #0d1320;
      position: relative;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      cursor: grab;
    }
    #svgViewport.grabbing {
      cursor: grabbing;
    }

    #svgContainer {
      position: relative;
      display: inline-block;
      transform-origin: top left;
    }
    #svgContainer svg {
      display: block;
      background: #0c111b;
    }

    #boxOverlay {
      position: absolute;
      border: 1px dashed rgba(96,165,250,0.9);
      background: rgba(37,99,235,0.18);
      pointer-events: none;
      display: none;
      z-index: 5;
    }

    .empty-state {
      text-align: center;
      color: var(--muted);
      font-size: 0.8rem;
      padding: 1.2rem;
    }

    .status-line { font-size: 0.72rem; color: var(--muted); margin-top: 0.3rem; }

    /* Label list */
    #labelList {
      display: flex;
      flex-direction: column;
      gap: 0.3rem;
      margin-top: 0.3rem;
    }
    .label-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0.25rem 0.4rem;
      background: rgba(15, 23, 42, 0.95);
      border-radius: 0.5rem;
      border: 1px solid transparent;
      cursor: pointer;
      gap: 0.4rem;
      transition: all 0.12s ease;
    }
    .label-item:hover { border-color: var(--border); }
    .label-item.active {
      border-color: var(--accent);
      box-shadow: 0 0 0 1px var(--accent-soft);
      background: radial-gradient(circle at top, var(--accent-soft), #020617);
    }
    .label-color-dot {
      width: 14px;
      height: 14px;
      border-radius: 999px;
      border: 1px solid #020617;
      flex-shrink: 0;
    }
    .label-main { flex: 1; min-width: 0; }
    .label-main div:first-child {
      font-size: 0.8rem;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .label-main div:last-child {
      font-size: 0.7rem;
      color: var(--muted);
    }
    .badge {
      font-size: 0.7rem;
      padding: 0.05rem 0.35rem;
      border-radius: 999px;
      border: 1px solid #475569;
      color: var(--muted);
    }

    footer {
      padding: 0.3rem 0.8rem;
      font-size: 0.72rem;
      color: var(--muted);
      border-top: 1px solid var(--border);
      background: rgba(15, 23, 42, 0.96);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    /* ROI：更深灰底色；hover 变白/淡色 + 粗线 + 强光晕 */
    .roi-shape {
      cursor: pointer;
      transition: fill 0.12s ease-out, filter 0.12s ease-out, stroke-width 0.12s ease-out, transform 0.12s ease-out;
      vector-effect: non-scaling-stroke;
      transform-box: fill-box;
      pointer-events: visiblePainted;
      will-change: transform, filter, fill;
    }
    .roi-hover {
      filter: drop-shadow(0 0 7px rgba(148, 163, 184, 0.98));
      transform: scale(1.02);
      transform-origin: center;
    }
  </style>
</head>
<body>
<header>
  <div>
    <h1>Root SVG Map Labeler</h1>
    <span>Directly use the root SVG as a high-resolution map and add labels.</span>
  </div>
  <div class="pill">
    <span>Wheel: zoom at mouse</span>
    <span>Label mode: click or drag box to label ROIs</span>
    <span>Move mode: drag to pan</span>
  </div>
</header>

<main>
  <!-- 左侧：项目 & 导入导出 -->
  <aside class="panel">
    <div class="panel-header">
      <div class="panel-title">Map & Project</div>
    </div>
    <div class="panel-body">
      <div class="section">
        <div class="section-title">1. Root map (SVG)</div>
        <div class="hint">
          This page always uses <strong>Vector image_ blank root.svg</strong> in the same folder.<br/>
          The SVG geometry is never changed; only labels are added on top.
        </div>
        <div id="mapInfo" class="status-line"></div>
      </div>

      <div class="section">
        <div class="section-title">2. Import / Export labels</div>
        <div class="row">
          <button class="button small primary" id="exportJsonBtn">Export labels (JSON)</button>
          <button class="button small" id="clearAssignmentsBtn">Clear ROI labels</button>
        </div>
        <label for="labelsFileInput">Import labels JSON</label>
        <input type="file" id="labelsFileInput" accept="application/json,.json" />
        <div class="hint">
          JSON contains: label definitions + ROI assignments.<br/>
          SVG file is assumed to be the same root map.
        </div>
      </div>

      <div class="section">
        <div class="section-title">3. Global stats</div>
        <div id="globalStats" class="hint">SVG not loaded yet.</div>
      </div>
    </div>
  </aside>

  <!-- 中间：SVG 视图区 -->
  <section class="panel">
    <div class="panel-header">
      <div>
        <div class="panel-title">Root map view (SVG)</div>
        <div class="panel-subtitle">
          Each cell contour is a vector ROI path. Only fills are changed; strokes remain crisp and uniform.
        </div>
        <div style="margin-top:0.35rem; display:flex; gap:0.3rem;">
          <button class="button small" id="modeLabelBtn">Label</button>
          <button class="button small mode-active" id="modeMoveBtn">Move</button>
        </div>
      </div>
      <div id="hoverInfo" class="pill">Loading SVG…</div>
    </div>
    <div id="svgViewport">
      <div id="svgContainer">
        <div id="emptyState" class="empty-state">
          Loading <strong>Vector image_ blank root.svg</strong>…
        </div>
      </div>
      <div id="boxOverlay"></div>
    </div>
  </section>

  <!-- 右侧：标签管理 -->
  <aside class="panel">
    <div class="panel-header">
      <div class="panel-title">Labels</div>
      <button class="button small danger" id="clearAllLabelsBtn">Delete all labels</button>
    </div>
    <div class="panel-body">
      <div class="section">
        <div class="section-title">1. Create label</div>
        <label for="labelNameInput">Label name</label>
        <input type="text" id="labelNameInput" placeholder="e.g. Meristem / Cortex / QC" />
        <label for="labelColorInput">Label color</label>
        <input type="color" id="labelColorInput" />
        <button class="button primary" id="addLabelBtn" style="margin-top:0.4rem;width:100%;">Add label</button>
        <div class="hint">
          Label mode:<br/>
          • Click ROI → toggle this ROI’s label (same as before).<br/>
          • Drag a box → set/overwrite label for all ROIs in the box (no toggle).<br/>
          No active label: click/box clears labels.
        </div>
      </div>

      <div class="section">
        <div class="section-title">2. Label list</div>
        <div id="labelList"></div>
        <div id="labelEmptyHint" class="hint">No labels yet. Please create at least one.</div>
      </div>
    </div>
  </aside>
</main>

<footer>
  <div>SVG geometry stays untouched. Only label fills are stored and exported.</div>
  <div id="selectionStatus">No ROI selected</div>
</footer>

<script>
  // ----------- 基本状态 -----------
  const svgViewport     = document.getElementById("svgViewport");
  const svgContainer    = document.getElementById("svgContainer");
  const boxOverlay      = document.getElementById("boxOverlay");
  const emptyState      = document.getElementById("emptyState");
  const hoverInfo       = document.getElementById("hoverInfo");
  const mapInfo         = document.getElementById("mapInfo");
  const globalStats     = document.getElementById("globalStats");
  const selectionStatus = document.getElementById("selectionStatus");

  const exportJsonBtn       = document.getElementById("exportJsonBtn");
  const labelsFileInput     = document.getElementById("labelsFileInput");
  const clearAssignmentsBtn = document.getElementById("clearAssignmentsBtn");

  const addLabelBtn       = document.getElementById("addLabelBtn");
  const labelNameInput    = document.getElementById("labelNameInput");
  const labelColorInput   = document.getElementById("labelColorInput");
  const labelListEl       = document.getElementById("labelList");
  const labelEmptyHint    = document.getElementById("labelEmptyHint");
  const clearAllLabelsBtn = document.getElementById("clearAllLabelsBtn");

  const modeLabelBtn = document.getElementById("modeLabelBtn");
  const modeMoveBtn  = document.getElementById("modeMoveBtn");

  const defaultColors = ["#ef4444","#f97316","#facc15","#22c55e","#14b8a6",
                         "#0ea5e9","#6366f1","#8b5cf6","#ec4899","#f97373"];
  let colorIndex = 0;

  const SVG_FILENAME = "Vector image_ blank root.svg";

  let svgEl = null;
  let svgWidth = 0, svgHeight = 0;
  let baseScale = 1, viewScale = 1;
  let panX = 0, panY = 0;

  // Move 模式拖动
  let isPanning = false;
  let panStartX = 0, panStartY = 0;
  let panStartClientX = 0, panStartClientY = 0;
  let panMoved = false;

  // Label 模式：点击/框选
  let interactionMode = "move"; // "label" | "move"
  let labelMouseDown = false;
  let labelStartClientX = 0, labelStartClientY = 0;
  let labelCurrentClientX = 0, labelCurrentClientY = 0;
  let labelIsBox = false;
  let labelBoxMoved = false;
  let ignoreNextClick = false;

  // ROI & 标签
  let roiElements = [];      // SVG path elements
  let labels = [];           // [{id, name, color}]
  let activeLabelId = null;
  let roiAssignments = {};   // { roiId: labelId }
  let roiBBox = null;        // cached ROI bbox for centering/scale

  function getNextColor(){
    const c = defaultColors[colorIndex % defaultColors.length];
    colorIndex++;
    return c;
  }
  function hexToRgb(hex){
    hex = hex.replace("#","");
    if (hex.length === 3) hex = hex.split("").map(c => c + c).join("");
    const num = parseInt(hex,16);
    return { r:(num>>16)&255, g:(num>>8)&255, b:num&255 };
  }
  function lightenHex(hex, factor=0.35){
    // factor: 0~1, 越大越接近白
    const {r,g,b} = hexToRgb(hex);
    const nr = Math.round(r + (255 - r) * factor);
    const ng = Math.round(g + (255 - g) * factor);
    const nb = Math.round(b + (255 - b) * factor);
    return `rgb(${nr}, ${ng}, ${nb})`;
  }

  function updateGlobalStats(){
    if (!roiElements.length) {
      globalStats.textContent = "SVG not loaded yet.";
      return;
    }
    const total = roiElements.length;
    const labeled = Object.values(roiAssignments).filter(v => !!v).length;
    const pct = total ? (labeled / total * 100).toFixed(1) : 0;
    globalStats.innerHTML = `Total ROIs: <strong>${total}</strong> · Labeled: <strong>${labeled}</strong> (${pct}%)`;
  }
  function updateSelectionStatus(text){
    selectionStatus.textContent = text || "No ROI selected";
  }

  function recomputeRoiBBox(){
    if (!roiElements.length) {
      roiBBox = null;
      return;
    }
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    roiElements.forEach(el => {
      const b = el.getBBox();
      minX = Math.min(minX, b.x);
      minY = Math.min(minY, b.y);
      maxX = Math.max(maxX, b.x + b.width);
      maxY = Math.max(maxY, b.y + b.height);
    });
    roiBBox = {
      minX,
      minY,
      maxX,
      maxY,
      width: maxX - minX,
      height: maxY - minY
    };
  }

  function getContentMetrics(){
    const hasBBox = roiBBox && isFinite(roiBBox.width) && isFinite(roiBBox.height) && roiBBox.width > 0 && roiBBox.height > 0;
    return {
      width: hasBBox ? roiBBox.width : svgWidth,
      height: hasBBox ? roiBBox.height : svgHeight,
      offsetX: hasBBox ? roiBBox.minX : 0,
      offsetY: hasBBox ? roiBBox.minY : 0
    };
  }

  // ---------- 模式切换 ----------
  function setInteractionMode(mode){
    interactionMode = mode;
    modeLabelBtn.classList.toggle("mode-active", mode === "label");
    modeMoveBtn.classList.toggle("mode-active", mode === "move");
  }
  modeLabelBtn.addEventListener("click", () => setInteractionMode("label"));
  modeMoveBtn.addEventListener("click",  () => setInteractionMode("move"));

  // ----------- SVG 缩放 / 平移 -----------
  function computeBaseScale(){
    if (!svgWidth || !svgHeight) return;
    const rect = svgViewport.getBoundingClientRect();
    const padding = 24; // keep some breathing room on all sides
    const { width: contentWidth, height: contentHeight } = getContentMetrics();
    const scaleByHeight = (rect.height - padding * 2) / contentHeight;
    const scaleByWidth  = (rect.width  - padding * 2) / contentWidth;
    baseScale = Math.min(scaleByWidth, scaleByHeight);
  }

  function updateSvgTransform(){
    if (!svgEl) return;
    const scale = baseScale * viewScale;
    const { width, height, offsetX, offsetY } = getContentMetrics();
    const rect = svgViewport.getBoundingClientRect();
    const tx = (rect.width - width * scale) / 2 + panX - offsetX * scale;
    const ty = (rect.height - height * scale) / 2 + panY - offsetY * scale;
    svgContainer.style.transformOrigin = "top left";
    svgContainer.style.transform = `translate(${tx}px, ${ty}px) scale(${scale})`;
  }

  function centerOnRoiBBox(){
    if (!roiElements.length || !roiBBox) return;
    const rect = svgViewport.getBoundingClientRect();
    const scale = baseScale * viewScale;
    const { width, height, offsetX, offsetY } = getContentMetrics();
    const cx = offsetX + width / 2;
    const cy = offsetY + height / 2;

    // 让 ROI 中心对齐到视口中心
    panX = rect.width / 2 - cx * scale;
    panY = rect.height / 2 - cy * scale;
    updateSvgTransform();
  }

  function clientToSvg(clientX, clientY){
    const rect = svgViewport.getBoundingClientRect();
    const scale = baseScale * viewScale;
    const { width, height, offsetX, offsetY } = getContentMetrics();
    const tx = (rect.width - width * scale) / 2 + panX - offsetX * scale;
    const ty = (rect.height - height * scale) / 2 + panY - offsetY * scale;
    const x = (clientX - rect.left - tx) / scale;
    const y = (clientY - rect.top - ty) / scale;
    return { x, y };
  }

  svgViewport.addEventListener("wheel", (e) => {
    if (!svgEl) return;
    e.preventDefault();
    const rect = svgViewport.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;

    const oldScale = baseScale * viewScale;
    const factor = e.deltaY > 0 ? 0.9 : 1.1;
    let newViewScale = viewScale * factor;
    newViewScale = Math.max(0.2, Math.min(6, newViewScale));
    const newScale = baseScale * newViewScale;
    const { width, height, offsetX, offsetY } = getContentMetrics();
    const txOld = (rect.width - width * oldScale) / 2 + panX - offsetX * oldScale;
    const tyOld = (rect.height - height * oldScale) / 2 + panY - offsetY * oldScale;

    const imgX = (mouseX - txOld) / oldScale;
    const imgY = (mouseY - tyOld) / oldScale;

    const txNew = mouseX - imgX * newScale;
    const tyNew = mouseY - imgY * newScale;

    panX = txNew - (rect.width - width * newScale) / 2 + offsetX * newScale;
    panY = tyNew - (rect.height - height * newScale) / 2 + offsetY * newScale;
    viewScale = newViewScale;
    updateSvgTransform();
  }, { passive: false });

  svgViewport.addEventListener("mousedown", (e) => {
    if (!svgEl) return;
    if (e.button !== 0) return;

    if (interactionMode === "move") {
      e.preventDefault();
      isPanning = true;
      panMoved = false;
      svgViewport.classList.add("grabbing");
      panStartX = panX;
      panStartY = panY;
      panStartClientX = e.clientX;
      panStartClientY = e.clientY;
    } else {
      labelMouseDown = true;
      labelIsBox = false;
      labelBoxMoved = false;
      labelStartClientX = e.clientX;
      labelStartClientY = e.clientY;
      labelCurrentClientX = e.clientX;
      labelCurrentClientY = e.clientY;
    }
  });

  window.addEventListener("mousemove", (e) => {
    if (isPanning) {
      const dx = e.clientX - panStartClientX;
      const dy = e.clientY - panStartClientY;
      if (Math.abs(dx) > 3 || Math.abs(dy) > 3) panMoved = true;
      panX = panStartX + dx;
      panY = panStartY + dy;
      updateSvgTransform();
    } else if (labelMouseDown) {
      const dx = e.clientX - labelStartClientX;
      const dy = e.clientY - labelStartClientY;
      labelCurrentClientX = e.clientX;
      labelCurrentClientY = e.clientY;
      if (!labelIsBox && (Math.abs(dx) > 3 || Math.abs(dy) > 3)) {
        labelIsBox = true;
        boxOverlay.style.display = "block";
      }
      if (labelIsBox) {
        const rect = svgViewport.getBoundingClientRect();
        const x1 = labelStartClientX - rect.left;
        const y1 = labelStartClientY - rect.top;
        const x2 = labelCurrentClientX - rect.left;
        const y2 = labelCurrentClientY - rect.top;
        const left = Math.min(x1, x2);
        const top  = Math.min(y1, y2);
        const width  = Math.abs(x1 - x2);
        const height = Math.abs(y1 - y2);
        boxOverlay.style.left = left + "px";
        boxOverlay.style.top  = top  + "px";
        boxOverlay.style.width  = width + "px";
        boxOverlay.style.height = height + "px";
        if (width > 3 || height > 3) labelBoxMoved = true;
      }
    }
  });

  window.addEventListener("mouseup", (e) => {
    if (e.button !== 0) return;
    if (isPanning) {
      isPanning = false;
      svgViewport.classList.remove("grabbing");
    }
    if (labelMouseDown) {
      if (labelIsBox && labelBoxMoved) {
        ignoreNextClick = true;
        performBoxSelection();
      }
      labelMouseDown = false;
      labelIsBox = false;
      labelBoxMoved = false;
      boxOverlay.style.display = "none";
    }
  });

  function performBoxSelection(){
    if (!svgEl || !roiElements.length) return;

    const minXClient = Math.min(labelStartClientX, labelCurrentClientX);
    const maxXClient = Math.max(labelStartClientX, labelCurrentClientX);
    const minYClient = Math.min(labelStartClientY, labelCurrentClientY);
    const maxYClient = Math.max(labelStartClientY, labelCurrentClientY);

    const affected = [];
    roiElements.forEach(el => {
      const b = el.getBoundingClientRect();
      const overlap = !(b.right < minXClient || b.left > maxXClient || b.bottom < minYClient || b.top > maxYClient);
      if (overlap) affected.push(el);
    });

    affected.forEach(el => {
      const roiId = el.id;
      if (activeLabelId) {
        roiAssignments[roiId] = activeLabelId;
      } else {
        delete roiAssignments[roiId];
      }
    });

    refreshAllRoisAppearance();
    updateGlobalStats();
    updateSelectionStatus(
      affected.length
        ? `Box selection affected ${affected.length} ROIs.`
        : "No ROI in box selection."
    );
  }

  window.addEventListener("resize", () => {
    if (!svgEl) return;
    computeBaseScale();
    centerOnRoiBBox();
  });

  // ----------- SVG 加载 & ROI 初始化 -----------
  async function loadSvgMap(){
    try {
      const resp = await fetch(SVG_FILENAME);
      if (!resp.ok) throw new Error("HTTP " + resp.status);
      const svgText = await resp.text();
      svgContainer.innerHTML = svgText;
      svgEl = svgContainer.querySelector("svg");
      if (!svgEl) {
        emptyState.textContent = "Failed to load SVG: no <svg> root found.";
        hoverInfo.textContent = "SVG load error";
        return;
      }
      emptyState.style.display = "none";

      const vbAttr = svgEl.getAttribute("viewBox");
      if (vbAttr) {
        const parts = vbAttr.split(/[\s,]+/).map(parseFloat);
        svgWidth  = parts[2];
        svgHeight = parts[3];
      } else {
        const bbox = svgEl.getBBox();
        svgWidth  = bbox.width;
        svgHeight = bbox.height;
      }
      svgEl.setAttribute("width", svgWidth);
      svgEl.setAttribute("height", svgHeight);

      mapInfo.textContent =
        `Map file: ${SVG_FILENAME} · viewBox: ${svgEl.getAttribute("viewBox") || "none"} · W×H: ${svgWidth.toFixed(1)} × ${svgHeight.toFixed(1)}`;

      viewScale = 1;
      panX = 0;
      panY = 0;

      setupRoisFromSvg(svgEl);

      // ensure measurements use the latest layout
      requestAnimationFrame(() => {
        computeBaseScale();
        centerOnRoiBBox();
      });

      hoverInfo.textContent = "SVG loaded. Label mode: click or drag box. Move mode: drag to pan.";
    } catch (err) {
      console.error(err);
      emptyState.textContent = "Failed to load SVG file.";
      hoverInfo.textContent = "SVG load error";
    }
  }

  function setupRoisFromSvg(svgEl){
    let paths = svgEl.querySelectorAll("g#layer-MC0 path, g[id^='layer'] path");
    if (!paths.length) {
      paths = svgEl.querySelectorAll("path");
    }

    roiElements = [];
    let autoIdCount = 1;
    paths.forEach(el => {
      const baseFill = "#c9d0d8"; // 更灰一点
      el.dataset.baseFill = baseFill;
      el.style.fill = baseFill;
      el.style.stroke = "#000000";
      el.style.strokeWidth = "1.6";
      el.style.strokeLinejoin = "round";
      el.style.strokeLinecap = "round";
      el.style.vectorEffect = "non-scaling-stroke";

      if (!el.id || el.id === "") {
        el.id = "roi_auto_" + autoIdCount++;
      }

      el.classList.add("roi-shape");

      el.addEventListener("pointerenter", () => {
        el.classList.add("roi-hover");
        el.dataset.baseStrokeWidth = el.style.strokeWidth || "1.6";
        const roiId = el.id;
        const labelId = roiAssignments[roiId];
        if (!labelId) {
          const base = el.dataset.baseFill || "#c9d0d8";
          el.style.fill = lightenHex(base, 0.4); // 无标签：底色提亮
        } else {
          const label = labels.find(l => l.id === labelId);
          const c = label ? label.color : "#ffffff";
          el.style.fill = lightenHex(c, 0.6); // 有标签：标签色 -> 更明显的淡色
        }
        el.style.strokeWidth = "2.8";

        const currentLabelId = roiAssignments[roiId];
        const labelName = currentLabelId
          ? (labels.find(l => l.id === currentLabelId)?.name || currentLabelId)
          : "Unlabeled";
        hoverInfo.textContent = `ROI: ${roiId} · Label: ${labelName}`;
      });

      el.addEventListener("pointerleave", () => {
        el.classList.remove("roi-hover");
        el.style.strokeWidth = el.dataset.baseStrokeWidth || "1.6";
        updateRoiAppearance(el); // 恢复为标签色或灰色
        hoverInfo.textContent = "Hover a cell to see ROI id and label.";
      });

      el.addEventListener("click", () => {
        if (ignoreNextClick) {
          ignoreNextClick = false;
          return;
        }
        if (interactionMode === "move") {
          return;
        }
        applyLabelLogicForRoi(el.id);
        updateRoiAppearance(el);
        updateGlobalStats();

        const now = roiAssignments[el.id] || null;
        if (now) {
          const ln = labels.find(l => l.id === now)?.name || now;
          updateSelectionStatus(`ROI ${el.id} set to label ${ln}.`);
        } else {
          updateSelectionStatus(`ROI ${el.id} cleared.`);
        }
      });

      roiElements.push(el);
    });

    recomputeRoiBBox();
    updateGlobalStats();
  }

  function applyLabelLogicForRoi(roiId){
    const current = roiAssignments[roiId] || null;
    if (activeLabelId) {
      if (current === activeLabelId) {
        delete roiAssignments[roiId];
      } else {
        roiAssignments[roiId] = activeLabelId;
      }
    } else {
      delete roiAssignments[roiId];
    }
  }

  function updateRoiAppearance(el){
    const roiId = el.id;
    const labelId = roiAssignments[roiId];
    if (!labelId) {
      el.style.fill = el.dataset.baseFill || "#c9d0d8";
      el.classList.remove("roi-labeled");
      return;
    }
    const label = labels.find(l => l.id === labelId);
    if (!label) {
      delete roiAssignments[roiId];
      el.style.fill = el.dataset.baseFill || "#c9d0d8";
      el.classList.remove("roi-labeled");
      return;
    }
    el.style.fill = label.color;
    el.classList.add("roi-labeled");
  }

  function refreshAllRoisAppearance(){
    roiElements.forEach(updateRoiAppearance);
  }

  // ----------- 标签管理 -----------
  function refreshLabelList(){
    labelListEl.innerHTML = "";
    if (!labels.length) {
      labelEmptyHint.style.display = "block";
    } else {
      labelEmptyHint.style.display = "none";
    }

    const counts = {};
    Object.values(roiAssignments).forEach(id => {
      if (!id) return;
      counts[id] = (counts[id] || 0) + 1;
    });

    labels.forEach(label => {
      const item = document.createElement("div");
      item.className = "label-item" + (label.id === activeLabelId ? " active" : "");
      const dot = document.createElement("div");
      dot.className = "label-color-dot";
      dot.style.backgroundColor = label.color;

      const main = document.createElement("div");
      main.className = "label-main";
      const nDiv = document.createElement("div");
      nDiv.textContent = label.name || "(Untitled)";
      const mDiv = document.createElement("div");
      mDiv.textContent = `ID: ${label.id} · ROIs: ${counts[label.id] || 0}`;
      main.appendChild(nDiv);
      main.appendChild(mDiv);

      const right = document.createElement("div");
      right.style.display = "flex";
      right.style.alignItems = "center";
      right.style.gap = "0.25rem";

      const badge = document.createElement("div");
      badge.className = "badge";
      badge.textContent = "Active";
      if (label.id !== activeLabelId) badge.style.visibility = "hidden";

      const delBtn = document.createElement("button");
      delBtn.className = "button small icon";
      delBtn.textContent = "×";
      delBtn.title = "Delete this label";
      delBtn.addEventListener("click", (ev) => {
        ev.stopPropagation();
        deleteLabel(label.id);
      });

      right.appendChild(badge);
      right.appendChild(delBtn);

      item.appendChild(dot);
      item.appendChild(main);
      item.appendChild(right);

      item.addEventListener("click", () => {
        activeLabelId = (activeLabelId === label.id ? null : label.id);
        refreshLabelList();
      });

      labelListEl.appendChild(item);
    });
  }

  function deleteLabel(id){
    labels = labels.filter(l => l.id !== id);
    if (activeLabelId === id) activeLabelId = null;
    for (const [roiId, labId] of Object.entries(roiAssignments)) {
      if (labId === id) delete roiAssignments[roiId];
    }
    refreshLabelList();
    refreshAllRoisAppearance();
    updateGlobalStats();
  }

  // ----------- 导入 / 导出 -----------
  function exportLabels(){
    if (!roiElements.length) {
      alert("SVG map is not loaded yet.");
      return;
    }
    const obj = {
      version: 4,
      mapFile: SVG_FILENAME,
      labels,
      assignments: roiAssignments,
      timestamp: new Date().toISOString()
    };
    const blob = new Blob([JSON.stringify(obj, null, 2)], {type: "application/json"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "root_svg_labels.json";
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }

  function importLabelsFromObject(obj){
    if (!obj || !obj.labels || !obj.assignments) {
      alert("Invalid JSON: no labels / assignments.");
      return;
    }
    if (obj.mapFile && obj.mapFile !== SVG_FILENAME) {
      const proceed = confirm(
        `JSON was exported for "${obj.mapFile}", but current map is "${SVG_FILENAME}".\n` +
        `Continue to apply labels?`
      );
      if (!proceed) return;
    }
    labels = obj.labels;
    roiAssignments = obj.assignments;
    activeLabelId = labels.length ? labels[0].id : null;
    refreshLabelList();
    refreshAllRoisAppearance();
    updateGlobalStats();
  }

  exportJsonBtn.addEventListener("click", exportLabels);

  labelsFileInput.addEventListener("change", (e) => {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (ev) => {
      try {
        const obj = JSON.parse(ev.target.result);
        importLabelsFromObject(obj);
      } catch (err) {
        console.error(err);
        alert("Failed to parse JSON.");
      }
    };
    reader.readAsText(file);
  });

  clearAssignmentsBtn.addEventListener("click", () => {
    roiAssignments = {};
    refreshAllRoisAppearance();
    updateGlobalStats();
  });

  addLabelBtn.addEventListener("click", () => {
    const name = labelNameInput.value.trim();
    const color = labelColorInput.value || getNextColor();
    const id = "L" + (labels.length + 1);
    labels.push({
      id,
      name: name || `Label ${labels.length + 1}`,
      color
    });
    activeLabelId = id;
    labelNameInput.value = "";
    labelColorInput.value = getNextColor();
    refreshLabelList();
    updateGlobalStats();
  });

  clearAllLabelsBtn.addEventListener("click", () => {
    const ok = confirm("Delete all labels and clear assignments?");
    if (!ok) return;
    labels = [];
    roiAssignments = {};
    activeLabelId = null;
    refreshLabelList();
    refreshAllRoisAppearance();
    updateGlobalStats();
  });

  // ----------- 初始化 -----------
  (function init(){
    labelColorInput.value = getNextColor();
    refreshLabelList();
    updateGlobalStats();
    setInteractionMode("move");
    hoverInfo.textContent = "Loading SVG map…";
    loadSvgMap();
  })();
</script>
</body>
</html>
