<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <title>Root ROI Map 自动分割 & 标注工具</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    :root {
      --bg: #020617;
      --panel: #0f172a;
      --panel2: #111827;
      --border: #1f2937;
      --accent: #3b82f6;
      --accent-soft: rgba(59, 130, 246, 0.16);
      --text: #e5e7eb;
      --muted: #9ca3af;
      --danger: #f97373;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
        sans-serif;
      background: radial-gradient(circle at top, #111827 0, #020617 55%);
      color: var(--text);
      height: 100vh;
      display: flex;
      flex-direction: column;
    }

    header {
      padding: 0.6rem 1rem;
      border-bottom: 1px solid var(--border);
      background: rgba(15, 23, 42, 0.95);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    header h1 {
      margin: 0;
      font-size: 1rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: #93c5fd;
    }

    header span {
      font-size: 0.8rem;
      color: var(--muted);
    }

    .pill {
      font-size: 0.75rem;
      padding: 0.2rem 0.6rem;
      border-radius: 999px;
      border: 1px solid var(--border);
      color: var(--muted);
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
      background: rgba(15, 23, 42, 0.85);
    }

    main {
      flex: 1;
      display: grid;
      grid-template-columns: 260px minmax(0, 1.2fr) 260px;
      gap: 0.6rem;
      padding: 0.6rem;
      min-height: 0;
    }

    @media (max-width: 1024px) {
      main {
        grid-template-columns: minmax(0, 1fr);
        grid-template-rows: auto auto auto;
      }
    }

    .panel {
      background: var(--panel);
      border-radius: 0.75rem;
      border: 1px solid var(--border);
      padding: 0.7rem;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }

    .panel-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.5rem;
    }

    .panel-title {
      font-size: 0.85rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--muted);
    }

    .panel-subtitle {
      font-size: 0.75rem;
      color: var(--muted);
    }

    .panel-body {
      flex: 1;
      overflow: auto;
      padding-right: 0.3rem;
    }

    .section {
      margin-bottom: 0.8rem;
      padding-bottom: 0.6rem;
      border-bottom: 1px dashed #1f2937;
    }
    .section:last-child {
      border-bottom: none;
      margin-bottom: 0;
      padding-bottom: 0;
    }

    .section-title {
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: var(--muted);
      margin-bottom: 0.3rem;
    }

    label {
      display: block;
      font-size: 0.8rem;
      color: var(--muted);
      margin-bottom: 0.2rem;
    }

    input[type="file"],
    input[type="text"] {
      width: 100%;
      font-size: 0.8rem;
      padding: 0.3rem 0.4rem;
      border-radius: 0.45rem;
      border: 1px solid var(--border);
      background: var(--panel2);
      color: var(--text);
      outline: none;
    }

    input[type="file"] {
      padding: 0.2rem 0.3rem;
    }

    input[type="text"]:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 1px var(--accent-soft);
    }

    input[type="color"] {
      width: 100%;
      height: 1.8rem;
      border-radius: 0.4rem;
      border: 1px solid var(--border);
      background: transparent;
      padding: 0;
      cursor: pointer;
    }

    .button {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 0.8rem;
      padding: 0.28rem 0.6rem;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: #020617;
      color: var(--text);
      cursor: pointer;
      gap: 0.3rem;
      transition: all 0.12s ease;
    }

    .button.primary {
      background: linear-gradient(135deg, #2563eb, #4f46e5);
      border-color: transparent;
      color: white;
    }

    .button.small {
      font-size: 0.75rem;
      padding: 0.18rem 0.5rem;
    }

    .button.danger {
      border-color: rgba(248, 113, 113, 0.8);
      color: #fecaca;
    }

    .button:hover {
      border-color: var(--accent);
      background: #020617;
    }

    .button.primary:hover {
      box-shadow: 0 10px 25px rgba(37, 99, 235, 0.6);
      transform: translateY(-1px);
    }

    .button.danger:hover {
      background: rgba(185, 28, 28, 0.45);
    }

    .row {
      display: flex;
      gap: 0.4rem;
      margin-bottom: 0.4rem;
    }

    .row > * {
      flex: 1;
    }

    .hint {
      font-size: 0.72rem;
      color: var(--muted);
      line-height: 1.4;
      margin-top: 0.25rem;
    }

    #canvasContainer {
      flex: 1;
      min-height: 0;
      border-radius: 0.7rem;
      border: 1px solid var(--border);
      background: radial-gradient(circle at center, #020617 0, #020617 60%);
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }

    #maskCanvas {
      image-rendering: pixelated;
      border-radius: 0.6rem;
      box-shadow: 0 14px 35px rgba(0, 0, 0, 0.75);
      position: absolute;
      top: 0;
      left: 0;
    }

    #overlayCanvas {
      position: absolute;
      top: 0;
      left: 0;
      pointer-events: none;
    }

    .empty-state {
      text-align: center;
      color: var(--muted);
      font-size: 0.8rem;
      padding: 1.2rem;
    }

    .status-line {
      font-size: 0.72rem;
      color: var(--muted);
      margin-top: 0.3rem;
    }

    #labelList {
      display: flex;
      flex-direction: column;
      gap: 0.3rem;
      margin-top: 0.3rem;
    }

    .label-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0.25rem 0.4rem;
      background: rgba(15, 23, 42, 0.95);
      border-radius: 0.5rem;
      border: 1px solid transparent;
      cursor: pointer;
      gap: 0.4rem;
      transition: all 0.12s ease;
    }

    .label-item:hover {
      border-color: var(--border);
    }

    .label-item.active {
      border-color: var(--accent);
      box-shadow: 0 0 0 1px var(--accent-soft);
      background: radial-gradient(circle at top, var(--accent-soft), #020617);
    }

    .label-color-dot {
      width: 14px;
      height: 14px;
      border-radius: 999px;
      border: 1px solid #020617;
      flex-shrink: 0;
    }

    .label-main {
      flex: 1;
      min-width: 0;
    }

    .label-main div:first-child {
      font-size: 0.8rem;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .label-main div:last-child {
      font-size: 0.7rem;
      color: var(--muted);
    }

    .badge {
      font-size: 0.7rem;
      padding: 0.05rem 0.35rem;
      border-radius: 999px;
      border: 1px solid #475569;
      color: var(--muted);
    }

    footer {
      padding: 0.3rem 0.8rem;
      font-size: 0.72rem;
      color: var(--muted);
      border-top: 1px solid var(--border);
      background: rgba(15, 23, 42, 0.96);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
  </style>
</head>
<body>
  <header>
    <div>
      <h1>Root ROI Map Annotator</h1>
      <span>黑线轮廓 PNG/SVG → 自动分割 ROI → 点击/框选标注 → 导出 JSON / PNG</span>
    </div>
    <div class="pill">
      <span>左键：点击/框选</span>
      <span>右键拖动：平移</span>
      <span>滚轮：缩放</span>
    </div>
  </header>

  <main>
    <!-- 左侧：输入与导入/导出 -->
    <aside class="panel">
      <div class="panel-header">
        <div class="panel-title">输入 & 文件</div>
      </div>
      <div class="panel-body">
        <div class="section">
          <div class="section-title">1. 导入根模板图像</div>
          <label for="maskFileInput">PNG / JPEG / SVG（黑色轮廓 + 白色背景）</label>
          <input type="file" id="maskFileInput" accept=".png,.jpg,.jpeg,.svg,image/png,image/jpeg,image/svg+xml" />
          <div class="hint">
            建议从 PDF 导出为纯黑线 + 白底的 SVG 或高分辨率 PNG。脚本会把黑线当作边界，对白色区域做连通域分割，最大的白色连通域视为外部背景。
          </div>
          <div id="maskInfo" class="status-line"></div>
        </div>

        <div class="section">
          <div class="section-title">2. 导入/导出标注</div>
          <div class="row">
            <button class="button small primary" id="exportJsonBtn">导出标注 JSON</button>
            <button class="button small" id="exportPngBtn">导出着色 PNG</button>
          </div>
          <label for="annotationFileInput">导入标注 JSON</label>
          <input type="file" id="annotationFileInput" accept="application/json,.json" />
          <div class="hint">
            JSON 中保存：标签列表（名称+颜色）、每个 ROI 的标签 ID 以及图像尺寸。再次加载相同模板时可恢复标注。
          </div>
        </div>

        <div class="section">
          <div class="section-title">3. 交互模式</div>
          <div class="row">
            <button class="button small primary" id="modeClickBtn">单击 ROI</button>
            <button class="button small" id="modeBoxBtn">框选 ROI</button>
          </div>
          <div id="modeStatus" class="status-line"></div>
        </div>
      </div>
    </aside>

    <!-- 中间：画布 -->
    <section class="panel">
      <div class="panel-header">
        <div>
          <div class="panel-title">ROI Map 视图</div>
          <div class="panel-subtitle">自动分割后的 ROI 在这里显示，可点击/框选标注</div>
        </div>
        <div id="hoverInfo" class="pill">未加载图像</div>
      </div>
      <div id="canvasContainer">
        <canvas id="maskCanvas"></canvas>
        <canvas id="overlayCanvas"></canvas>
        <div id="emptyState" class="empty-state">
          请先在左侧上传一张根模板图片（PNG/JPEG/SVG，黑线轮廓 + 白底）。<br /><br />
          加载后工具会：<br />
          · 自动识别每个封闭白色区域作为 ROI<br />
          · 最大的外部区域视为背景忽略<br />
          然后你可以创建标签，并对 ROI 进行标注。
        </div>
      </div>
    </section>

    <!-- 右侧：标签管理 -->
    <aside class="panel">
      <div class="panel-header">
        <div class="panel-title">标签 & 统计</div>
        <button class="button small danger" id="clearAllBtn">清空标签</button>
      </div>
      <div class="panel-body">
        <div class="section">
          <div class="section-title">1. 新建标签</div>
          <label for="labelNameInput">标签名称</label>
          <input type="text" id="labelNameInput" placeholder="例：Meristem / Cortex / QC 等" />
          <label for="labelColorInput">标签颜色</label>
          <input type="color" id="labelColorInput" value="#ff5c7a" />
          <button class="button primary" id="addLabelBtn" style="margin-top:0.4rem;width:100%;">添加标签</button>
          <div class="hint">
            新建标签后，在标签列表中点击选择为“当前标签”，然后在中间画布点击/框选 ROI 即可赋予该标签。
          </div>
        </div>

        <div class="section">
          <div class="section-title">2. 标签列表</div>
          <div id="labelList"></div>
          <div id="labelEmptyHint" class="hint">
            还没有标签，请先创建一个标签。
          </div>
        </div>

        <div class="section">
          <div class="section-title">3. 全局统计</div>
          <div id="globalStats" class="hint">尚未加载图像。</div>
        </div>
      </div>
    </aside>
  </main>

  <footer>
    <div>提示：外部最大的白色连通区域会被视作背景并忽略。</div>
    <div id="selectionStatus">未选择 ROI</div>
  </footer>

  <script>
    // ===== 全局状态 =====
    const maskCanvas = document.getElementById("maskCanvas");
    const overlayCanvas = document.getElementById("overlayCanvas");
    const ctx = maskCanvas.getContext("2d");
    const overlayCtx = overlayCanvas.getContext("2d");
    const canvasContainer = document.getElementById("canvasContainer");
    const emptyState = document.getElementById("emptyState");

    const maskFileInput = document.getElementById("maskFileInput");
    const annotationFileInput = document.getElementById("annotationFileInput");
    const maskInfo = document.getElementById("maskInfo");
    const hoverInfo = document.getElementById("hoverInfo");
    const globalStats = document.getElementById("globalStats");
    const selectionStatus = document.getElementById("selectionStatus");
    const modeStatus = document.getElementById("modeStatus");

    const modeClickBtn = document.getElementById("modeClickBtn");
    const modeBoxBtn = document.getElementById("modeBoxBtn");

    const addLabelBtn = document.getElementById("addLabelBtn");
    const labelNameInput = document.getElementById("labelNameInput");
    const labelColorInput = document.getElementById("labelColorInput");
    const labelListEl = document.getElementById("labelList");
    const labelEmptyHint = document.getElementById("labelEmptyHint");
    const clearAllBtn = document.getElementById("clearAllBtn");

    const exportJsonBtn = document.getElementById("exportJsonBtn");
    const exportPngBtn = document.getElementById("exportPngBtn");

    let imgWidth = 0;
    let imgHeight = 0;
    let maskLoaded = false;

    // 每个像素的 ROI ID（0=背景，1..N）
    let roiLabelData = null;
    let roiCount = 0;

    // 标签
    let labels = [];       // {id, name, color}
    let activeLabelId = null;
    let roiAssignments = {}; // { roiId: labelId }

    // 交互模式
    let interactionMode = "click"; // "click" | "box"
    let isDragging = false;
    let dragStart = null;
    let dragCurrent = null;

    // 视图缩放和平移
    let baseScale = 1;   // 自动按容器居中时的基础 scale
    let viewScale = 1;   // 用户滚轮调节的缩放倍数
    const minScale = 0.3;
    const maxScale = 5;
    let panX = 0;        // 额外平移（px）
    let panY = 0;
    let isPanning = false;
    let panStartClientX = 0;
    let panStartClientY = 0;
    let panStartX = 0;
    let panStartY = 0;

    // ===== 工具函数 =====
    function hexToRgb(hex) {
      hex = hex.replace("#", "");
      if (hex.length === 3) {
        hex = hex.split("").map(c => c + c).join("");
      }
      const num = parseInt(hex, 16);
      return {
        r: (num >> 16) & 255,
        g: (num >> 8) & 255,
        b: num & 255,
      };
    }

    function setMaskInfo(text) {
      maskInfo.textContent = text || "";
    }

    function setInteractionMode(mode) {
      interactionMode = mode;
      modeStatus.innerHTML =
        mode === "click"
          ? "当前模式：<strong>单击 ROI</strong>（点击一个封闭区域，赋予当前标签；右键拖动可平移）"
          : "当前模式：<strong>框选 ROI</strong>（拖出矩形，为其中所有 ROI 赋予当前标签；右键拖动可平移）";

      modeClickBtn.classList.toggle("primary", mode === "click");
      modeBoxBtn.classList.toggle("primary", mode === "box");
    }

    function updateGlobalStats() {
      if (!maskLoaded || !roiLabelData) {
        globalStats.textContent = "尚未加载图像。";
        return;
      }
      const used = new Set();
      for (let i = 0; i < roiLabelData.length; i++) {
        if (roiLabelData[i] > 0) used.add(roiLabelData[i]);
      }
      const total = used.size;
      const labeledSet = new Set(
        Object.keys(roiAssignments)
          .filter(k => roiAssignments[k])
          .map(k => parseInt(k, 10))
      );
      const labeled = labeledSet.size;
      globalStats.innerHTML = `ROI 总数：<strong>${total}</strong><br/>已标注 ROI：<strong>${labeled}</strong>（${
        total ? (labeled / total * 100).toFixed(1) : 0
      }%）`;
    }

    function updateSelectionStatus(text) {
      selectionStatus.textContent = text || "未选择 ROI";
    }

    function resizeCanvases(width, height) {
      maskCanvas.width = width;
      maskCanvas.height = height;
      overlayCanvas.width = width;
      overlayCanvas.height = height;

      // Canvas 的 CSS 尺寸先设为图像原始尺寸，缩放交给 transform
      maskCanvas.style.width = width + "px";
      maskCanvas.style.height = height + "px";
      overlayCanvas.style.width = width + "px";
      overlayCanvas.style.height = height + "px";

      computeBaseScale();
      viewScale = 1;
      panX = 0;
      panY = 0;
      updateViewTransform();
    }

    function computeBaseScale() {
      const rect = canvasContainer.getBoundingClientRect();
      if (!imgWidth || !imgHeight || !rect.width || !rect.height) return;
      baseScale = Math.min(rect.width / imgWidth, rect.height / imgHeight);
    }

    function updateViewTransform() {
      if (!imgWidth || !imgHeight) return;
      if (!baseScale) computeBaseScale();

      const rect = canvasContainer.getBoundingClientRect();
      const scale = baseScale * viewScale;

      const tx = (rect.width - imgWidth * scale) / 2 + panX;
      const ty = (rect.height - imgHeight * scale) / 2 + panY;

      const transform = `translate(${tx}px, ${ty}px) scale(${scale})`;

      maskCanvas.style.transformOrigin = "top left";
      overlayCanvas.style.transformOrigin = "top left";
      maskCanvas.style.transform = transform;
      overlayCanvas.style.transform = transform;
    }

    function refreshLabelList() {
      labelListEl.innerHTML = "";
      if (!labels.length) {
        labelEmptyHint.style.display = "block";
        return;
      }
      labelEmptyHint.style.display = "none";

      const counts = {};
      for (const [roiId, labelId] of Object.entries(roiAssignments)) {
        if (!labelId) continue;
        counts[labelId] = (counts[labelId] || 0) + 1;
      }

      labels.forEach(label => {
        const item = document.createElement("div");
        item.className = "label-item" + (label.id === activeLabelId ? " active" : "");
        item.dataset.labelId = label.id;

        const colorDot = document.createElement("div");
        colorDot.className = "label-color-dot";
        colorDot.style.backgroundColor = label.color;

        const main = document.createElement("div");
        main.className = "label-main";
        const nameDiv = document.createElement("div");
        nameDiv.textContent = label.name || "(未命名)";
        const metaDiv = document.createElement("div");
        metaDiv.textContent = `ID: ${label.id} · ROI: ${counts[label.id] || 0}`;

        main.appendChild(nameDiv);
        main.appendChild(metaDiv);

        const badge = document.createElement("div");
        badge.className = "badge";
        badge.textContent = "当前";
        if (label.id !== activeLabelId) badge.style.visibility = "hidden";

        item.appendChild(colorDot);
        item.appendChild(main);
        item.appendChild(badge);

        item.addEventListener("click", () => {
          activeLabelId = label.id;
          refreshLabelList();
        });

        labelListEl.appendChild(item);
      });
    }

    function addLabel(name, color) {
      const id = "L" + (labels.length + 1);
      labels.push({ id, name: name || `Label ${labels.length + 1}`, color });
      activeLabelId = id;
      refreshLabelList();
    }

    // ===== 自动分割：黑线为边界，白区为 ROI =====
    function segmentImageToRois() {
      const imageData = ctx.getImageData(0, 0, imgWidth, imgHeight);
      const data = imageData.data;
      const pixels = imgWidth * imgHeight;

      const labelsArr = new Int32Array(pixels);
      const isBoundary = new Uint8Array(pixels);

      // 判断边界像素（黑线 / 深色）
      for (let i = 0; i < pixels; i++) {
        const r = data[i * 4];
        const g = data[i * 4 + 1];
        const b = data[i * 4 + 2];
        const a = data[i * 4 + 3];

        const brightness = (r + g + b) / 3;
        // 亮度 < 某阈值视为线条；阈值可根据图像适当调整
        if (a > 0 && brightness < 220) {
          isBoundary[i] = 1;
        }
      }

      let currentLabel = 0;
      const stack = [];

      function pushIfValid(idx) {
        if (idx < 0 || idx >= pixels) return;
        if (isBoundary[idx]) return;
        if (labelsArr[idx] !== 0) return;
        labelsArr[idx] = currentLabel;
        stack.push(idx);
      }

      // 4-邻域连通域标记
      for (let i = 0; i < pixels; i++) {
        if (isBoundary[i]) continue;
        if (labelsArr[i] !== 0) continue;
        currentLabel++;
        labelsArr[i] = currentLabel;
        stack.length = 0;
        stack.push(i);

        while (stack.length > 0) {
          const idx = stack.pop();
          const x = idx % imgWidth;
          const y = (idx / imgWidth) | 0;
          if (x > 0) pushIfValid(idx - 1);
          if (x < imgWidth - 1) pushIfValid(idx + 1);
          if (y > 0) pushIfValid(idx - imgWidth);
          if (y < imgHeight - 1) pushIfValid(idx + imgWidth);
        }
      }

      // 统计面积，找最大连通区域（外部背景）
      const areas = new Array(currentLabel + 1).fill(0);
      for (let i = 0; i < pixels; i++) {
        const l = labelsArr[i];
        if (l > 0) areas[l]++;
      }

      let largestLabel = 0;
      let largestArea = 0;
      for (let l = 1; l <= currentLabel; l++) {
        if (areas[l] > largestArea) {
          largestArea = areas[l];
          largestLabel = l;
        }
      }

      // 重新映射 label：外部背景 -> 0，其余 -> 1..N
      const labelMap = new Int32Array(currentLabel + 1);
      let newId = 1;
      for (let l = 1; l <= currentLabel; l++) {
        if (l === largestLabel) {
          labelMap[l] = 0;
        } else {
          labelMap[l] = newId++;
        }
      }

      roiLabelData = new Uint16Array(pixels);
      for (let i = 0; i < pixels; i++) {
        const old = labelsArr[i];
        roiLabelData[i] = labelMap[old];
      }
      roiCount = newId - 1;

      setMaskInfo(`自动分割完成：检测到 ${roiCount} 个非背景 ROI（排除外部背景）`);
      updateGlobalStats();
    }

    // ===== 根据 ROI + 标签渲染画布 =====
    function renderMaskWithLabels() {
      if (!maskLoaded || !roiLabelData) return;

      const imageData = ctx.createImageData(imgWidth, imgHeight);
      const data = imageData.data;
      const total = roiLabelData.length;

      const bgR = 18, bgG = 24, bgB = 38;

      for (let i = 0; i < total; i++) {
        const roiId = roiLabelData[i];
        let r, g, b, a;
        if (roiId === 0) {
          r = bgR; g = bgG; b = bgB; a = 255;
        } else {
          const labelId = roiAssignments[roiId];
          if (labelId) {
            const label = labels.find(l => l.id === labelId);
            if (label) {
              const { r: lr, g: lg, b: lb } = hexToRgb(label.color);
              r = lr; g = lg; b = lb; a = 255;
            } else {
              r = 150; g = 150; b = 150; a = 255;
            }
          } else {
            r = 120; g = 120; b = 120; a = 255;
          }
        }
        data[i * 4] = r;
        data[i * 4 + 1] = g;
        data[i * 4 + 2] = b;
        data[i * 4 + 3] = a;
      }

      ctx.putImageData(imageData, 0, 0);

      // overlay 清空 & 重画框选矩形
      overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
      if (isDragging && dragStart && dragCurrent) {
        overlayCtx.save();
        overlayCtx.setLineDash([4, 3]);
        overlayCtx.lineWidth = 1.5;
        overlayCtx.strokeStyle = "rgba(96,165,250,0.9)";
        overlayCtx.fillStyle = "rgba(37,99,235,0.18)";

        const x = Math.min(dragStart.x, dragCurrent.x);
        const y = Math.min(dragStart.y, dragCurrent.y);
        const w = Math.abs(dragCurrent.x - dragStart.x);
        const h = Math.abs(dragCurrent.y - dragStart.y);

        overlayCtx.fillRect(x, y, w, h);
        overlayCtx.strokeRect(x, y, w, h);
        overlayCtx.restore();
      }

      updateGlobalStats();
      refreshLabelList();
    }

    // 将鼠标坐标映射到图像像素
    function canvasPixelFromEvent(evt) {
      const rect = maskCanvas.getBoundingClientRect();
      const scaleX = maskCanvas.width / rect.width;
      const scaleY = maskCanvas.height / rect.height;
      const x = Math.floor((evt.clientX - rect.left) * scaleX);
      const y = Math.floor((evt.clientY - rect.top) * scaleY);
      if (x < 0 || y < 0 || x >= maskCanvas.width || y >= maskCanvas.height) return null;
      return { x, y };
    }

    function getRoiIdAt(x, y) {
      if (!roiLabelData) return 0;
      const idx = y * imgWidth + x;
      if (idx < 0 || idx >= roiLabelData.length) return 0;
      return roiLabelData[idx];
    }

    function assignLabelToRoi(roiId, labelId) {
      if (roiId <= 0 || !labelId) return;
      roiAssignments[roiId] = labelId;
    }

    function getRoiIdsInRect(x1, y1, x2, y2) {
      const minX = Math.max(0, Math.min(x1, x2));
      const maxX = Math.min(imgWidth - 1, Math.max(x1, x2));
      const minY = Math.max(0, Math.min(y1, y2));
      const maxY = Math.min(imgHeight - 1, Math.max(y1, y2));
      const set = new Set();
      for (let y = minY; y <= maxY; y++) {
        let rowOffset = y * imgWidth;
        for (let x = minX; x <= maxX; x++) {
          const roiId = roiLabelData[rowOffset + x];
          if (roiId > 0) set.add(roiId);
        }
      }
      return Array.from(set);
    }

    // ===== 事件绑定 =====

    // 上传模板图像（PNG/JPEG/SVG）
    maskFileInput.addEventListener("change", e => {
      const file = e.target.files[0];
      if (!file) return;

      const img = new Image();
      img.onload = () => {
        imgWidth = img.width;
        imgHeight = img.height;
        resizeCanvases(imgWidth, imgHeight);

        ctx.clearRect(0, 0, imgWidth, imgHeight);
        ctx.drawImage(img, 0, 0);

        emptyState.style.display = "none";
        maskLoaded = true;

        // 自动分割 & 渲染
        segmentImageToRois();
        renderMaskWithLabels();
        hoverInfo.textContent = `尺寸：${imgWidth}×${imgHeight} · ROI 数约 ${roiCount}`;
        setMaskInfo(`已加载：${file.name} · ROI 数约 ${roiCount}`);
        roiAssignments = {};
        updateSelectionStatus("未选择 ROI");
      };

      img.onerror = () => {
        alert("无法加载该图片，请确认是黑线+白底的 PNG/JPEG/SVG。");
      };

      const url = URL.createObjectURL(file);
      img.src = url;
    });

    // 导入标注 JSON
    annotationFileInput.addEventListener("change", e => {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = evt => {
        try {
          const json = JSON.parse(evt.target.result);
          if (!json.labels || !json.roiAssignments) {
            alert("JSON 格式不正确（缺少 labels 或 roiAssignments）。");
            return;
          }
          labels = json.labels;
          roiAssignments = json.roiAssignments;
          activeLabelId = labels.length ? labels[0].id : null;
          refreshLabelList();
          updateGlobalStats();
          renderMaskWithLabels();
          alert("标注 JSON 导入成功。请确保你加载的是相同的根模板图像。");
        } catch (err) {
          console.error(err);
          alert("解析 JSON 出错，请检查文件是否为本工具导出的标注。");
        }
      };
      reader.readAsText(file);
    });

    // 新建标签
    addLabelBtn.addEventListener("click", () => {
      const name = labelNameInput.value.trim();
      const color = labelColorInput.value || "#ff5c7a";
      addLabel(name, color);
      labelNameInput.value = "";
    });

    // 清空标签 & 标注
    clearAllBtn.addEventListener("click", () => {
      if (!maskLoaded) {
        labels = [];
        roiAssignments = {};
        activeLabelId = null;
        refreshLabelList();
        updateGlobalStats();
        renderMaskWithLabels();
        return;
      }
      if (confirm("确定要清空所有标签和 ROI 标注吗？")) {
        labels = [];
        roiAssignments = {};
        activeLabelId = null;
        refreshLabelList();
        updateGlobalStats();
        renderMaskWithLabels();
      }
    });

    // 模式切换
    modeClickBtn.addEventListener("click", () => setInteractionMode("click"));
    modeBoxBtn.addEventListener("click", () => setInteractionMode("box"));

    // 防止右键菜单
    canvasContainer.addEventListener("contextmenu", e => e.preventDefault());

    // 滚轮缩放（以中心为基准）
    canvasContainer.addEventListener("wheel", e => {
      if (!maskLoaded) return;
      e.preventDefault();
      const delta = e.deltaY;
      const factor = delta > 0 ? 0.9 : 1.1;
      viewScale *= factor;
      if (viewScale < minScale) viewScale = minScale;
      if (viewScale > maxScale) viewScale = maxScale;
      updateViewTransform();
    }, { passive: false });

    // 右键拖动：平移
    canvasContainer.addEventListener("mousedown", e => {
      if (!maskLoaded) return;
      if (e.button === 2) { // 右键
        isPanning = true;
        panStartClientX = e.clientX;
        panStartClientY = e.clientY;
        panStartX = panX;
        panStartY = panY;
      }
    });

    window.addEventListener("mousemove", e => {
      if (isPanning) {
        const dx = e.clientX - panStartClientX;
        const dy = e.clientY - panStartClientY;
        panX = panStartX + dx;
        panY = panStartY + dy;
        updateViewTransform();
      }
    });

    window.addEventListener("mouseup", e => {
      if (e.button === 2 && isPanning) {
        isPanning = false;
      }
    });

    // 左键在画布上的交互（点击/框选）
    maskCanvas.addEventListener("mousemove", e => {
      if (!maskLoaded || !roiLabelData) return;
      const p = canvasPixelFromEvent(e);
      if (!p) return;
      const roiId = getRoiIdAt(p.x, p.y);
      if (roiId === 0) {
        hoverInfo.textContent = `位置：(${p.x}, ${p.y}) · 背景`;
      } else {
        const labelId = roiAssignments[roiId];
        const labelName = labelId
          ? (labels.find(l => l.id === labelId)?.name || labelId)
          : "未标注";
        hoverInfo.textContent = `位置：(${p.x}, ${p.y}) · ROI ID: ${roiId} · 标签：${labelName}`;
      }

      if (isDragging && dragStart) {
        dragCurrent = p;
        renderMaskWithLabels();
      }
    });

    maskCanvas.addEventListener("mouseleave", () => {
      if (!maskLoaded) return;
      hoverInfo.textContent = "鼠标已离开 ROI 视图";
      if (isDragging) {
        isDragging = false;
        dragStart = null;
        dragCurrent = null;
        renderMaskWithLabels();
      }
    });

    maskCanvas.addEventListener("mousedown", e => {
      if (e.button !== 0) return; // 只处理左键，右键用于平移
      if (!maskLoaded || !roiLabelData) return;
      const p = canvasPixelFromEvent(e);
      if (!p) return;

      if (interactionMode === "click") {
        if (!activeLabelId) {
          alert("请先在右侧创建并选择一个标签。");
          return;
        }
        const roiId = getRoiIdAt(p.x, p.y);
        if (roiId === 0) {
          updateSelectionStatus("点击在背景区域，没有 ROI。");
          return;
        }
        assignLabelToRoi(roiId, activeLabelId);
        renderMaskWithLabels();
        updateSelectionStatus(`ROI ${roiId} 已赋予标签 ${activeLabelId}`);
      } else if (interactionMode === "box") {
        isDragging = true;
        dragStart = p;
        dragCurrent = p;
      }
    });

    maskCanvas.addEventListener("mouseup", e => {
      if (e.button !== 0) return;
      if (!maskLoaded || !roiLabelData) return;
      if (interactionMode !== "box") return;
      if (!isDragging || !dragStart) return;

      const p = canvasPixelFromEvent(e);
      if (!p) {
        isDragging = false;
        dragStart = null;
        dragCurrent = null;
        renderMaskWithLabels();
        return;
      }
      dragCurrent = p;

      if (!activeLabelId) {
        alert("请先在右侧创建并选择一个标签。");
        isDragging = false;
        dragStart = null;
        dragCurrent = null;
        renderMaskWithLabels();
        return;
      }

      const roiIds = getRoiIdsInRect(
        dragStart.x, dragStart.y, dragCurrent.x, dragCurrent.y
      );
      roiIds.forEach(id => assignLabelToRoi(id, activeLabelId));

      isDragging = false;
      dragStart = null;
      dragCurrent = null;
      renderMaskWithLabels();

      if (roiIds.length) {
        updateSelectionStatus(
          `框选区域中 ${roiIds.length} 个 ROI 已赋予标签 ${activeLabelId}`
        );
      } else {
        updateSelectionStatus("框选区域内没有 ROI。");
      }
    });

    // 导出 JSON
    exportJsonBtn.addEventListener("click", () => {
      if (!maskLoaded || !roiLabelData) {
        alert("请先加载模板并完成自动分割。");
        return;
      }
      const obj = {
        version: 1,
        imgWidth,
        imgHeight,
        labels,
        roiAssignments,
        timestamp: new Date().toISOString(),
      };
      const blob = new Blob([JSON.stringify(obj, null, 2)], {
        type: "application/json",
      });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "root_roi_annotations.json";
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    });

    // 导出 PNG
    exportPngBtn.addEventListener("click", () => {
      if (!maskLoaded || !roiLabelData) {
        alert("请先加载模板并完成自动分割。");
        return;
      }
      maskCanvas.toBlob(blob => {
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "root_roi_colored_map.png";
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }, "image/png", 1.0);
    });

    // 窗口大小变化时重新计算 baseScale 并保持大致居中
    window.addEventListener("resize", () => {
      if (!maskLoaded) return;
      computeBaseScale();
      updateViewTransform();
    });

    // 初始化
    setInteractionMode("click");
    updateGlobalStats();
    refreshLabelList();
  </script>
</body>
</html>
