<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Root ROI Map Annotator v3</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    :root {
      --bg: #020617;
      --panel: #0f172a;
      --panel2: #111827;
      --border: #1f2937;
      --accent: #3b82f6;
      --accent-soft: rgba(59, 130, 246, 0.16);
      --text: #e5e7eb;
      --muted: #9ca3af;
      --danger: #f97373;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
        sans-serif;
      background: radial-gradient(circle at top, #111827 0, #020617 55%);
      color: var(--text);
      height: 100vh;
      display: flex;
      flex-direction: column;
    }

    header {
      padding: 0.6rem 1rem;
      border-bottom: 1px solid var(--border);
      background: rgba(15, 23, 42, 0.95);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    header h1 {
      margin: 0;
      font-size: 1rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: #93c5fd;
    }

    header span {
      font-size: 0.8rem;
      color: var(--muted);
    }

    .pill {
      font-size: 0.75rem;
      padding: 0.2rem 0.6rem;
      border-radius: 999px;
      border: 1px solid var(--border);
      color: var(--muted);
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
      background: rgba(15, 23, 42, 0.85);
    }

    main {
      flex: 1;
      display: grid;
      grid-template-columns: 260px minmax(0, 1.2fr) 260px;
      gap: 0.6rem;
      padding: 0.6rem;
      min-height: 0;
    }

    @media (max-width: 1024px) {
      main {
        grid-template-columns: minmax(0, 1fr);
        grid-template-rows: auto auto auto;
      }
    }

    .panel {
      background: var(--panel);
      border-radius: 0.75rem;
      border: 1px solid var(--border);
      padding: 0.7rem;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }

    .panel-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.5rem;
    }

    .panel-title {
      font-size: 0.85rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--muted);
    }

    .panel-subtitle {
      font-size: 0.75rem;
      color: var(--muted);
    }

    .panel-body {
      flex: 1;
      overflow: auto;
      padding-right: 0.3rem;
    }

    .section {
      margin-bottom: 0.8rem;
      padding-bottom: 0.6rem;
      border-bottom: 1px dashed #1f2937;
    }

    .section:last-child {
      border-bottom: none;
      margin-bottom: 0;
      padding-bottom: 0;
    }

    .section-title {
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: var(--muted);
      margin-bottom: 0.3rem;
    }

    label {
      display: block;
      font-size: 0.8rem;
      color: var(--muted);
      margin-bottom: 0.2rem;
    }

    input[type="file"],
    input[type="text"] {
      width: 100%;
      font-size: 0.8rem;
      padding: 0.3rem 0.4rem;
      border-radius: 0.45rem;
      border: 1px solid var(--border);
      background: var(--panel2);
      color: var(--text);
      outline: none;
    }

    input[type="file"] {
      padding: 0.2rem 0.3rem;
    }

    input[type="text"]:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 1px var(--accent-soft);
    }

    input[type="color"] {
      width: 100%;
      height: 1.8rem;
      border-radius: 0.4rem;
      border: 1px solid var(--border);
      background: transparent;
      padding: 0;
      cursor: pointer;
    }

    .button {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 0.8rem;
      padding: 0.28rem 0.6rem;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: #020617;
      color: var(--text);
      cursor: pointer;
      gap: 0.3rem;
      transition: all 0.12s ease;
    }

    .button.primary {
      background: linear-gradient(135deg, #2563eb, #4f46e5);
      border-color: transparent;
      color: white;
    }

    .button.small {
      font-size: 0.75rem;
      padding: 0.18rem 0.5rem;
    }

    .button.danger {
      border-color: rgba(248, 113, 113, 0.8);
      color: #fecaca;
    }

    .button.icon {
      padding: 0.15rem 0.35rem;
    }

    .button:hover {
      border-color: var(--accent);
      background: #020617;
    }

    .button.primary:hover {
      box-shadow: 0 10px 25px rgba(37, 99, 235, 0.6);
      transform: translateY(-1px);
    }

    .button.danger:hover {
      background: rgba(185, 28, 28, 0.45);
    }

    .row {
      display: flex;
      gap: 0.4rem;
      margin-bottom: 0.4rem;
    }

    .row > * {
      flex: 1;
    }

    .hint {
      font-size: 0.72rem;
      color: var(--muted);
      line-height: 1.4;
      margin-top: 0.25rem;
    }

    #canvasContainer {
      flex: 1;
      min-height: 0;
      border-radius: 0.7rem;
      border: 1px solid var(--border);
      background: radial-gradient(circle at center, #020617 0, #020617 60%);
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }

    #maskCanvas {
      image-rendering: auto;
      border-radius: 0.6rem;
      box-shadow: 0 14px 35px rgba(0, 0, 0, 0.75);
      position: absolute;
      top: 0;
      left: 0;
    }

    #overlayCanvas {
      position: absolute;
      top: 0;
      left: 0;
      pointer-events: none;
    }

    .empty-state {
      text-align: center;
      color: var(--muted);
      font-size: 0.8rem;
      padding: 1.2rem;
    }

    .status-line {
      font-size: 0.72rem;
      color: var(--muted);
      margin-top: 0.3rem;
    }

    #labelList {
      display: flex;
      flex-direction: column;
      gap: 0.3rem;
      margin-top: 0.3rem;
    }

    .label-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0.25rem 0.4rem;
      background: rgba(15, 23, 42, 0.95);
      border-radius: 0.5rem;
      border: 1px solid transparent;
      cursor: pointer;
      gap: 0.4rem;
      transition: all 0.12s ease;
    }

    .label-item:hover {
      border-color: var(--border);
    }

    .label-item.active {
      border-color: var(--accent);
      box-shadow: 0 0 0 1px var(--accent-soft);
      background: radial-gradient(circle at top, var(--accent-soft), #020617);
    }

    .label-color-dot {
      width: 14px;
      height: 14px;
      border-radius: 999px;
      border: 1px solid #020617;
      flex-shrink: 0;
    }

    .label-main {
      flex: 1;
      min-width: 0;
    }

    .label-main div:first-child {
      font-size: 0.8rem;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .label-main div:last-child {
      font-size: 0.7rem;
      color: var(--muted);
    }

    .badge {
      font-size: 0.7rem;
      padding: 0.05rem 0.35rem;
      border-radius: 999px;
      border: 1px solid #475569;
      color: var(--muted);
    }

    footer {
      padding: 0.3rem 0.8rem;
      font-size: 0.72rem;
      color: var(--muted);
      border-top: 1px solid var(--border);
      background: rgba(15, 23, 42, 0.96);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
  </style>
</head>
<body>
  <header>
    <div>
      <h1>Root ROI Map Annotator v3</h1>
      <span>Black-outline PNG/SVG → automatic ROI segmentation → vector-like redraw + labeling → self-contained JSON/PNG export</span>
    </div>
    <div class="pill">
      <span>Annotate: click = single ROI, drag = box</span>
      <span>Move: drag canvas</span>
      <span>Wheel zoom: center at mouse</span>
    </div>
  </header>

  <main>
    <!-- Left panel -->
    <aside class="panel">
      <div class="panel-header">
        <div class="panel-title">Input & Files</div>
      </div>
      <div class="panel-body">
        <div class="section">
          <div class="section-title">1. Root template image</div>
          <label for="maskFileInput">PNG / JPEG / SVG (black outlines + white background)</label>
          <input type="file" id="maskFileInput" accept=".png,.jpg,.jpeg,.svg,image/png,image/jpeg,image/svg+xml" />
          <div class="hint">
            Recommended: export your root PDF as a pure black-outline + white-background SVG or high-resolution PNG.
            Dark pixels are treated as boundaries, white regions are segmented as ROIs. The largest outer white region is treated as background.
            After segmentation, the original image is discarded; the map is fully redrawn per-ROI.
          </div>
          <div id="maskInfo" class="status-line"></div>
        </div>

        <div class="section">
          <div class="section-title">2. Import / Export map</div>
          <div class="row">
            <button class="button small primary" id="exportJsonBtn">Export map+annotations (JSON)</button>
            <button class="button small" id="exportPngBtn">Export colored PNG</button>
          </div>
          <label for="annotationFileInput">Import map JSON</label>
          <input type="file" id="annotationFileInput" accept="application/json,.json" />
          <div class="hint">
            The JSON now contains the full ROI map (segmentation grid + labels) and can be reloaded without the original template image.
            You can still load a template image first, then export a self-contained map.
          </div>
        </div>

        <div class="section">
          <div class="section-title">3. Interaction mode</div>
          <div class="row">
            <button class="button small primary" id="modeAnnotateBtn">Annotate</button>
            <button class="button small" id="modeMoveBtn">Move</button>
          </div>
          <div id="modeStatus" class="status-line"></div>
        </div>
      </div>
    </aside>

    <!-- Center canvas -->
    <section class="panel">
      <div class="panel-header">
        <div>
          <div class="panel-title">ROI Map View</div>
          <div class="panel-subtitle">
            Automatically segmented ROIs, redrawn as clean regions with borders. Annotate by click or drag, move the map in Move mode.
          </div>
        </div>
        <div id="hoverInfo" class="pill">No image loaded</div>
      </div>
      <div id="canvasContainer">
        <canvas id="maskCanvas"></canvas>
        <canvas id="overlayCanvas"></canvas>
        <div id="emptyState" class="empty-state">
          Please upload a root template image (PNG/JPEG/SVG, black outlines + white background) on the left,<br/>
          or import a previously exported map JSON.<br /><br />
          After loading, the tool will:<br />
          · Detect each closed white region as an ROI (non-closed internal gaps are not separated)<br />
          · Treat the largest outer white region as background and ignore it<br />
          · Redraw each ROI as a clean region with its own border (no original internal lines)<br />
          You can then create labels and annotate ROIs.
        </div>
      </div>
    </section>

    <!-- Right panel: labels -->
    <aside class="panel">
      <div class="panel-header">
        <div class="panel-title">Labels & Stats</div>
        <button class="button small danger" id="clearAllBtn">Clear labels</button>
      </div>
      <div class="panel-body">
        <div class="section">
          <div class="section-title">1. Create label</div>
          <label for="labelNameInput">Label name</label>
          <input type="text" id="labelNameInput" placeholder="e.g. Meristem / Cortex / QC" />
          <label for="labelColorInput">Label color</label>
          <input type="color" id="labelColorInput" />
          <button class="button primary" id="addLabelBtn" style="margin-top:0.4rem;width:100%;">Add label</button>
          <div class="hint">
            After creating a label, click it in the list to toggle it as the “active” label (click again to deactivate).
            When no label is active, clicking/dragging only clears labels on selected ROIs.
            Colors auto-advance through a default palette and will not repeat consecutively.
          </div>
        </div>

        <div class="section">
          <div class="section-title">2. Label list</div>
          <div id="labelList"></div>
          <div id="labelEmptyHint" class="hint">
            No labels yet. Please create at least one label.
          </div>
        </div>

        <div class="section">
          <div class="section-title">3. Global stats</div>
          <div id="globalStats" class="hint">No image or map loaded yet.</div>
        </div>
      </div>
    </aside>
  </main>

  <footer>
    <div>Note: the largest white connected region is treated as outside background and ignored.</div>
    <div id="selectionStatus">No ROI selected</div>
  </footer>

  <script>
    // ===== Global state =====
    const maskCanvas = document.getElementById("maskCanvas");
    const overlayCanvas = document.getElementById("overlayCanvas");
    const ctx = maskCanvas.getContext("2d");
    const overlayCtx = overlayCanvas.getContext("2d");
    const canvasContainer = document.getElementById("canvasContainer");
    const emptyState = document.getElementById("emptyState");

    const maskFileInput = document.getElementById("maskFileInput");
    const annotationFileInput = document.getElementById("annotationFileInput");
    const maskInfo = document.getElementById("maskInfo");
    const hoverInfo = document.getElementById("hoverInfo");
    const globalStats = document.getElementById("globalStats");
    const selectionStatus = document.getElementById("selectionStatus");
    const modeStatus = document.getElementById("modeStatus");

    const modeAnnotateBtn = document.getElementById("modeAnnotateBtn");
    const modeMoveBtn = document.getElementById("modeMoveBtn");

    const addLabelBtn = document.getElementById("addLabelBtn");
    const labelNameInput = document.getElementById("labelNameInput");
    const labelColorInput = document.getElementById("labelColorInput");
    const labelListEl = document.getElementById("labelList");
    const labelEmptyHint = document.getElementById("labelEmptyHint");
    const clearAllBtn = document.getElementById("clearAllBtn");

    const exportJsonBtn = document.getElementById("exportJsonBtn");
    const exportPngBtn = document.getElementById("exportPngBtn");

    let imgWidth = 0;
    let imgHeight = 0;
    let maskLoaded = false;

    // ROI ID per pixel (0 = background, 1..N)
    let roiLabelData = null;
    let roiCount = 0;

    // ROI → pixel list & centroid (for hover float effect)
    let roiPixelMap = {}; // roiId -> {pixels: [{x,y}, ...], cx, cy}

    // Labels
    let labels = [];       // {id, name, color}
    let activeLabelId = null;
    let roiAssignments = {}; // { roiId: labelId }

    // Default color palette
    const defaultColors = [
      "#ef4444","#f97316","#facc15","#22c55e","#14b8a6",
      "#0ea5e9","#6366f1","#8b5cf6","#ec4899","#f97373"
    ];
    let colorIndex = 0;

    // Interaction mode
    let interactionMode = "annotate"; // "annotate" | "move"

    // Combined click + box selection (for annotate mode)
    let mouseDown = false;
    let mouseDownPos = null;
    let isBoxSelecting = false;
    let dragStart = null;
    let dragCurrent = null;
    const BOX_THRESHOLD = 3; // pixels

    // View transform (zoom & pan)
    let baseScale = 1;
    let viewScale = 1;
    const minScale = 0.3;
    const maxScale = 5;
    let panX = 0;
    let panY = 0;

    // Move mode (drag canvas)
    let isPanning = false;
    let panStartClientX = 0;
    let panStartClientY = 0;
    let panStartX = 0;
    let panStartY = 0;

    // Hover float animation
    let hoveredRoiId = 0;
    let hoverScaleCurrent = 1.0;
    let hoverScaleTarget = 1.0;
    const hoverScaleMax = 1.05;
    const hoverAnimSpeed = 8.0; // approach speed

    // ===== Utility functions =====
    function hexToRgb(hex) {
      hex = hex.replace("#", "");
      if (hex.length === 3) {
        hex = hex.split("").map(c => c + c).join("");
      }
      const num = parseInt(hex, 16);
      return {
        r: (num >> 16) & 255,
        g: (num >> 8) & 255,
        b: num & 255,
      };
    }

    function getNextColor() {
      const color = defaultColors[colorIndex % defaultColors.length];
      colorIndex++;
      return color;
    }

    function setMaskInfo(text) {
      maskInfo.textContent = text || "";
    }

    function setInteractionMode(mode) {
      interactionMode = mode;

      modeAnnotateBtn.classList.toggle("primary", mode === "annotate");
      modeMoveBtn.classList.toggle("primary", mode === "move");

      if (mode === "annotate") {
        modeStatus.innerHTML =
          "Mode: <strong>Annotate</strong>. Click = single ROI; drag = box selection. Box only selects/overwrites, no toggle-off.";
      } else {
        modeStatus.innerHTML =
          "Mode: <strong>Move</strong>. Hold left mouse button to pan; use wheel to zoom at the mouse position.";
      }
    }

    function updateGlobalStats() {
      if (!maskLoaded || !roiLabelData) {
        globalStats.textContent = "No image or map loaded yet.";
        return;
      }
      const used = new Set();
      for (let i = 0; i < roiLabelData.length; i++) {
        if (roiLabelData[i] > 0) used.add(roiLabelData[i]);
      }
      const total = used.size;
      const labeledSet = new Set(
        Object.keys(roiAssignments)
          .filter(k => roiAssignments[k])
          .map(k => parseInt(k, 10))
      );
      const labeled = labeledSet.size;
      globalStats.innerHTML = `Total ROIs: <strong>${total}</strong><br/>Labeled ROIs: <strong>${labeled}</strong> (${
        total ? (labeled / total * 100).toFixed(1) : 0
      }%)`;
    }

    function updateSelectionStatus(text) {
      selectionStatus.textContent = text || "No ROI selected";
    }

    function resizeCanvases(width, height) {
      maskCanvas.width = width;
      maskCanvas.height = height;
      overlayCanvas.width = width;
      overlayCanvas.height = height;

      maskCanvas.style.width = width + "px";
      maskCanvas.style.height = height + "px";
      overlayCanvas.style.width = width + "px";
      overlayCanvas.style.height = height + "px";

      computeBaseScale();
      viewScale = 1;
      panX = 0;
      panY = 0;
      updateViewTransform();
    }

    function computeBaseScale() {
      const rect = canvasContainer.getBoundingClientRect();
      if (!imgWidth || !imgHeight || !rect.width || !rect.height) return;
      baseScale = Math.min(rect.width / imgWidth, rect.height / imgHeight);
    }

    function updateViewTransform() {
      if (!imgWidth || !imgHeight) return;
      if (!baseScale) computeBaseScale();

      const rect = canvasContainer.getBoundingClientRect();
      const scale = baseScale * viewScale;

      const tx = (rect.width - imgWidth * scale) / 2 + panX;
      const ty = (rect.height - imgHeight * scale) / 2 + panY;

      const transform = `translate(${tx}px, ${ty}px) scale(${scale})`;

      maskCanvas.style.transformOrigin = "top left";
      overlayCanvas.style.transformOrigin = "top left";
      maskCanvas.style.transform = transform;
      overlayCanvas.style.transform = transform;
    }

    function refreshLabelList() {
      labelListEl.innerHTML = "";
      if (!labels.length) {
        labelEmptyHint.style.display = "block";
        return;
      }
      labelEmptyHint.style.display = "none";

      const counts = {};
      for (const [roiId, labelId] of Object.entries(roiAssignments)) {
        if (!labelId) continue;
        counts[labelId] = (counts[labelId] || 0) + 1;
      }

      labels.forEach(label => {
        const item = document.createElement("div");
        item.className = "label-item" + (label.id === activeLabelId ? " active" : "");
        item.dataset.labelId = label.id;

        const colorDot = document.createElement("div");
        colorDot.className = "label-color-dot";
        colorDot.style.backgroundColor = label.color;

        const main = document.createElement("div");
        main.className = "label-main";
        const nameDiv = document.createElement("div");
        nameDiv.textContent = label.name || "(Untitled)";
        const metaDiv = document.createElement("div");
        metaDiv.textContent = `ID: ${label.id} · ROIs: ${counts[label.id] || 0}`;

        main.appendChild(nameDiv);
        main.appendChild(metaDiv);

        const rightBox = document.createElement("div");
        rightBox.style.display = "flex";
        rightBox.style.alignItems = "center";
        rightBox.style.gap = "0.25rem";

        const badge = document.createElement("div");
        badge.className = "badge";
        badge.textContent = "Active";
        if (label.id !== activeLabelId) badge.style.visibility = "hidden";

        const delBtn = document.createElement("button");
        delBtn.className = "button small icon";
        delBtn.textContent = "×";
        delBtn.title = "Delete label";
        delBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          deleteLabel(label.id);
        });

        rightBox.appendChild(badge);
        rightBox.appendChild(delBtn);

        item.appendChild(colorDot);
        item.appendChild(main);
        item.appendChild(rightBox);

        item.addEventListener("click", () => {
          if (activeLabelId === label.id) {
            activeLabelId = null; // toggle off
          } else {
            activeLabelId = label.id;
          }
          refreshLabelList();
        });

        labelListEl.appendChild(item);
      });
    }

    function deleteLabel(labelId) {
      labels = labels.filter(l => l.id !== labelId);
      if (activeLabelId === labelId) activeLabelId = null;
      // remove assignments of this label
      for (const [roiId, lid] of Object.entries(roiAssignments)) {
        if (lid === labelId) {
          delete roiAssignments[roiId];
        }
      }
      refreshLabelList();
      updateGlobalStats();
      renderBase();
      renderOverlay();
    }

    function addLabel(name, colorInputValue) {
      const color = colorInputValue || getNextColor();
      const id = "L" + (labels.length + 1);
      labels.push({ id, name: name || `Label ${labels.length + 1}`, color });
      activeLabelId = id;
      refreshLabelList();
      // advance color picker
      labelColorInput.value = getNextColor();
    }

    // ===== RLE encode / decode for roiLabelData (to store full map in JSON) =====
    function encodeRLE(arr) {
      if (!arr || arr.length === 0) return [];
      const out = [];
      let currentVal = arr[0];
      let runLength = 1;
      for (let i = 1; i < arr.length; i++) {
        const v = arr[i];
        if (v === currentVal) {
          runLength++;
        } else {
          out.push([currentVal, runLength]);
          currentVal = v;
          runLength = 1;
        }
      }
      out.push([currentVal, runLength]);
      return out;
    }

    function decodeRLE(rle, totalLength) {
      const arr = new Uint16Array(totalLength);
      let idx = 0;
      for (const [val, len] of rle) {
        for (let i = 0; i < len; i++) {
          if (idx >= totalLength) break;
          arr[idx++] = val;
        }
        if (idx >= totalLength) break;
      }
      return arr;
    }

    // ===== Build ROI geometry (pixel lists & centroids) from roiLabelData =====
    function rebuildRoiFromLabelData() {
      roiPixelMap = {};
      roiCount = 0;
      if (!roiLabelData) return;
      const pixels = roiLabelData.length;
      let maxId = 0;

      for (let i = 0; i < pixels; i++) {
        const id = roiLabelData[i];
        if (id > maxId) maxId = id;
        if (id > 0) {
          const x = i % imgWidth;
          const y = (i / imgWidth) | 0;
          if (!roiPixelMap[id]) {
            roiPixelMap[id] = { pixels: [], cx: 0, cy: 0 };
          }
          roiPixelMap[id].pixels.push({ x, y });
        }
      }
      roiCount = maxId;

      // compute centroid for each ROI
      for (const [key, obj] of Object.entries(roiPixelMap)) {
        const arr = obj.pixels;
        let sx = 0, sy = 0;
        for (const p of arr) {
          sx += p.x;
          sy += p.y;
        }
        const n = arr.length || 1;
        obj.cx = sx / n;
        obj.cy = sy / n;
      }
    }

    // ===== Segmentation: dark pixels = boundary, white connected regions = ROIs =====
    function segmentImageToRois() {
      const imageData = ctx.getImageData(0, 0, imgWidth, imgHeight);
      const data = imageData.data;
      const pixels = imgWidth * imgHeight;

      const labelsArr = new Int32Array(pixels);
      const isBoundary = new Uint8Array(pixels);

      // mark boundary pixels (dark lines)
      for (let i = 0; i < pixels; i++) {
        const r = data[i * 4];
        const g = data[i * 4 + 1];
        const b = data[i * 4 + 2];
        const a = data[i * 4 + 3];

        const brightness = (r + g + b) / 3;
        if (a > 0 && brightness < 220) {
          isBoundary[i] = 1;
        }
      }

      let currentLabel = 0;
      const stack = [];

      function pushIfValid(idx) {
        if (idx < 0 || idx >= pixels) return;
        if (isBoundary[idx]) return;
        if (labelsArr[idx] !== 0) return;
        labelsArr[idx] = currentLabel;
        stack.push(idx);
      }

      // 4-connected component labeling on non-boundary pixels
      for (let i = 0; i < pixels; i++) {
        if (isBoundary[i]) continue;
        if (labelsArr[i] !== 0) continue;
        currentLabel++;
        labelsArr[i] = currentLabel;
        stack.length = 0;
        stack.push(i);

        while (stack.length > 0) {
          const idx = stack.pop();
          const x = idx % imgWidth;
          const y = (idx / imgWidth) | 0;
          if (x > 0) pushIfValid(idx - 1);
          if (x < imgWidth - 1) pushIfValid(idx + 1);
          if (y > 0) pushIfValid(idx - imgWidth);
          if (y < imgHeight - 1) pushIfValid(idx + imgWidth);
          if (y < imgHeight - 1) pushIfValid(idx + imgWidth);
        }
      }

      // find largest region → outside background
      const areas = new Array(currentLabel + 1).fill(0);
      for (let i = 0; i < pixels; i++) {
        const l = labelsArr[i];
        if (l > 0) areas[l]++;
      }

      let largestLabel = 0;
      let largestArea = 0;
      for (let l = 1; l <= currentLabel; l++) {
        if (areas[l] > largestArea) {
          largestArea = areas[l];
          largestLabel = l;
        }
      }

      // remap labels: largest region → 0 (background), others → 1..N
      const labelMap = new Int32Array(currentLabel + 1);
      let newId = 1;
      for (let l = 1; l <= currentLabel; l++) {
        if (l === largestLabel) {
          labelMap[l] = 0;
        } else {
          labelMap[l] = newId++;
        }
      }

      roiLabelData = new Uint16Array(pixels);
      for (let i = 0; i < pixels; i++) {
        const old = labelsArr[i];
        roiLabelData[i] = labelMap[old];
      }

      // build per-ROI geometry
      rebuildRoiFromLabelData();

      setMaskInfo(`Segmentation done: found ${roiCount} non-background ROIs (outer background removed).`);
      updateGlobalStats();

      // clear original raster; from now on we fully redraw per ROI
      ctx.clearRect(0, 0, imgWidth, imgHeight);
    }

    // ===== Base map render (ROI fill + anti-aliased-ish borders), no hover/box =====
    function renderBase() {
      if (!maskLoaded || !roiLabelData) return;

      const imageData = ctx.createImageData(imgWidth, imgHeight);
      const data = imageData.data;
      const total = roiLabelData.length;

      const bgR = 18, bgG = 24, bgB = 38;

      for (let idx = 0; idx < total; idx++) {
        const roiId = roiLabelData[idx];
        let r, g, b, a;
        if (roiId === 0) {
          r = bgR; g = bgG; b = bgB; a = 255;
        } else {
          const labelId = roiAssignments[roiId];
          if (labelId) {
            const label = labels.find(l => l.id === labelId);
            if (label) {
              const { r: lr, g: lg, b: lb } = hexToRgb(label.color);
              r = lr; g = lg; b = lb; a = 255;
            } else {
              r = 150; g = 150; b = 150; a = 255;
            }
          } else {
            r = 120; g = 120; b = 120; a = 255;
          }
        }
        data[idx * 4] = r;
        data[idx * 4 + 1] = g;
        data[idx * 4 + 2] = b;
        data[idx * 4 + 3] = a;
      }

      // overlay borders by darkening boundary pixels
      const w = imgWidth;
      const h = imgHeight;
      const darkerFactor = 0.65;
      for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
          const idx = y * w + x;
          const roiId = roiLabelData[idx];
          if (roiId <= 0) continue;

          let isBoundary = false;
          // 4-neighborhood
          if (x > 0 && roiLabelData[idx - 1] !== roiId) isBoundary = true;
          else if (x < w - 1 && roiLabelData[idx + 1] !== roiId) isBoundary = true;
          else if (y > 0 && roiLabelData[idx - w] !== roiId) isBoundary = true;
          else if (y < h - 1 && roiLabelData[idx + w] !== roiId) isBoundary = true;

          if (isBoundary) {
            const di = idx * 4;
            data[di] = data[di] * darkerFactor;
            data[di + 1] = data[di + 1] * darkerFactor;
            data[di + 2] = data[di + 2] * darkerFactor;
          }
        }
      }

      ctx.putImageData(imageData, 0, 0);
      updateGlobalStats();
      refreshLabelList();
    }

    // ===== Overlay render (box selection + hover float with border) =====
    function renderOverlay() {
      overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);

      // Box selection rectangle (in annotate mode only)
      if (interactionMode === "annotate" && isBoxSelecting && dragStart && dragCurrent) {
        overlayCtx.save();
        overlayCtx.setLineDash([4, 3]);
        overlayCtx.lineWidth = 1.5;
        overlayCtx.strokeStyle = "rgba(96,165,250,0.9)";
        overlayCtx.fillStyle = "rgba(37,99,235,0.18)";

        const x = Math.min(dragStart.x, dragCurrent.x);
        const y = Math.min(dragStart.y, dragCurrent.y);
        const w = Math.abs(dragCurrent.x - dragStart.x);
        const h = Math.abs(dragCurrent.y - dragStart.y);

        overlayCtx.fillRect(x, y, w, h);
        overlayCtx.strokeRect(x, y, w, h);
        overlayCtx.restore();
      }

      // Hover float effect (slight scale + brighter fill + border)
      if (hoveredRoiId > 0 && roiPixelMap[hoveredRoiId]) {
        const obj = roiPixelMap[hoveredRoiId];
        const { pixels, cx, cy } = obj;
        const labelId = roiAssignments[hoveredRoiId];
        let baseColor = "#d1d5db"; // light gray if no label
        if (labelId) {
          const label = labels.find(l => l.id === labelId);
          baseColor = label ? label.color : baseColor;
        }
        const { r, g, b } = hexToRgb(baseColor);
        const s = hoverScaleCurrent;

        // slightly brighter fill
        overlayCtx.fillStyle = `rgba(${Math.min(r+40,255)},${Math.min(g+40,255)},${Math.min(b+40,255)},0.9)`;
        for (const p of pixels) {
          const dx = p.x - cx;
          const dy = p.y - cy;
          const nx = cx + dx * s;
          const ny = cy + dy * s;
          overlayCtx.fillRect(nx, ny, 1, 1);
        }

        // border line on top
        overlayCtx.fillStyle = "rgba(15,23,42,0.95)";
        const w = imgWidth;
        for (const p of pixels) {
          const x = p.x;
          const y = p.y;
          const idx = y * w + x;
          let isBoundary = false;
          if (x > 0 && roiLabelData[idx - 1] !== hoveredRoiId) isBoundary = true;
          else if (x < imgWidth - 1 && roiLabelData[idx + 1] !== hoveredRoiId) isBoundary = true;
          else if (y > 0 && roiLabelData[idx - imgWidth] !== hoveredRoiId) isBoundary = true;
          else if (y < imgHeight - 1 && roiLabelData[idx + imgWidth] !== hoveredRoiId) isBoundary = true;

          if (isBoundary) {
            const dx = x - cx;
            const dy = y - cy;
            const nx = cx + dx * s;
            const ny = cy + dy * s;
            overlayCtx.fillRect(nx, ny, 1, 1);
          }
        }
      }
    }

    // ===== Mouse position → image pixel =====
    function canvasPixelFromEvent(evt) {
      const rect = maskCanvas.getBoundingClientRect();
      const scaleX = maskCanvas.width / rect.width;
      const scaleY = maskCanvas.height / rect.height;
      const x = Math.floor((evt.clientX - rect.left) * scaleX);
      const y = Math.floor((evt.clientY - rect.top) * scaleY);
      if (x < 0 || y < 0 || x >= maskCanvas.width || y >= maskCanvas.height) return null;
      return { x, y };
    }

    function getRoiIdAt(x, y) {
      if (!roiLabelData) return 0;
      const idx = y * imgWidth + x;
      if (idx < 0 || idx >= roiLabelData.length) return 0;
      return roiLabelData[idx];
    }

    // Single-click logic (toggle for same label, overwrite for others)
    function handleClickAt(p) {
      const roiId = getRoiIdAt(p.x, p.y);
      if (roiId === 0) {
        updateSelectionStatus("Clicked background (no ROI).");
        return;
      }
      const current = roiAssignments[roiId];
      if (activeLabelId) {
        if (current === activeLabelId) {
          // same label → clear
          delete roiAssignments[roiId];
          updateSelectionStatus(`ROI ${roiId} label removed.`);
        } else {
          // overwrite with active label
          roiAssignments[roiId] = activeLabelId;
          updateSelectionStatus(`ROI ${roiId} set to label ${activeLabelId}.`);
        }
      } else {
        // no active label: only clear if labeled
        if (current) {
          delete roiAssignments[roiId];
          updateSelectionStatus(`ROI ${roiId} label removed.`);
        } else {
          updateSelectionStatus(`ROI ${roiId} has no label and no active label is selected.`);
        }
      }
      renderBase();
      renderOverlay();
    }

    // Box selection logic (no toggle-off by reselect; only assign/overwrite, or clear if no active label)
    function handleBoxSelection(p1, p2) {
      const roiIds = getRoiIdsInRect(p1.x, p1.y, p2.x, p2.y);
      if (!roiIds.length) {
        updateSelectionStatus("No ROI in box selection.");
        return;
      }
      if (activeLabelId) {
        // assign/overwrite all to active label
        roiIds.forEach(id => {
          if (id > 0) roiAssignments[id] = activeLabelId;
        });
        updateSelectionStatus(
          `Box selection: ${roiIds.length} ROIs set to label ${activeLabelId}.`
        );
      } else {
        // no active label: clear labels in the box
        roiIds.forEach(id => {
          if (id > 0 && roiAssignments[id]) {
            delete roiAssignments[id];
          }
        });
        updateSelectionStatus(
          `Box selection: labels cleared for ${roiIds.length} ROIs (no active label).`
        );
      }
      renderBase();
      renderOverlay();
    }

    function getRoiIdsInRect(x1, y1, x2, y2) {
      const minX = Math.max(0, Math.min(x1, x2));
      const maxX = Math.min(imgWidth - 1, Math.max(x1, x2));
      const minY = Math.max(0, Math.min(y1, y2));
      const maxY = Math.min(imgHeight - 1, Math.max(y1, y2));
      const set = new Set();
      for (let y = minY; y <= maxY; y++) {
        let rowOffset = y * imgWidth;
        for (let x = minX; x <= maxX; x++) {
          const roiId = roiLabelData[rowOffset + x];
          if (roiId > 0) set.add(roiId);
        }
      }
      return Array.from(set);
    }

    // ===== Image load =====
    maskFileInput.addEventListener("change", e => {
      const file = e.target.files[0];
      if (!file) return;

      const img = new Image();
      img.onload = () => {
        // upsample small images slightly to get a more "vector-like" feel
        let targetWidth = img.width;
        let targetHeight = img.height;
        const maxDim = 2000;
        const scale = Math.min(maxDim / img.width, maxDim / img.height, 1.5);
        if (scale > 1) {
          targetWidth = Math.round(img.width * scale);
          targetHeight = Math.round(img.height * scale);
        }

        imgWidth = targetWidth;
        imgHeight = targetHeight;
        resizeCanvases(imgWidth, imgHeight);

        // draw template for segmentation
        ctx.clearRect(0, 0, imgWidth, imgHeight);
        ctx.drawImage(img, 0, 0, img.width, img.height, 0, 0, imgWidth, imgHeight);

        emptyState.style.display = "none";
        maskLoaded = true;

        // segmentation & redraw
        segmentImageToRois();
        roiAssignments = {};
        renderBase();
        renderOverlay();
        hoverInfo.textContent = `Size: ${imgWidth} × ${imgHeight} · ~${roiCount} ROIs`;
        setMaskInfo(`Loaded: ${file.name} · ~${roiCount} ROIs`);
        updateSelectionStatus("No ROI selected");
      };

      img.onerror = () => {
        alert("Failed to load image. Please ensure it is a black-outline + white-background PNG/JPEG/SVG.");
      };

      const url = URL.createObjectURL(file);
      img.src = url;
    });

    // Import self-contained map JSON (geometry + labels)
    annotationFileInput.addEventListener("change", e => {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = evt => {
        try {
          const json = JSON.parse(evt.target.result);
          if (!json.labels || !json.roiAssignments || !json.imgWidth || !json.imgHeight) {
            alert("Invalid JSON. Expected keys: imgWidth, imgHeight, labels, roiAssignments, roiRLE.");
            return;
          }

          imgWidth = json.imgWidth;
          imgHeight = json.imgHeight;
          resizeCanvases(imgWidth, imgHeight);

          if (json.roiRLE && Array.isArray(json.roiRLE)) {
            const total = imgWidth * imgHeight;
            roiLabelData = decodeRLE(json.roiRLE, total);
            rebuildRoiFromLabelData();
            maskLoaded = true;
            emptyState.style.display = "none";
          } else {
            alert("This JSON does not contain ROI geometry (roiRLE). You may need to re-export with the new version.");
            return;
          }

          labels = json.labels;
          roiAssignments = json.roiAssignments || {};
          activeLabelId = labels.length ? labels[0].id : null;

          renderBase();
          renderOverlay();
          refreshLabelList();
          updateGlobalStats();
          hoverInfo.textContent = `Map loaded from JSON: ${imgWidth} × ${imgHeight} · ${roiCount} ROIs`;
          setMaskInfo("Self-contained map JSON loaded.");
          updateSelectionStatus("No ROI selected");
        } catch (err) {
          console.error(err);
          alert("Failed to parse JSON. Please check that this is a map file exported from this tool.");
        }
      };
      reader.readAsText(file);
    });

    // Create label
    addLabelBtn.addEventListener("click", () => {
      const name = labelNameInput.value.trim();
      const color = labelColorInput.value || getNextColor();
      addLabel(name, color);
      labelNameInput.value = "";
      renderBase();
      renderOverlay();
    });

    // Clear labels + assignments
    clearAllBtn.addEventListener("click", () => {
      labels = [];
      roiAssignments = {};
      activeLabelId = null;
      refreshLabelList();
      updateGlobalStats();
      renderBase();
      renderOverlay();
    });

    // Mode switching
    modeAnnotateBtn.addEventListener("click", () => setInteractionMode("annotate"));
    modeMoveBtn.addEventListener("click", () => setInteractionMode("move"));

    // Wheel zoom (centered at mouse)
    canvasContainer.addEventListener("wheel", e => {
      if (!maskLoaded) return;
      e.preventDefault();
      const rect = canvasContainer.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;

      const oldScale = baseScale * viewScale;
      const factor = e.deltaY > 0 ? 0.9 : 1.1;
      let newViewScale = viewScale * factor;
      if (newViewScale < minScale) newViewScale = minScale;
      if (newViewScale > maxScale) newViewScale = maxScale;
      const newScale = baseScale * newViewScale;

      const tx = (rect.width - imgWidth * oldScale) / 2 + panX;
      const ty = (rect.height - imgHeight * oldScale) / 2 + panY;
      const imgX = (mouseX - tx) / oldScale;
      const imgY = (mouseY - ty) / oldScale;

      const newTx = mouseX - imgX * newScale;
      const newTy = mouseY - imgY * newScale;

      panX = newTx - (rect.width - imgWidth * newScale) / 2;
      panY = newTy - (rect.height - imgHeight * newScale) / 2;
      viewScale = newViewScale;
      updateViewTransform();
    }, { passive: false });

    // Move mode: drag canvas with left mouse
    canvasContainer.addEventListener("mousedown", e => {
      if (!maskLoaded) return;
      if (e.button !== 0) return;
      if (interactionMode !== "move") return;
      isPanning = true;
      panStartClientX = e.clientX;
      panStartClientY = e.clientY;
      panStartX = panX;
      panStartY = panY;
    });

    window.addEventListener("mousemove", e => {
      if (isPanning) {
        const dx = e.clientX - panStartClientX;
        const dy = e.clientY - panStartClientY;
        panX = panStartX + dx;
        panY = panStartY + dy;
        updateViewTransform();
      }
    });

    window.addEventListener("mouseup", e => {
      if (isPanning && e.button === 0) {
        isPanning = false;
      }
    });

    // Canvas hover + annotate (click/drag)
    maskCanvas.addEventListener("mousemove", e => {
      if (!maskLoaded || !roiLabelData) return;
      const p = canvasPixelFromEvent(e);
      if (!p) return;
      const roiId = getRoiIdAt(p.x, p.y);
      if (roiId === 0) {
        hoverInfo.textContent = `Pos: (${p.x}, ${p.y}) · Background`;
      } else {
        const labelId = roiAssignments[roiId];
        const labelName = labelId
          ? (labels.find(l => l.id === labelId)?.name || labelId)
          : "Unlabeled";
        hoverInfo.textContent = `Pos: (${p.x}, ${p.y}) · ROI ID: ${roiId} · Label: ${labelName}`;
      }

      // Hover float update
      if (roiId !== hoveredRoiId) {
        hoveredRoiId = roiId;
        hoverScaleTarget = roiId > 0 ? hoverScaleMax : 1.0;
      }

      // Annotate mode: track drag to decide click vs box
      if (interactionMode === "annotate" && mouseDown && mouseDownPos) {
        const dx = p.x - mouseDownPos.x;
        const dy = p.y - mouseDownPos.y;
        const dist2 = dx * dx + dy * dy;
        if (!isBoxSelecting && dist2 > BOX_THRESHOLD * BOX_THRESHOLD) {
          // start box selection
          isBoxSelecting = true;
          dragStart = { ...mouseDownPos };
          dragCurrent = p;
        } else if (isBoxSelecting) {
          dragCurrent = p;
        }
      }

      renderOverlay();
    });

    maskCanvas.addEventListener("mouseleave", () => {
      if (!maskLoaded) return;
      hoverInfo.textContent = "Mouse left ROI view";
      hoveredRoiId = 0;
      hoverScaleTarget = 1.0;
      if (interactionMode === "annotate") {
        mouseDown = false;
        isBoxSelecting = false;
        mouseDownPos = null;
        dragStart = null;
        dragCurrent = null;
      }
      renderOverlay();
    });

    maskCanvas.addEventListener("mousedown", e => {
      if (!maskLoaded || !roiLabelData) return;
      if (e.button !== 0) return;
      const p = canvasPixelFromEvent(e);
      if (!p) return;

      if (interactionMode === "annotate") {
        mouseDown = true;
        mouseDownPos = p;
        isBoxSelecting = false;
        dragStart = null;
        dragCurrent = null;
      }
      // move mode drag handled on canvasContainer
    });

    maskCanvas.addEventListener("mouseup", e => {
      if (!maskLoaded || !roiLabelData) return;
      if (e.button !== 0) return;
      if (interactionMode !== "annotate") return;

      const p = canvasPixelFromEvent(e);
      const wasBox = isBoxSelecting && dragStart && dragCurrent;
      const startPos = mouseDownPos;

      mouseDown = false;
      mouseDownPos = null;
      isBoxSelecting = false;

      if (!p || !startPos) {
        dragStart = null;
        dragCurrent = null;
        renderOverlay();
        return;
      }

      if (!wasBox) {
        // treat as single click
        handleClickAt(p);
      } else {
        // box selection
        handleBoxSelection(dragStart, dragCurrent);
      }

      dragStart = null;
      dragCurrent = null;
      renderOverlay();
    });

    // Export self-contained JSON
    exportJsonBtn.addEventListener("click", () => {
      if (!maskLoaded || !roiLabelData) {
        alert("Please load a template image or map JSON and run segmentation first.");
        return;
      }
      const rle = encodeRLE(roiLabelData);
      const obj = {
        version: 2,
        imgWidth,
        imgHeight,
        labels,
        roiAssignments,
        roiRLE: rle,
        timestamp: new Date().toISOString(),
      };
      const blob = new Blob([JSON.stringify(obj, null, 2)], {
        type: "application/json",
      });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "root_roi_map_and_annotations.json";
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    });

    // Export colored PNG
    exportPngBtn.addEventListener("click", () => {
      if (!maskLoaded || !roiLabelData) {
        alert("Please load a template image or map JSON and run segmentation first.");
        return;
      }
      maskCanvas.toBlob(blob => {
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "root_roi_colored_map.png";
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }, "image/png", 1.0);
    });

    // Window resize: keep centered
    window.addEventListener("resize", () => {
      if (!maskLoaded) return;
      computeBaseScale();
      updateViewTransform();
    });

    // Hover animation loop
    function hoverAnimLoop() {
      const dt = 1 / 60;
      const diff = hoverScaleTarget - hoverScaleCurrent;
      hoverScaleCurrent += diff * Math.min(1, hoverAnimSpeed * dt);
      if (Math.abs(diff) < 0.001) {
        hoverScaleCurrent = hoverScaleTarget;
      }
      renderOverlay();
      requestAnimationFrame(hoverAnimLoop);
    }

    // Init
    (function init() {
      setInteractionMode("annotate");
      updateGlobalStats();
      refreshLabelList();
      labelColorInput.value = getNextColor();
      hoverAnimLoop();
    })();
  </script>
</body>
</html>
