<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Root ROI Map Annotator v6 (Unified Raster-to-Vector)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    :root {
      --bg: #020617;
      --panel: #0f172a;
      --panel2: #111827;
      --border: #1f2937;
      --accent: #3b82f6;
      --accent-soft: rgba(59, 130, 246, 0.16);
      --text: #e5e7eb;
      --muted: #9ca3af;
      --danger: #f97373;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: radial-gradient(circle at top, #111827 0, #020617 55%);
      color: var(--text);
      height: 100vh;
      display: flex;
      flex-direction: column;
    }
    header {
      padding: 0.6rem 1rem;
      border-bottom: 1px solid var(--border);
      background: rgba(15, 23, 42, 0.95);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    header h1 {
      margin: 0;
      font-size: 1rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: #93c5fd;
    }
    header span {
      font-size: 0.8rem;
      color: var(--muted);
    }
    .pill {
      font-size: 0.75rem;
      padding: 0.2rem 0.6rem;
      border-radius: 999px;
      border: 1px solid var(--border);
      color: var(--muted);
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
      background: rgba(15, 23, 42, 0.85);
    }
    main {
      flex: 1;
      display: grid;
      grid-template-columns: 260px minmax(0, 1.2fr) 260px;
      gap: 0.6rem;
      padding: 0.6rem;
      min-height: 0;
    }
    @media (max-width: 1024px) {
      main {
        grid-template-columns: minmax(0, 1fr);
        grid-template-rows: auto auto auto;
      }
    }
    .panel {
      background: var(--panel);
      border-radius: 0.75rem;
      border: 1px solid var(--border);
      padding: 0.7rem;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }
    .panel-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.5rem;
    }
    .panel-title {
      font-size: 0.85rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--muted);
    }
    .panel-subtitle {
      font-size: 0.75rem;
      color: var(--muted);
    }
    .panel-body {
      flex: 1;
      overflow: auto;
      padding-right: 0.3rem;
    }
    .section {
      margin-bottom: 0.8rem;
      padding-bottom: 0.6rem;
      border-bottom: 1px dashed #1f2937;
    }
    .section:last-child {
      border-bottom: none;
      margin-bottom: 0;
      padding-bottom: 0;
    }
    .section-title {
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: var(--muted);
      margin-bottom: 0.3rem;
    }
    label {
      display: block;
      font-size: 0.8rem;
      color: var(--muted);
      margin-bottom: 0.2rem;
    }
    input[type="file"],
    input[type="text"] {
      width: 100%;
      font-size: 0.8rem;
      padding: 0.3rem 0.4rem;
      border-radius: 0.45rem;
      border: 1px solid var(--border);
      background: var(--panel2);
      color: var(--text);
      outline: none;
    }
    input[type="file"] { padding: 0.2rem 0.3rem; }
    input[type="text"]:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 1px var(--accent-soft);
    }
    input[type="color"] {
      width: 100%;
      height: 1.8rem;
      border-radius: 0.4rem;
      border: 1px solid var(--border);
      background: transparent;
      padding: 0;
      cursor: pointer;
    }
    .button {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 0.8rem;
      padding: 0.28rem 0.6rem;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: #020617;
      color: var(--text);
      cursor: pointer;
      gap: 0.3rem;
      transition: all 0.12s ease;
    }
    .button.primary {
      background: linear-gradient(135deg, #2563eb, #4f46e5);
      border-color: transparent;
      color: white;
    }
    .button.small { font-size: 0.75rem; padding: 0.18rem 0.5rem; }
    .button.danger {
      border-color: rgba(248, 113, 113, 0.8);
      color: #fecaca;
    }
    .button.icon { padding: 0.15rem 0.35rem; }
    .button:hover {
      border-color: var(--accent);
      background: #020617;
    }
    .button.primary:hover {
      box-shadow: 0 10px 25px rgba(37, 99, 235, 0.6);
      transform: translateY(-1px);
    }
    .button.danger:hover { background: rgba(185, 28, 28, 0.45); }
    .row {
      display: flex;
      gap: 0.4rem;
      margin-bottom: 0.4rem;
    }
    .row > * { flex: 1; }
    .hint {
      font-size: 0.72rem;
      color: var(--muted);
      line-height: 1.4;
      margin-top: 0.25rem;
    }
    #canvasContainer {
      flex: 1;
      min-height: 0;
      border-radius: 0.7rem;
      border: 1px solid var(--border);
      background: radial-gradient(circle at center, #020617 0, #020617 60%);
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }
    #maskCanvas {
      border-radius: 0.6rem;
      box-shadow: 0 14px 35px rgba(0, 0, 0, 0.75);
      position: absolute;
      top: 0;
      left: 0;
    }
    #overlayCanvas {
      position: absolute;
      top: 0;
      left: 0;
      pointer-events: none;
    }
    .empty-state {
      text-align: center;
      color: var(--muted);
      font-size: 0.8rem;
      padding: 1.2rem;
    }
    .status-line { font-size: 0.72rem; color: var(--muted); margin-top: 0.3rem; }
    #labelList {
      display: flex;
      flex-direction: column;
      gap: 0.3rem;
      margin-top: 0.3rem;
    }
    .label-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0.25rem 0.4rem;
      background: rgba(15, 23, 42, 0.95);
      border-radius: 0.5rem;
      border: 1px solid transparent;
      cursor: pointer;
      gap: 0.4rem;
      transition: all 0.12s ease;
    }
    .label-item:hover { border-color: var(--border); }
    .label-item.active {
      border-color: var(--accent);
      box-shadow: 0 0 0 1px var(--accent-soft);
      background: radial-gradient(circle at top, var(--accent-soft), #020617);
    }
    .label-color-dot {
      width: 14px;
      height: 14px;
      border-radius: 999px;
      border: 1px solid #020617;
      flex-shrink: 0;
    }
    .label-main { flex: 1; min-width: 0; }
    .label-main div:first-child {
      font-size: 0.8rem;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .label-main div:last-child {
      font-size: 0.7rem;
      color: var(--muted);
    }
    .badge {
      font-size: 0.7rem;
      padding: 0.05rem 0.35rem;
      border-radius: 999px;
      border: 1px solid #475569;
      color: var(--muted);
    }
    footer {
      padding: 0.3rem 0.8rem;
      font-size: 0.72rem;
      color: var(--muted);
      border-top: 1px solid var(--border);
      background: rgba(15, 23, 42, 0.96);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
  </style>
</head>
<body>
  <header>
    <div>
      <h1>Root ROI Map Annotator v6</h1>
      <span>Template (PNG / JPG / SVG) → high-res segmentation → vector ROIs + labels</span>
    </div>
    <div class="pill">
      <span>Click: label / clear</span>
      <span>Box: batch label / clear</span>
      <span>Move: drag canvas</span>
      <span>Wheel: zoom at mouse</span>
    </div>
  </header>

  <main>
    <aside class="panel">
      <div class="panel-header">
        <div class="panel-title">Input & Files</div>
      </div>
      <div class="panel-body">
        <div class="section">
          <div class="section-title">1. Root template image</div>
          <label for="maskFileInput">SVG / PNG / JPEG (black outlines + white background)</label>
          <input type="file" id="maskFileInput" accept=".png,.jpg,.jpeg,.svg,image/png,image/jpeg,image/svg+xml" />
          <div class="hint">
            All formats are rendered at high resolution, segmented, then converted to clean vector ROIs.<br/>
            Large background regions are removed automatically.
          </div>
          <div id="maskInfo" class="status-line"></div>
        </div>

        <div class="section">
          <div class="section-title">2. Import / Export</div>
          <div class="row">
            <button class="button small primary" id="exportJsonBtn">Export full project (JSON)</button>
            <button class="button small" id="exportPngBtn">Export map (PNG)</button>
          </div>
          <label for="annotationFileInput">Import project JSON</label>
          <input type="file" id="annotationFileInput" accept="application/json,.json" />
          <div class="hint">
            JSON stores polygons, centroids, labels, and assignments (no raw image needed).
          </div>
        </div>

        <div class="section">
          <div class="section-title">3. Interaction mode</div>
          <div class="row">
            <button class="button small primary" id="modeClickBtn">Click mode</button>
            <button class="button small" id="modeBoxBtn">Box mode</button>
            <button class="button small" id="modeMoveBtn">Move mode</button>
          </div>
          <div id="modeStatus" class="status-line"></div>
        </div>
      </div>
    </aside>

    <section class="panel">
      <div class="panel-header">
        <div>
          <div class="panel-title">Vector ROI Map View</div>
          <div class="panel-subtitle">
            Each ROI is an independent shape with white (or tinted) interior and fixed-width black border.
          </div>
        </div>
        <div id="hoverInfo" class="pill">No image loaded</div>
      </div>
      <div id="canvasContainer">
        <canvas id="maskCanvas"></canvas>
        <canvas id="overlayCanvas"></canvas>
        <div id="emptyState" class="empty-state">
          Upload a root template image (SVG recommended).<br/><br/>
          Closed white regions will become ROIs; the largest background region is ignored.
        </div>
      </div>
    </section>

    <aside class="panel">
      <div class="panel-header">
        <div class="panel-title">Labels & Stats</div>
        <button class="button small danger" id="clearAllBtn">Clear labels</button>
      </div>
      <div class="panel-body">
        <div class="section">
          <div class="section-title">1. Create label</div>
          <label for="labelNameInput">Label name</label>
          <input type="text" id="labelNameInput" placeholder="e.g. Meristem / Cortex / QC" />
          <label for="labelColorInput">Label color (fill tint)</label>
          <input type="color" id="labelColorInput" />
          <button class="button primary" id="addLabelBtn" style="margin-top:0.4rem;width:100%;">Add label</button>
          <div class="hint">
            Active label: click/box → set / overwrite that label on ROIs.<br/>
            No active label: click/box → clear labels.
          </div>
        </div>

        <div class="section">
          <div class="section-title">2. Label list</div>
          <div id="labelList"></div>
          <div id="labelEmptyHint" class="hint">No labels yet. Please create at least one label.</div>
        </div>

        <div class="section">
          <div class="section-title">3. Global stats</div>
          <div id="globalStats" class="hint">No image/project loaded yet.</div>
        </div>
      </div>
    </aside>
  </main>

  <footer>
    <div>Large background regions are ignored; only closed interior regions become ROIs.</div>
    <div id="selectionStatus">No ROI selected</div>
  </footer>

  <script>
    const maskCanvas = document.getElementById("maskCanvas");
    const overlayCanvas = document.getElementById("overlayCanvas");
    const ctx = maskCanvas.getContext("2d");
    const overlayCtx = overlayCanvas.getContext("2d");
    const canvasContainer = document.getElementById("canvasContainer");
    const emptyState = document.getElementById("emptyState");

    const maskFileInput = document.getElementById("maskFileInput");
    const annotationFileInput = document.getElementById("annotationFileInput");
    const maskInfo = document.getElementById("maskInfo");
    const hoverInfo = document.getElementById("hoverInfo");
    const globalStats = document.getElementById("globalStats");
    const selectionStatus = document.getElementById("selectionStatus");
    const modeStatus = document.getElementById("modeStatus");

    const modeClickBtn = document.getElementById("modeClickBtn");
    const modeBoxBtn = document.getElementById("modeBoxBtn");
    const modeMoveBtn = document.getElementById("modeMoveBtn");

    const addLabelBtn = document.getElementById("addLabelBtn");
    const labelNameInput = document.getElementById("labelNameInput");
    const labelColorInput = document.getElementById("labelColorInput");
    const labelListEl = document.getElementById("labelList");
    const labelEmptyHint = document.getElementById("labelEmptyHint");
    const clearAllBtn = document.getElementById("clearAllBtn");

    const exportJsonBtn = document.getElementById("exportJsonBtn");
    const exportPngBtn = document.getElementById("exportPngBtn");

    let imgWidth = 0, imgHeight = 0, maskLoaded = false;
    let roiPolygons = {}, roiCentroids = {}, roiCount = 0;
    let labels = [], activeLabelId = null, roiAssignments = {};

    const defaultColors = ["#ef4444","#f97316","#facc15","#22c55e","#14b8a6",
      "#0ea5e9","#6366f1","#8b5cf6","#ec4899","#f97373"];
    let colorIndex = 0;

    let interactionMode = "click";
    let isDragging = false;
    let dragStart = null, dragCurrent = null;

    let baseScale = 1, viewScale = 1;
    const minScale = 0.3, maxScale = 5;
    let panX = 0, panY = 0;
    let isPanning = false, panStartClientX = 0, panStartClientY = 0, panStartX = 0, panStartY = 0;

    let hoveredRoiId = 0;
    let hoverScaleCurrent = 1.0, hoverScaleTarget = 1.0;
    const hoverScaleMax = 1.06, hoverAnimSpeed = 8.0;

    const idCanvas = document.createElement("canvas");
    const idCtx = idCanvas.getContext("2d", { willReadFrequently: true });

    function hexToRgb(hex) {
      hex = hex.replace("#","");
      if (hex.length===3) hex = hex.split("").map(c=>c+c).join("");
      const num = parseInt(hex,16);
      return { r:(num>>16)&255, g:(num>>8)&255, b:num&255 };
    }
    function getNextColor(){ const c = defaultColors[colorIndex%defaultColors.length]; colorIndex++; return c; }
    function encodeIdToColor(id){ const r=id&255,g=(id>>8)&255,b=(id>>16)&255; return `rgb(${r},${g},${b})`; }
    function decodeColorToId(r,g,b){ return r + (g<<8) + (b<<16); }

    function setMaskInfo(t){ maskInfo.textContent = t || ""; }
    function setInteractionMode(mode){
      interactionMode = mode;
      modeClickBtn.classList.toggle("primary", mode==="click");
      modeBoxBtn.classList.toggle("primary", mode==="box");
      modeMoveBtn.classList.toggle("primary", mode==="move");
      if (mode==="click")
        modeStatus.innerHTML = "Mode: <strong>Click</strong>. Active label → set/overwrite. No label → clear.";
      else if (mode==="box")
        modeStatus.innerHTML = "Mode: <strong>Box</strong>. Drag rectangle to affect many ROIs.";
      else
        modeStatus.innerHTML = "Mode: <strong>Move</strong>. Drag canvas, wheel zoom at mouse.";
    }
    function updateGlobalStats(){
      if (!maskLoaded || roiCount===0){
        globalStats.textContent = "No image/project loaded yet.";
        return;
      }
      const total = roiCount;
      const labeledSet = new Set(Object.keys(roiAssignments).filter(k=>roiAssignments[k]).map(k=>+k));
      const labeled = labeledSet.size;
      globalStats.innerHTML = `Total ROIs: <strong>${total}</strong><br/>Labeled ROIs: <strong>${labeled}</strong> (${total?(labeled/total*100).toFixed(1):0}%)`;
    }
    function updateSelectionStatus(t){ selectionStatus.textContent = t || "No ROI selected"; }

    function resizeCanvases(w,h){
      maskCanvas.width = w; maskCanvas.height = h;
      overlayCanvas.width = w; overlayCanvas.height = h;
      idCanvas.width = w; idCanvas.height = h;
      maskCanvas.style.width = w+"px";
      maskCanvas.style.height = h+"px";
      overlayCanvas.style.width = w+"px";
      overlayCanvas.style.height = h+"px";
      computeBaseScale();
      viewScale = 1; panX = 0; panY = 0;
      updateViewTransform();
    }
    function computeBaseScale(){
      const rect = canvasContainer.getBoundingClientRect();
      if (!imgWidth || !imgHeight || !rect.width || !rect.height) return;
      baseScale = Math.min(rect.width/imgWidth, rect.height/imgHeight);
    }
    function updateViewTransform(){
      if (!imgWidth || !imgHeight) return;
      if (!baseScale) computeBaseScale();
      const rect = canvasContainer.getBoundingClientRect();
      const scale = baseScale * viewScale;
      const tx = (rect.width-imgWidth*scale)/2 + panX;
      const ty = (rect.height-imgHeight*scale)/2 + panY;
      const t = `translate(${tx}px,${ty}px) scale(${scale})`;
      maskCanvas.style.transformOrigin = "top left";
      overlayCanvas.style.transformOrigin = "top left";
      maskCanvas.style.transform = t;
      overlayCanvas.style.transform = t;
    }

    function refreshLabelList(){
      labelListEl.innerHTML = "";
      if (!labels.length){ labelEmptyHint.style.display="block"; return;}
      labelEmptyHint.style.display="none";

      const counts = {};
      for (const [roiId,labelId] of Object.entries(roiAssignments)){
        if (!labelId) continue;
        counts[labelId] = (counts[labelId]||0)+1;
      }

      labels.forEach(label=>{
        const item = document.createElement("div");
        item.className = "label-item" + (label.id===activeLabelId?" active":"");
        const dot = document.createElement("div");
        dot.className="label-color-dot";
        dot.style.backgroundColor = label.color;

        const main = document.createElement("div");
        main.className="label-main";
        const nDiv = document.createElement("div");
        nDiv.textContent = label.name || "(Untitled)";
        const mDiv = document.createElement("div");
        mDiv.textContent = `ID: ${label.id} · ROIs: ${counts[label.id]||0}`;
        main.appendChild(nDiv); main.appendChild(mDiv);

        const right = document.createElement("div");
        right.style.display="flex"; right.style.alignItems="center"; right.style.gap="0.25rem";
        const badge = document.createElement("div");
        badge.className="badge";
        badge.textContent="Active";
        if (label.id!==activeLabelId) badge.style.visibility="hidden";
        const delBtn = document.createElement("button");
        delBtn.className="button small icon";
        delBtn.textContent="×";
        delBtn.title="Delete label";
        delBtn.addEventListener("click",e=>{
          e.stopPropagation();
          deleteLabel(label.id);
        });
        right.appendChild(badge); right.appendChild(delBtn);

        item.appendChild(dot); item.appendChild(main); item.appendChild(right);
        item.addEventListener("click",()=>{
          activeLabelId = (activeLabelId===label.id? null : label.id);
          refreshLabelList();
        });
        labelListEl.appendChild(item);
      });
    }

    function deleteLabel(id){
      labels = labels.filter(l=>l.id!==id);
      if (activeLabelId===id) activeLabelId=null;
      for (const [roiId,lid] of Object.entries(roiAssignments)){
        if (lid===id) delete roiAssignments[roiId];
      }
      refreshLabelList();
      updateGlobalStats();
      renderBase(); renderOverlay();
    }

    // --- 过滤大背景 ROI ---
    function filterBackgroundPolygons(){
      if (!roiCount) return;
      const imgArea = imgWidth * imgHeight;
      const newPolys = {}, newCents = {};
      let newId = 1;
      for (let id=1; id<=roiCount; id++){
        const poly = roiPolygons[id];
        const cent = roiCentroids[id];
        if (!poly || poly.length<3 || !cent) continue;
        let minX=Infinity,maxX=-Infinity,minY=Infinity,maxY=-Infinity;
        let area = 0;
        for (let i=0;i<poly.length;i++){
          const [x1,y1]=poly[i];
          const [x2,y2]=poly[(i+1)%poly.length];
          area += x1*y2 - x2*y1;
          if (x1<minX) minX=x1;
          if (x1>maxX) maxX=x1;
          if (y1<minY) minY=y1;
          if (y1>maxY) maxY=y1;
        }
        area = Math.abs(area/2);
        const bboxW = maxX-minX, bboxH = maxY-minY;
        const bigArea = area > imgArea*0.5;
        const bigBox  = (bboxW > imgWidth*0.8 && bboxH > imgHeight*0.8);
        if (bigArea || bigBox) continue;
        newPolys[newId]=poly;
        newCents[newId]=cent;
        newId++;
      }
      roiPolygons = newPolys;
      roiCentroids = newCents;
      roiCount = newId-1;
    }

    function buildIdCanvas(){
      idCanvas.width = imgWidth;
      idCanvas.height = imgHeight;
      idCtx.clearRect(0,0,imgWidth,imgHeight);
      idCtx.imageSmoothingEnabled = false;
      for (let id=1; id<=roiCount; id++){
        const poly = roiPolygons[id];
        if (!poly || poly.length<3) continue;
        idCtx.beginPath();
        idCtx.moveTo(poly[0][0],poly[0][1]);
        for (let i=1;i<poly.length;i++) idCtx.lineTo(poly[i][0],poly[i][1]);
        idCtx.closePath();
        idCtx.fillStyle = encodeIdToColor(id);
        idCtx.fill();
      }
    }

    function getRoiIdAt(x,y){
      if (!roiCount) return 0;
      const d = idCtx.getImageData(x,y,1,1).data;
      const id = decodeColorToId(d[0],d[1],d[2]);
      return (id>0 && id<=roiCount) ? id : 0;
    }
    function getRoiIdsInRect(x1,y1,x2,y2){
      const minX = Math.max(0,Math.min(x1,x2));
      const maxX = Math.min(imgWidth-1,Math.max(x1,x2));
      const minY = Math.max(0,Math.min(y1,y2));
      const maxY = Math.min(imgHeight-1,Math.max(y1,y2));
      const w = maxX-minX+1, h = maxY-minY+1;
      const data = idCtx.getImageData(minX,minY,w,h).data;
      const s = new Set();
      for (let i=0;i<data.length;i+=4){
        const id = decodeColorToId(data[i],data[i+1],data[i+2]);
        if (id>0 && id<=roiCount) s.add(id);
      }
      return Array.from(s);
    }

    function renderBase(){
      if (!maskLoaded || roiCount===0) return;
      ctx.clearRect(0,0,imgWidth,imgHeight);
      ctx.save();
      ctx.fillStyle="#020617";
      ctx.fillRect(0,0,imgWidth,imgHeight);
      ctx.restore();

      ctx.save();
      ctx.lineJoin="round";
      ctx.lineCap="round";
      ctx.miterLimit=2;

      for (let id=1; id<=roiCount; id++){
        const poly = roiPolygons[id];
        if (!poly || poly.length<3) continue;
        const labelId = roiAssignments[id];
        let fillColor = "#ffffff";
        if (labelId){
          const label = labels.find(l=>l.id===labelId);
          if (label){
            const {r,g,b}=hexToRgb(label.color);
            fillColor=`rgba(${r},${g},${b},0.35)`;
          }
        }
        ctx.beginPath();
        ctx.moveTo(poly[0][0],poly[0][1]);
        for (let i=1;i<poly.length;i++) ctx.lineTo(poly[i][0],poly[i][1]);
        ctx.closePath();
        ctx.fillStyle=fillColor;
        ctx.strokeStyle="#000000";
        ctx.lineWidth=1.2;
        ctx.fill();
        ctx.stroke();
      }
      ctx.restore();
      updateGlobalStats();
      refreshLabelList();
    }

    function renderOverlay(){
      overlayCtx.clearRect(0,0,overlayCanvas.width,overlayCanvas.height);
      if (isDragging && dragStart && dragCurrent && interactionMode==="box"){
        overlayCtx.save();
        overlayCtx.setLineDash([4,3]);
        overlayCtx.lineWidth=1.5;
        overlayCtx.strokeStyle="rgba(96,165,250,0.9)";
        overlayCtx.fillStyle="rgba(37,99,235,0.18)";
        const x=Math.min(dragStart.x,dragCurrent.x);
        const y=Math.min(dragStart.y,dragCurrent.y);
        const w=Math.abs(dragCurrent.x-dragStart.x);
        const h=Math.abs(dragCurrent.y-dragStart.y);
        overlayCtx.fillRect(x,y,w,h);
        overlayCtx.strokeRect(x,y,w,h);
        overlayCtx.restore();
      }
      if (hoveredRoiId>0 && roiPolygons[hoveredRoiId]){
        const poly = roiPolygons[hoveredRoiId];
        const center = roiCentroids[hoveredRoiId];
        if (poly && center){
          const {cx,cy} = center;
          const labelId = roiAssignments[hoveredRoiId];
          let baseColor = labelId ? (labels.find(l=>l.id===labelId)?.color || "#6366f1") : "#94a3b8";
          const {r,g,b}=hexToRgb(baseColor);
          overlayCtx.save();
          overlayCtx.translate(cx,cy);
          overlayCtx.scale(hoverScaleCurrent,hoverScaleCurrent);
          overlayCtx.translate(-cx,-cy);
          overlayCtx.beginPath();
          overlayCtx.moveTo(poly[0][0],poly[0][1]);
          for (let i=1;i<poly.length;i++) overlayCtx.lineTo(poly[i][0],poly[i][1]);
          overlayCtx.closePath();
          overlayCtx.shadowColor="rgba(15,23,42,0.9)";
          overlayCtx.shadowBlur=12;
          overlayCtx.shadowOffsetY=4;
          overlayCtx.fillStyle=`rgba(${Math.min(r+30,255)},${Math.min(g+30,255)},${Math.min(b+30,255)},0.9)`;
          overlayCtx.strokeStyle="rgba(248,250,252,0.95)";
          overlayCtx.lineWidth=1.6;
          overlayCtx.fill();
          overlayCtx.stroke();
          overlayCtx.restore();
        }
      }
    }

    function canvasPixelFromEvent(e){
      const rect = maskCanvas.getBoundingClientRect();
      const scaleX = maskCanvas.width/rect.width;
      const scaleY = maskCanvas.height/rect.height;
      const x = Math.floor((e.clientX-rect.left)*scaleX);
      const y = Math.floor((e.clientY-rect.top)*scaleY);
      if (x<0||y<0||x>=maskCanvas.width||y>=maskCanvas.height) return null;
      return {x,y};
    }

    function applyLabelToRois(ids){
      ids.forEach(id=>{
        if (id<=0) return;
        if (activeLabelId) roiAssignments[id]=activeLabelId;
        else delete roiAssignments[id];
      });
    }
    function applyLabelToSingleRoi(id){
      if (id<=0) return;
      if (activeLabelId) roiAssignments[id]=activeLabelId;
      else delete roiAssignments[id];
    }

    // === 核心：统一的高分辨率分割管线 ===
    function segmentRasterToPolygons(img){
      const maxDim = 3500;  // 提高一点分辨率，边缘更平滑
      const scale = Math.min(maxDim/Math.max(img.width,img.height), 6);
      const segW = Math.round(img.width*scale);
      const segH = Math.round(img.height*scale);

      const segCanvas = document.createElement("canvas");
      segCanvas.width = segW;
      segCanvas.height = segH;
      const segCtx = segCanvas.getContext("2d");
      segCtx.imageSmoothingEnabled = true;
      segCtx.setTransform(scale,0,0,scale,0,0);
      segCtx.drawImage(img,0,0);

      imgWidth = segW; imgHeight = segH;
      resizeCanvases(imgWidth,imgHeight);

      const imageData = segCtx.getImageData(0,0,segW,segH);
      const data = imageData.data;
      const pixels = segW*segH;
      const labelsArr = new Int32Array(pixels);
      const isBoundary = new Uint8Array(pixels);

      for (let i=0;i<pixels;i++){
        const r=data[i*4],g=data[i*4+1],b=data[i*4+2],a=data[i*4+3];
        const bright=(r+g+b)/3;
        if (a>0 && bright<220) isBoundary[i]=1;
      }

      let currentLabel = 0;
      const stack=[];
      function pushIfValid(idx){
        if (idx<0||idx>=pixels) return;
        if (isBoundary[idx]) return;
        if (labelsArr[idx]!==0) return;
        labelsArr[idx]=currentLabel;
        stack.push(idx);
      }
      for (let i=0;i<pixels;i++){
        if (isBoundary[i] || labelsArr[i]!==0) continue;
        currentLabel++;
        labelsArr[i]=currentLabel;
        stack.length=0;
        stack.push(i);
        while (stack.length){
          const idx=stack.pop();
          const x=idx%segW, y=(idx/segW)|0;
          if (x>0) pushIfValid(idx-1);
          if (x<segW-1) pushIfValid(idx+1);
          if (y>0) pushIfValid(idx-segW);
          if (y<segH-1) pushIfValid(idx+segW);
        }
      }

      const areas = new Array(currentLabel+1).fill(0);
      for (let i=0;i<pixels;i++){
        const l=labelsArr[i]; if (l>0) areas[l]++;
      }
      let largestLabel=0, largestArea=0;
      for (let l=1;l<=currentLabel;l++){
        if (areas[l]>largestArea){largestArea=areas[l];largestLabel=l;}
      }

      const labelMap=new Int32Array(currentLabel+1);
      let newId=1;
      for (let l=1;l<=currentLabel;l++){
        labelMap[l]=(l===largestLabel)?0:newId++;
      }

      const roiPixelMap={};
      for (let i=0;i<pixels;i++){
        const nl=labelMap[labelsArr[i]];
        if (nl>0){
          const x=i%segW, y=(i/segW)|0;
          if (!roiPixelMap[nl]) roiPixelMap[nl]=[];
          roiPixelMap[nl].push({x,y});
        }
      }

      roiPolygons={}; roiCentroids={}; roiCount=newId-1;

      for (let id=1; id<=roiCount; id++){
        const pix = roiPixelMap[id] || [];
        if (!pix.length) continue;
        const set = new Set(pix.map(p=>p.x+","+p.y));
        const boundary=[];
        for (const p of pix){
          const nb=[(p.x-1)+","+p.y,(p.x+1)+","+p.y,p.x+","+(p.y-1),p.x+","+(p.y+1)];
          let isB=false;
          for (const s of nb){ if (!set.has(s)){isB=true;break;} }
          if (isB) boundary.push(p);
        }
        if (!boundary.length) continue;
        let sx=0,sy=0;
        boundary.forEach(p=>{sx+=p.x;sy+=p.y;});
        const cx=sx/boundary.length, cy=sy/boundary.length;
        boundary.sort((a,b)=>{
          const ta=Math.atan2(a.y-cy,a.x-cx);
          const tb=Math.atan2(b.y-cy,b.x-cx);
          return ta-tb;
        });
        const step=Math.max(1,Math.floor(boundary.length/1200));
        const poly=[];
        for (let i=0;i<boundary.length;i+=step){
          poly.push([boundary[i].x+0.5,boundary[i].y+0.5]);
        }
        roiPolygons[id]=poly;
        roiCentroids[id]={cx,cy};
      }

      filterBackgroundPolygons();
      buildIdCanvas();
      renderBase();
      renderOverlay();
      maskLoaded=true;
      emptyState.style.display="none";
      hoverInfo.textContent=`Template segmented · ROIs: ${roiCount}`;
      setMaskInfo(`High-res segmentation ${segW}×${segH}, ROIs: ${roiCount} (background filtered).`);
      updateSelectionStatus("No ROI selected");
    }

    // --- 文件载入：统一走 Image + segmentRasterToPolygons ---
    maskFileInput.addEventListener("change",e=>{
      const file=e.target.files[0];
      if (!file) return;
      const url = URL.createObjectURL(file);
      const img = new Image();
      img.onload = ()=>{
        segmentRasterToPolygons(img);
        URL.revokeObjectURL(url);
      };
      img.onerror = ()=>{
        URL.revokeObjectURL(url);
        alert("Failed to load image. Please use SVG / PNG / JPEG with black outlines and white background.");
      };
      img.src = url;
    });

    // --- JSON 导入 / 导出 ---
    annotationFileInput.addEventListener("change",e=>{
      const file=e.target.files[0];
      if (!file) return;
      const reader=new FileReader();
      reader.onload = ev=>{
        try{
          const json = JSON.parse(ev.target.result);
          if (!json.roiPolygons || !json.roiCentroids){
            alert("JSON does not contain vector ROI data.");
            return;
          }
          imgWidth=json.imgWidth; imgHeight=json.imgHeight;
          roiPolygons=json.roiPolygons;
          roiCentroids=json.roiCentroids;
          roiCount=json.roiCount || Object.keys(roiPolygons).length;
          labels=json.labels || [];
          roiAssignments=json.roiAssignments || {};
          activeLabelId = labels.length? labels[0].id : null;
          resizeCanvases(imgWidth,imgHeight);
          buildIdCanvas();
          renderBase(); renderOverlay();
          maskLoaded=true;
          emptyState.style.display="none";
          hoverInfo.textContent=`Project loaded · ROIs: ${roiCount}`;
          setMaskInfo("Project JSON loaded.");
          updateSelectionStatus("No ROI selected");
        }catch(err){
          console.error(err);
          alert("Failed to parse JSON.");
        }
      };
      reader.readAsText(file);
    });

    exportJsonBtn.addEventListener("click",()=>{
      if (!maskLoaded || roiCount===0){alert("Please load a template image or project first.");return;}
      const obj={
        version: 6,
        imgWidth,imgHeight,roiCount,
        roiPolygons,roiCentroids,
        labels,roiAssignments,
        timestamp:new Date().toISOString()
      };
      const blob=new Blob([JSON.stringify(obj,null,2)],{type:"application/json"});
      const url=URL.createObjectURL(blob);
      const a=document.createElement("a");
      a.href=url; a.download="root_roi_project.json";
      document.body.appendChild(a); a.click(); document.body.removeChild(a);
      URL.revokeObjectURL(url);
    });

    exportPngBtn.addEventListener("click",()=>{
      if (!maskLoaded || roiCount===0){alert("Please load a template image or project first.");return;}
      maskCanvas.toBlob(blob=>{
        const url=URL.createObjectURL(blob);
        const a=document.createElement("a");
        a.href=url; a.download="root_roi_vector_map.png";
        document.body.appendChild(a); a.click(); document.body.removeChild(a);
        URL.revokeObjectURL(url);
      },"image/png",1.0);
    });

    // --- label 操作 ---
    addLabelBtn.addEventListener("click",()=>{
      const name=labelNameInput.value.trim();
      const color=labelColorInput.value || getNextColor();
      const id="L"+(labels.length+1);
      labels.push({id,name: name||`Label ${labels.length+1}`,color});
      activeLabelId=id;
      refreshLabelList();
      labelNameInput.value="";
      labelColorInput.value=getNextColor();
      renderBase(); renderOverlay();
    });

    clearAllBtn.addEventListener("click",()=>{
      labels=[]; roiAssignments={}; activeLabelId=null;
      refreshLabelList(); updateGlobalStats();
      renderBase(); renderOverlay();
    });

    // --- 模式切换 ---
    modeClickBtn.addEventListener("click",()=>setInteractionMode("click"));
    modeBoxBtn.addEventListener("click",()=>setInteractionMode("box"));
    modeMoveBtn.addEventListener("click",()=>setInteractionMode("move"));

    // --- 缩放 / 平移 ---
    canvasContainer.addEventListener("wheel",e=>{
      if (!maskLoaded) return;
      e.preventDefault();
      const rect=canvasContainer.getBoundingClientRect();
      const mouseX=e.clientX-rect.left;
      const mouseY=e.clientY-rect.top;
      const oldScale=baseScale*viewScale;
      const factor=e.deltaY>0?0.9:1.1;
      let newViewScale=viewScale*factor;
      newViewScale=Math.max(minScale,Math.min(maxScale,newViewScale));
      const newScale=baseScale*newViewScale;
      const tx=(rect.width-imgWidth*oldScale)/2+panX;
      const ty=(rect.height-imgHeight*oldScale)/2+panY;
      const imgX=(mouseX-tx)/oldScale;
      const imgY=(mouseY-ty)/oldScale;
      const newTx=mouseX-imgX*newScale;
      const newTy=mouseY-imgY*newScale;
      panX=newTx-(rect.width-imgWidth*newScale)/2;
      panY=newTy-(rect.height-imgHeight*newScale)/2;
      viewScale=newViewScale;
      updateViewTransform();
    },{passive:false});

    canvasContainer.addEventListener("mousedown",e=>{
      if (!maskLoaded) return;
      if (e.button!==0) return;
      if (interactionMode!=="move") return;
      isPanning=true;
      panStartClientX=e.clientX;
      panStartClientY=e.clientY;
      panStartX=panX; panStartY=panY;
    });
    window.addEventListener("mousemove",e=>{
      if (isPanning){
        const dx=e.clientX-panStartClientX;
        const dy=e.clientY-panStartClientY;
        panX=panStartX+dx;
        panY=panStartY+dy;
        updateViewTransform();
      }
    });
    window.addEventListener("mouseup",e=>{
      if (isPanning && e.button===0) isPanning=false;
    });

    // --- click / box / hover ---
    maskCanvas.addEventListener("mousemove",e=>{
      if (!maskLoaded || roiCount===0) return;
      const p=canvasPixelFromEvent(e);
      if (!p) return;
      const id=getRoiIdAt(p.x,p.y);
      if (id===0){
        hoverInfo.textContent=`Pos: (${p.x}, ${p.y}) · Background`;
      }else{
        const labelId=roiAssignments[id];
        const labelName=labelId?(labels.find(l=>l.id===labelId)?.name||labelId):"Unlabeled";
        hoverInfo.textContent=`Pos: (${p.x}, ${p.y}) · ROI ID: ${id} · Label: ${labelName}`;
      }
      if (id!==hoveredRoiId){
        hoveredRoiId=id;
        hoverScaleTarget = id>0 ? hoverScaleMax : 1.0;
      }
      if (interactionMode==="box" && isDragging && dragStart){
        dragCurrent=p;
      }
      renderOverlay();
    });

    maskCanvas.addEventListener("mouseleave",()=>{
      if (!maskLoaded) return;
      hoverInfo.textContent="Mouse left ROI view";
      hoveredRoiId=0; hoverScaleTarget=1.0;
      if (isDragging && interactionMode==="box"){
        isDragging=false; dragStart=null; dragCurrent=null;
      }
      renderOverlay();
    });

    maskCanvas.addEventListener("mousedown",e=>{
      if (!maskLoaded || roiCount===0) return;
      if (e.button!==0) return;
      const p=canvasPixelFromEvent(e);
      if (!p) return;
      if (interactionMode==="click"){
        const id=getRoiIdAt(p.x,p.y);
        if (id===0){
          updateSelectionStatus("Clicked background (no ROI).");
        }else{
          applyLabelToSingleRoi(id);
          renderBase(); renderOverlay();
          const cur=roiAssignments[id];
          updateSelectionStatus(cur ? `ROI ${id} set to label ${cur}.` : `ROI ${id} cleared.`);
        }
      }else if (interactionMode==="box"){
        isDragging=true; dragStart=p; dragCurrent=p;
        renderOverlay();
      }
    });

    maskCanvas.addEventListener("mouseup",e=>{
      if (e.button!==0) return;
      if (!maskLoaded || roiCount===0) return;
      if (interactionMode!=="box" || !isDragging || !dragStart) return;
      const p=canvasPixelFromEvent(e);
      if (!p){
        isDragging=false; dragStart=null; dragCurrent=null;
        renderOverlay(); return;
      }
      dragCurrent=p;
      const ids=getRoiIdsInRect(dragStart.x,dragStart.y,dragCurrent.x,dragCurrent.y);
      applyLabelToRois(ids);
      isDragging=false; dragStart=null; dragCurrent=null;
      renderBase(); renderOverlay();
      updateSelectionStatus(ids.length?`Box selection affected ${ids.length} ROIs.`:"No ROI in box selection.");
    });

    window.addEventListener("resize",()=>{
      if (!maskLoaded) return;
      computeBaseScale(); updateViewTransform();
    });

    function hoverAnimLoop(){
      const dt=1/60;
      const diff=hoverScaleTarget-hoverScaleCurrent;
      hoverScaleCurrent += diff*Math.min(1,hoverAnimSpeed*dt);
      if (Math.abs(diff)<0.001) hoverScaleCurrent=hoverScaleTarget;
      renderOverlay();
      requestAnimationFrame(hoverAnimLoop);
    }

    (function init(){
      setInteractionMode("click");
      updateGlobalStats();
      refreshLabelList();
      labelColorInput.value=getNextColor();
      hoverAnimLoop();
    })();
  </script>
</body>
</html>
