<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Root SVG Map Labeler</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    :root {
      --bg: #0c1320;
      --panel: #0f172a;
      --panel2: #111827;
      --border: #1f2937;
      --accent: #3b82f6;
      --accent-soft: rgba(59, 130, 246, 0.16);
      --text: #e5e7eb;
      --muted: #9ca3af;
      --danger: #f97373;
    }
    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: radial-gradient(circle at top, #161c2a 0, #0c1320 55%);
      color: var(--text);
      height: 100vh;
      display: flex;
      flex-direction: column;
    }

    header {
      padding: 0.6rem 1rem;
      border-bottom: 1px solid var(--border);
      background: rgba(15, 23, 42, 0.95);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    header h1 {
      margin: 0;
      font-size: 1rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: #93c5fd;
    }
    header span {
      font-size: 0.8rem;
      color: var(--muted);
    }

    .pill {
      font-size: 0.75rem;
      padding: 0.2rem 0.6rem;
      border-radius: 999px;
      border: 1px solid var(--border);
      color: var(--muted);
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
      background: rgba(15, 23, 42, 0.85);
    }

    main {
      flex: 1;
      display: grid;
      grid-template-columns: 260px minmax(0, 1.6fr) 260px;
      gap: 0.6rem;
      padding: 0.6rem;
      min-height: 0;
    }
    @media (max-width: 1024px) {
      main {
        grid-template-columns: minmax(0, 1fr);
        grid-template-rows: auto auto auto;
      }
    }

    .panel {
      background: var(--panel);
      border-radius: 0.75rem;
      border: 1px solid var(--border);
      padding: 0.7rem;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }
    .panel-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 0.5rem;
    }
    .panel-title {
      font-size: 0.85rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--muted);
    }
    .panel-subtitle {
      font-size: 0.75rem;
      color: var(--muted);
    }
    .panel-body {
      flex: 1;
      overflow: auto;
      padding-right: 0.3rem;
    }

    .section {
      margin-bottom: 0.8rem;
      padding-bottom: 0.6rem;
      border-bottom: 1px dashed #1f2937;
    }
    .section:last-child {
      border-bottom: none;
      margin-bottom: 0;
      padding-bottom: 0;
    }
    .section-title {
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: var(--muted);
      margin-bottom: 0.3rem;
    }

    label {
      display: block;
      font-size: 0.8rem;
      color: var(--muted);
      margin-bottom: 0.2rem;
    }

    .data-status {
      background: rgba(59, 130, 246, 0.06);
      border: 1px solid rgba(59, 130, 246, 0.25);
      padding: 0.5rem;
      border-radius: 0.6rem;
      font-size: 0.78rem;
      color: #c7d2fe;
      line-height: 1.4;
    }
    .data-status strong { color: #bfdbfe; }
    .data-actions { display: flex; gap: 0.4rem; flex-wrap: wrap; margin-top: 0.4rem; }

    input[type="file"],
    input[type="text"] {
      width: 100%;
      font-size: 0.8rem;
      padding: 0.3rem 0.4rem;
      border-radius: 0.45rem;
      border: 1px solid var(--border);
      background: var(--panel2);
      color: var(--text);
      outline: none;
    }
    input[type="file"] { padding: 0.2rem 0.3rem; }
    input[type="text"]:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 1px var(--accent-soft);
    }
    input[type="color"] {
      width: 100%;
      height: 1.8rem;
      border-radius: 0.4rem;
      border: 1px solid var(--border);
      background: transparent;
      padding: 0;
      cursor: pointer;
    }

    .button {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 0.8rem;
      padding: 0.28rem 0.6rem;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: #0c1320;
      color: var(--text);
      cursor: pointer;
      gap: 0.3rem;
      transition: all 0.12s ease;
    }
    .button.small { font-size: 0.75rem; padding: 0.18rem 0.5rem; }
    .button.primary {
      background: linear-gradient(135deg, #2563eb, #4f46e5);
      border-color: transparent;
      color: white;
    }
    .button.danger {
      border-color: rgba(248, 113, 113, 0.8);
      color: #fecaca;
    }
    .button:hover {
      border-color: var(--accent);
      background: #020617;
    }
    .button.primary:hover {
      box-shadow: 0 10px 25px rgba(37, 99, 235, 0.6);
      transform: translateY(-1px);
    }
    .button.danger:hover {
      background: rgba(185, 28, 28, 0.45);
    }
    .button.mode-active {
      border-color: var(--accent);
      background: rgba(37,99,235,0.18);
      color: #bfdbfe;
    }

    .row {
      display: flex;
      gap: 0.4rem;
      margin-bottom: 0.4rem;
    }
    .row > * { flex: 1; }

    .hint {
      font-size: 0.72rem;
      color: var(--muted);
      line-height: 1.4;
      margin-top: 0.25rem;
    }

    /* SVG 视区 */
    #svgViewport {
      flex: 1;
      min-height: 0;
      border-radius: 0.7rem;
      border: 1px solid var(--border);
      background: #0f1724;
      position: relative;
      overflow: hidden;
      display: flex;
      align-items: flex-start;
      justify-content: flex-start;
      padding: 0;
      cursor: grab;
    }
    #svgViewport.grabbing {
      cursor: grabbing;
    }

    #svgContainer {
      position: relative;
      display: inline-block;
      transform-origin: top left;
    }
    #svgContainer svg {
      display: block;
      background: #0f1724;
    }

    #boxOverlay {
      position: absolute;
      border: 1px dashed rgba(96,165,250,0.9);
      background: rgba(37,99,235,0.18);
      pointer-events: none;
      display: none;
      z-index: 5;
    }

    .empty-state {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      color: var(--muted);
      font-size: 0.8rem;
      padding: 1.2rem;
    }

    .status-line { font-size: 0.72rem; color: var(--muted); margin-top: 0.3rem; }

    /* Label list */
    #labelList {
      display: flex;
      flex-direction: column;
      gap: 0.3rem;
      margin-top: 0.3rem;
    }
    .label-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0.25rem 0.4rem;
      background: rgba(15, 23, 42, 0.95);
      border-radius: 0.5rem;
      border: 1px solid transparent;
      cursor: pointer;
      gap: 0.4rem;
      transition: all 0.12s ease;
    }
    .label-item:hover { border-color: var(--border); }
    .label-item.active {
      border-color: var(--accent);
      box-shadow: 0 0 0 1px var(--accent-soft);
      background: radial-gradient(circle at top, var(--accent-soft), #020617);
    }
    .label-color-dot {
      width: 14px;
      height: 14px;
      border-radius: 999px;
      border: 1px solid #020617;
      flex-shrink: 0;
    }
    .label-main { flex: 1; min-width: 0; }
    .label-main div:first-child {
      font-size: 0.8rem;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .label-main div:last-child {
      font-size: 0.7rem;
      color: var(--muted);
    }
    .badge {
      font-size: 0.7rem;
      padding: 0.05rem 0.35rem;
      border-radius: 999px;
      border: 1px solid #475569;
      color: var(--muted);
    }

    footer {
      padding: 0.3rem 0.8rem;
      font-size: 0.72rem;
      color: var(--muted);
      border-top: 1px solid var(--border);
      background: rgba(15, 23, 42, 0.96);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    /* ROI：更深灰底色；hover 变白/淡色 + 粗线 + 强光晕 */
    .roi-shape {
      cursor: pointer;
      transition: fill 0.12s ease-out, filter 0.12s ease-out, stroke-width 0.12s ease-out;
      vector-effect: non-scaling-stroke;
    }
    .roi-hover {
      filter: drop-shadow(0 0 7px rgba(148, 163, 184, 0.98));
    }
  </style>
</head>
<body>
<header>
  <div>
    <h1>Root SVG Map Labeler</h1>
    <span>Directly use the root SVG as a high-resolution map and add labels.</span>
  </div>
  <div class="pill">
    <span>Wheel: zoom at mouse</span>
    <span>Label mode: click or drag box to label ROIs</span>
    <span>Move mode: drag to pan</span>
  </div>
</header>

<main>
  <!-- 左侧：项目 & 导入导出 -->
  <aside class="panel">
    <div class="panel-header">
      <div class="panel-title">Map & Project</div>
    </div>
    <div class="panel-body">
      <div class="section">
        <div class="section-title">1. Root map (SVG)</div>
        <div class="hint">
          This page always uses <strong>Vector image_ blank root.svg</strong> in the same folder.<br/>
          The SVG geometry is never changed; only labels are added on top.
        </div>
        <div id="mapInfo" class="status-line"></div>
      </div>

      <div class="section">
        <div class="section-title">2. Import / Export labels</div>
        <div class="row">
          <button class="button small primary" id="exportJsonBtn">Export labels (JSON)</button>
          <button class="button small" id="clearAssignmentsBtn">Clear ROI labels</button>
        </div>
        <label for="labelsFileInput">Import labels JSON</label>
        <input type="file" id="labelsFileInput" accept="application/json,.json" />
        <div class="hint">
          JSON contains: label definitions + ROI assignments.<br/>
          SVG file is assumed to be the same root map.
        </div>
      </div>

      <div class="section">
        <div class="section-title">3. Global stats</div>
        <div id="globalStats" class="hint">SVG not loaded yet.</div>
      </div>

      <div class="section">
        <div class="section-title">4. Data table & Analysis</div>
        <label for="dataFileInput">Load per-cell table (CSV/TSV)</label>
        <input type="file" id="dataFileInput" accept=".csv,.tsv,text/csv,text/tab-separated-values" />
        <div class="hint">
          Each row is one ROI with metadata and unlimited indices.<br/>
          Required columns: <strong>roi_id</strong>, <strong>label</strong>, <strong>z_position</strong>.<br/>
          Optional metadata: zone, layer, treatment, batch, x, y.
        </div>
        <div class="data-actions">
          <button class="button small" id="downloadTemplateBtn">Download template from labels</button>
          <button class="button small primary" id="openAnalysisBtn">Open analysis workspace</button>
        </div>
        <div id="dataStatus" class="data-status" style="margin-top:0.4rem;">No data table loaded.</div>
      </div>
    </div>
  </aside>

  <!-- 中间：SVG 视图区 -->
  <section class="panel">
    <div class="panel-header">
      <div>
        <div class="panel-title">Root map view (SVG)</div>
        <div class="panel-subtitle">
          Each cell contour is a vector ROI path. Only fills are changed; strokes remain crisp and uniform.
        </div>
        <div style="margin-top:0.35rem; display:flex; gap:0.3rem;">
          <button class="button small mode-active" id="modeLabelBtn">Label</button>
          <button class="button small" id="modeMoveBtn">Move</button>
        </div>
      </div>
      <div id="hoverInfo" class="pill">Loading SVG…</div>
    </div>
    <div id="svgViewport">
      <div id="svgContainer">
        <div id="emptyState" class="empty-state">
          Loading <strong>Vector image_ blank root.svg</strong>…
        </div>
      </div>
      <div id="boxOverlay"></div>
    </div>
  </section>

  <!-- 右侧：标签管理 -->
  <aside class="panel">
    <div class="panel-header">
      <div class="panel-title">Labels</div>
      <button class="button small danger" id="clearAllLabelsBtn">Delete all labels</button>
    </div>
    <div class="panel-body">
      <div class="section">
        <div class="section-title">1. Create label</div>
        <label for="labelNameInput">Label name</label>
        <input type="text" id="labelNameInput" placeholder="e.g. Meristem / Cortex / QC" />
        <label for="labelColorInput">Label color</label>
        <input type="color" id="labelColorInput" />
        <button class="button primary" id="addLabelBtn" style="margin-top:0.4rem;width:100%;">Add label</button>
        <div class="hint">
          Label mode:<br/>
          • Click ROI → toggle this ROI’s label (same as before).<br/>
          • Drag a box → set/overwrite label for all ROIs in the box (no toggle).<br/>
          No active label: click/box clears labels.
        </div>
      </div>

      <div class="section">
        <div class="section-title">2. Label list</div>
        <div id="labelList"></div>
        <div id="labelEmptyHint" class="hint">No labels yet. Please create at least one.</div>
      </div>
    </div>
  </aside>
</main>

<footer>
  <div>SVG geometry stays untouched. Only label fills are stored and exported.</div>
  <div id="selectionStatus">No ROI selected</div>
</footer>

<script>
  // ----------- 基本状态 -----------
  const svgViewport     = document.getElementById("svgViewport");
  const svgContainer    = document.getElementById("svgContainer");
  const boxOverlay      = document.getElementById("boxOverlay");
  const emptyState      = document.getElementById("emptyState");
  const hoverInfo       = document.getElementById("hoverInfo");
  const mapInfo         = document.getElementById("mapInfo");
  const globalStats     = document.getElementById("globalStats");
  const selectionStatus = document.getElementById("selectionStatus");

  const exportJsonBtn       = document.getElementById("exportJsonBtn");
  const labelsFileInput     = document.getElementById("labelsFileInput");
  const clearAssignmentsBtn = document.getElementById("clearAssignmentsBtn");
  const dataFileInput       = document.getElementById("dataFileInput");
  const downloadTemplateBtn = document.getElementById("downloadTemplateBtn");
  const openAnalysisBtn     = document.getElementById("openAnalysisBtn");
  const dataStatus          = document.getElementById("dataStatus");

  const addLabelBtn       = document.getElementById("addLabelBtn");
  const labelNameInput    = document.getElementById("labelNameInput");
  const labelColorInput   = document.getElementById("labelColorInput");
  const labelListEl       = document.getElementById("labelList");
  const labelEmptyHint    = document.getElementById("labelEmptyHint");
  const clearAllLabelsBtn = document.getElementById("clearAllLabelsBtn");

  const modeLabelBtn = document.getElementById("modeLabelBtn");
  const modeMoveBtn  = document.getElementById("modeMoveBtn");

  const defaultColors = ["#ef4444","#f97316","#facc15","#22c55e","#14b8a6",
                         "#0ea5e9","#6366f1","#8b5cf6","#ec4899","#f97373"];
  let colorIndex = 0;

  const SVG_FILENAME = "Vector image_ blank root.svg";

  let svgEl = null;
  let svgWidth = 0, svgHeight = 0;
  let baseScale = 1, viewScale = 1;
  let panX = 0, panY = 0;

  // Move 模式拖动
  let isPanning = false;
  let panStartX = 0, panStartY = 0;
  let panStartClientX = 0, panStartClientY = 0;
  let panMoved = false;

  // Label 模式：点击/框选
  let interactionMode = "move"; // "label" | "move"
  let labelMouseDown = false;
  let labelStartClientX = 0, labelStartClientY = 0;
  let labelCurrentClientX = 0, labelCurrentClientY = 0;
  let labelIsBox = false;
  let labelBoxMoved = false;
  let ignoreNextClick = false;

  // ROI & 标签
  let roiElements = [];      // SVG path elements
  let labels = [];           // [{id, name, color}]
  let activeLabelId = null;
  let roiAssignments = {};   // { roiId: labelId }
  let roiBBox = null;        // cached ROI bbox for centering/scale
  let cellTable = [];        // loaded per-cell data rows
  let tableColumns = [];     // detected columns

  function getNextColor(){
    const c = defaultColors[colorIndex % defaultColors.length];
    colorIndex++;
    return c;
  }
  function hexToRgb(hex){
    hex = hex.replace("#","");
    if (hex.length === 3) hex = hex.split("").map(c => c + c).join("");
    const num = parseInt(hex,16);
    return { r:(num>>16)&255, g:(num>>8)&255, b:num&255 };
  }
  function lightenHex(hex, factor=0.35){
    // factor: 0~1, 越大越接近白
    const {r,g,b} = hexToRgb(hex);
    const nr = Math.round(r + (255 - r) * factor);
    const ng = Math.round(g + (255 - g) * factor);
    const nb = Math.round(b + (255 - b) * factor);
    return `rgb(${nr}, ${ng}, ${nb})`;
  }

  function updateGlobalStats(){
    if (!roiElements.length) {
      globalStats.textContent = "SVG not loaded yet.";
      return;
    }
    const total = roiElements.length;
    const labeled = Object.values(roiAssignments).filter(v => !!v).length;
    const pct = total ? (labeled / total * 100).toFixed(1) : 0;
    globalStats.innerHTML = `Total ROIs: <strong>${total}</strong> · Labeled: <strong>${labeled}</strong> (${pct}%)`;
  }
  function updateSelectionStatus(text){
    selectionStatus.textContent = text || "No ROI selected";
  }

  function recomputeRoiBBox(){
    if (!roiElements.length) {
      roiBBox = null;
      return;
    }
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    roiElements.forEach(el => {
      const b = el.getBBox();
      minX = Math.min(minX, b.x);
      minY = Math.min(minY, b.y);
      maxX = Math.max(maxX, b.x + b.width);
      maxY = Math.max(maxY, b.y + b.height);
    });
    roiBBox = {
      minX,
      minY,
      maxX,
      maxY,
      width: maxX - minX,
      height: maxY - minY
    };
  }

  // ---------- 模式切换 ----------
  function setInteractionMode(mode){
    interactionMode = mode;
    modeLabelBtn.classList.toggle("mode-active", mode === "label");
    modeMoveBtn.classList.toggle("mode-active", mode === "move");
  }
  modeLabelBtn.addEventListener("click", () => setInteractionMode("label"));
  modeMoveBtn.addEventListener("click",  () => setInteractionMode("move"));
  setInteractionMode("move");

  // ----------- SVG 缩放 / 平移 -----------
  function computeBaseScale(){
    if (!svgWidth || !svgHeight) return;
    const rect = svgViewport.getBoundingClientRect();
    const contentWidth  = (roiBBox?.width  || svgWidth);
    const contentHeight = (roiBBox?.height || svgHeight);
    const scaleByHeight = rect.height / (contentHeight * 1.2);
    const scaleByWidth  = rect.width  / (contentWidth  * 1.2);
    baseScale = Math.min(scaleByWidth, scaleByHeight);
  }

  function getTransformInfo(scaleOverride = viewScale){
    const rect = svgViewport.getBoundingClientRect();
    const scale = baseScale * scaleOverride;
    const contentMinX = roiBBox ? roiBBox.minX : 0;
    const contentMinY = roiBBox ? roiBBox.minY : 0;
    const contentWidth = roiBBox ? roiBBox.width : svgWidth;
    const contentHeight = roiBBox ? roiBBox.height : svgHeight;
    const cx = contentMinX + contentWidth / 2;
    const cy = contentMinY + contentHeight / 2;
    const baseTx = rect.width / 2 - cx * scale;
    const baseTy = rect.height / 2 - cy * scale;
    return {
      rect,
      scale,
      tx: baseTx + panX,
      ty: baseTy + panY,
      baseTx,
      baseTy
    };
  }
  
  function updateSvgTransform(){
    if (!svgEl) return;
    const { tx, ty, scale } = getTransformInfo();
    svgContainer.style.transformOrigin = "top left";
    svgContainer.style.transform = `translate(${tx}px, ${ty}px) scale(${scale})`;
  }

  function centerOnRoiBBox(){
    if (!roiElements.length || !roiBBox) return;
    // Reset pan so updateSvgTransform can center the ROI bounds itself
    panX = 0;
    panY = 0;
    updateSvgTransform();
  }

  function clientToSvg(clientX, clientY){
    const { rect, scale, tx, ty } = getTransformInfo();
    const x = (clientX - rect.left - tx) / scale;
    const y = (clientY - rect.top - ty) / scale;
    return { x, y };
  }

  svgViewport.addEventListener("wheel", (e) => {
    if (!svgEl) return;
    e.preventDefault();
    const { rect, scale: oldScale, tx: txOld, ty: tyOld, baseTx, baseTy } = getTransformInfo();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;

    const factor = e.deltaY > 0 ? 0.9 : 1.1;
    let newViewScale = viewScale * factor;
    newViewScale = Math.max(0.2, Math.min(6, newViewScale));
    const newInfo = getTransformInfo(newViewScale);
    const imgX = (mouseX - txOld) / oldScale;
    const imgY = (mouseY - tyOld) / oldScale;

    const txNew = mouseX - imgX * newInfo.scale;
    const tyNew = mouseY - imgY * newInfo.scale;

    panX = txNew - newInfo.baseTx;
    panY = tyNew - newInfo.baseTy;
    viewScale = newViewScale;
    updateSvgTransform();
  }, { passive: false });

  svgViewport.addEventListener("mousedown", (e) => {
    if (!svgEl) return;
    if (e.button !== 0) return;

    if (interactionMode === "move") {
      e.preventDefault();
      isPanning = true;
      panMoved = false;
      svgViewport.classList.add("grabbing");
      panStartX = panX;
      panStartY = panY;
      panStartClientX = e.clientX;
      panStartClientY = e.clientY;
    } else {
      labelMouseDown = true;
      labelIsBox = false;
      labelBoxMoved = false;
      labelStartClientX = e.clientX;
      labelStartClientY = e.clientY;
      labelCurrentClientX = e.clientX;
      labelCurrentClientY = e.clientY;
    }
  });

  window.addEventListener("mousemove", (e) => {
    if (isPanning) {
      const dx = e.clientX - panStartClientX;
      const dy = e.clientY - panStartClientY;
      if (Math.abs(dx) > 3 || Math.abs(dy) > 3) panMoved = true;
      panX = panStartX + dx;
      panY = panStartY + dy;
      updateSvgTransform();
    } else if (labelMouseDown) {
      const dx = e.clientX - labelStartClientX;
      const dy = e.clientY - labelStartClientY;
      labelCurrentClientX = e.clientX;
      labelCurrentClientY = e.clientY;
      if (!labelIsBox && (Math.abs(dx) > 3 || Math.abs(dy) > 3)) {
        labelIsBox = true;
        boxOverlay.style.display = "block";
      }
      if (labelIsBox) {
        const rect = svgViewport.getBoundingClientRect();
        const x1 = labelStartClientX - rect.left;
        const y1 = labelStartClientY - rect.top;
        const x2 = labelCurrentClientX - rect.left;
        const y2 = labelCurrentClientY - rect.top;
        const left = Math.min(x1, x2);
        const top  = Math.min(y1, y2);
        const width  = Math.abs(x1 - x2);
        const height = Math.abs(y1 - y2);
        boxOverlay.style.left = left + "px";
        boxOverlay.style.top  = top  + "px";
        boxOverlay.style.width  = width + "px";
        boxOverlay.style.height = height + "px";
        if (width > 3 || height > 3) labelBoxMoved = true;
      }
    }
  });

  window.addEventListener("mouseup", (e) => {
    if (e.button !== 0) return;
    if (isPanning) {
      isPanning = false;
      svgViewport.classList.remove("grabbing");
    }
    if (labelMouseDown) {
      if (labelIsBox && labelBoxMoved) {
        ignoreNextClick = true;
        performBoxSelection();
      }
      labelMouseDown = false;
      labelIsBox = false;
      labelBoxMoved = false;
      boxOverlay.style.display = "none";
    }
  });

  function performBoxSelection(){
    if (!svgEl || !roiElements.length) return;

    const minXClient = Math.min(labelStartClientX, labelCurrentClientX);
    const maxXClient = Math.max(labelStartClientX, labelCurrentClientX);
    const minYClient = Math.min(labelStartClientY, labelCurrentClientY);
    const maxYClient = Math.max(labelStartClientY, labelCurrentClientY);

    const affected = [];
    roiElements.forEach(el => {
      const b = el.getBoundingClientRect();
      const fullyInside = (
        b.left >= minXClient &&
        b.right <= maxXClient &&
        b.top >= minYClient &&
        b.bottom <= maxYClient
      );
      if (fullyInside) affected.push(el);
    });

    affected.forEach(el => {
      const roiId = el.id;
      if (activeLabelId) {
        roiAssignments[roiId] = activeLabelId;
      } else {
        delete roiAssignments[roiId];
      }
    });

    refreshAllRoisAppearance();
    updateGlobalStats();
    updateSelectionStatus(
      affected.length
        ? `Box selection affected ${affected.length} ROIs.`
        : "No ROI in box selection."
    );
  }

  window.addEventListener("resize", () => {
    if (!svgEl) return;
    computeBaseScale();
    centerOnRoiBBox();
  });

  // ----------- SVG 加载 & ROI 初始化 -----------
  async function loadSvgMap(){
    try {
      const resp = await fetch(SVG_FILENAME);
      if (!resp.ok) throw new Error("HTTP " + resp.status);
      const svgText = await resp.text();
      svgContainer.innerHTML = svgText;
      svgEl = svgContainer.querySelector("svg");
      if (!svgEl) {
        emptyState.textContent = "Failed to load SVG: no <svg> root found.";
        hoverInfo.textContent = "SVG load error";
        return;
      }
      emptyState.style.display = "none";

      const vbAttr = svgEl.getAttribute("viewBox");
      if (vbAttr) {
        const parts = vbAttr.split(/[\s,]+/).map(parseFloat);
        svgWidth  = parts[2];
        svgHeight = parts[3];
      } else {
        const bbox = svgEl.getBBox();
        svgWidth  = bbox.width;
        svgHeight = bbox.height;
      }
      svgEl.setAttribute("width", svgWidth);
      svgEl.setAttribute("height", svgHeight);

      mapInfo.textContent =
        `Map file: ${SVG_FILENAME} · viewBox: ${svgEl.getAttribute("viewBox") || "none"} · W×H: ${svgWidth.toFixed(1)} × ${svgHeight.toFixed(1)}`;

      viewScale = 1;
      panX = 0;
      panY = 0;

      setupRoisFromSvg(svgEl);
      computeBaseScale();
      centerOnRoiBBox();

      hoverInfo.textContent = "SVG loaded. Label mode: click or drag box. Move mode: drag to pan.";
    } catch (err) {
      console.error(err);
      emptyState.textContent = "Failed to load SVG file.";
      hoverInfo.textContent = "SVG load error";
    }
  }

  function setupRoisFromSvg(svgEl){
    let paths = svgEl.querySelectorAll("g#layer-MC0 path, g[id^='layer'] path");
    if (!paths.length) {
      paths = svgEl.querySelectorAll("path");
    }

    roiElements = [];
    let autoIdCount = 1;
    paths.forEach(el => {
      const styleAttr = el.getAttribute("style") || "";
      if (styleAttr.includes("stroke:none")) return;

      const baseFill = "#c2c6cf"; // 更灰一点
      el.dataset.baseFill = baseFill;
      el.style.fill = baseFill;
      el.style.stroke = "#000000";
      el.style.strokeWidth = "1.6";
      el.style.strokeLinejoin = "round";
      el.style.strokeLinecap = "round";
      el.style.vectorEffect = "non-scaling-stroke";

      if (!el.id || el.id === "") {
        el.id = "roi_auto_" + autoIdCount++;
      }

      el.classList.add("roi-shape");

      el.addEventListener("mouseenter", () => {
        el.classList.add("roi-hover");
        el.dataset.baseStrokeWidth = el.style.strokeWidth || "1.6";
        const roiId = el.id;
        const labelId = roiAssignments[roiId];
        if (!labelId) {
          el.style.fill = "#ffffff"; // 无标签：保持纯白
        } else {
          const label = labels.find(l => l.id === labelId);
          const c = label ? label.color : "#ffffff";
          el.style.fill = lightenHex(c, 0.5); // 有标签：标签色 -> 淡色
        }
        el.style.strokeWidth = "2.3";

        const currentLabelId = roiAssignments[roiId];
        const labelName = currentLabelId
          ? (labels.find(l => l.id === currentLabelId)?.name || currentLabelId)
          : "Unlabeled";
        hoverInfo.textContent = `ROI: ${roiId} · Label: ${labelName}`;
      });

      el.addEventListener("mouseleave", () => {
        el.classList.remove("roi-hover");
        el.style.strokeWidth = el.dataset.baseStrokeWidth || "1.6";
        updateRoiAppearance(el); // 恢复为标签色或灰色
        hoverInfo.textContent = "Hover a cell to see ROI id and label.";
      });

      el.addEventListener("click", () => {
        if (ignoreNextClick) {
          ignoreNextClick = false;
          return;
        }
        if (interactionMode === "move") {
          return;
        }
        applyLabelLogicForRoi(el.id);
        updateRoiAppearance(el);
        updateGlobalStats();

        const now = roiAssignments[el.id] || null;
        if (now) {
          const ln = labels.find(l => l.id === now)?.name || now;
          updateSelectionStatus(`ROI ${el.id} set to label ${ln}.`);
        } else {
          updateSelectionStatus(`ROI ${el.id} cleared.`);
        }
      });

      roiElements.push(el);
    });

    recomputeRoiBBox();
    updateGlobalStats();
  }

  function applyLabelLogicForRoi(roiId){
    const current = roiAssignments[roiId] || null;
    if (activeLabelId) {
      if (current === activeLabelId) {
        delete roiAssignments[roiId];
      } else {
        roiAssignments[roiId] = activeLabelId;
      }
    } else {
      delete roiAssignments[roiId];
    }
  }

  function updateRoiAppearance(el){
    const roiId = el.id;
    const labelId = roiAssignments[roiId];
    if (!labelId) {
      el.style.fill = el.dataset.baseFill || "#d1d5db";
      el.classList.remove("roi-labeled");
      return;
    }
    const label = labels.find(l => l.id === labelId);
    if (!label) {
      delete roiAssignments[roiId];
      el.style.fill = el.dataset.baseFill || "#d1d5db";
      el.classList.remove("roi-labeled");
      return;
    }
    el.style.fill = label.color;
    el.classList.add("roi-labeled");
  }

  function refreshAllRoisAppearance(){
    roiElements.forEach(updateRoiAppearance);
  }

  // ----------- 标签管理 -----------
  function refreshLabelList(){
    labelListEl.innerHTML = "";
    if (!labels.length) {
      labelEmptyHint.style.display = "block";
    } else {
      labelEmptyHint.style.display = "none";
    }

    const counts = {};
    Object.values(roiAssignments).forEach(id => {
      if (!id) return;
      counts[id] = (counts[id] || 0) + 1;
    });

    labels.forEach(label => {
      const item = document.createElement("div");
      item.className = "label-item" + (label.id === activeLabelId ? " active" : "");
      const dot = document.createElement("div");
      dot.className = "label-color-dot";
      dot.style.backgroundColor = label.color;

      const main = document.createElement("div");
      main.className = "label-main";
      const nDiv = document.createElement("div");
      nDiv.textContent = label.name || "(Untitled)";
      const mDiv = document.createElement("div");
      mDiv.textContent = `ID: ${label.id} · ROIs: ${counts[label.id] || 0}`;
      main.appendChild(nDiv);
      main.appendChild(mDiv);

      const right = document.createElement("div");
      right.style.display = "flex";
      right.style.alignItems = "center";
      right.style.gap = "0.25rem";

      const badge = document.createElement("div");
      badge.className = "badge";
      badge.textContent = "Active";
      if (label.id !== activeLabelId) badge.style.visibility = "hidden";

      const delBtn = document.createElement("button");
      delBtn.className = "button small icon";
      delBtn.textContent = "×";
      delBtn.title = "Delete this label";
      delBtn.addEventListener("click", (ev) => {
        ev.stopPropagation();
        deleteLabel(label.id);
      });

      right.appendChild(badge);
      right.appendChild(delBtn);

      item.appendChild(dot);
      item.appendChild(main);
      item.appendChild(right);

      item.addEventListener("click", () => {
        activeLabelId = (activeLabelId === label.id ? null : label.id);
        refreshLabelList();
      });

      labelListEl.appendChild(item);
    });
  }

  function deleteLabel(id){
    labels = labels.filter(l => l.id !== id);
    if (activeLabelId === id) activeLabelId = null;
    for (const [roiId, labId] of Object.entries(roiAssignments)) {
      if (labId === id) delete roiAssignments[roiId];
    }
    refreshLabelList();
    refreshAllRoisAppearance();
    updateGlobalStats();
  }

  // ----------- 导入 / 导出 -----------
  function exportLabels(){
    if (!roiElements.length) {
      alert("SVG map is not loaded yet.");
      return;
    }
    const obj = {
      version: 4,
      mapFile: SVG_FILENAME,
      labels,
      assignments: roiAssignments,
      timestamp: new Date().toISOString()
    };
    const blob = new Blob([JSON.stringify(obj, null, 2)], {type: "application/json"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "root_svg_labels.json";
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }

  function importLabelsFromObject(obj){
    if (!obj || !obj.labels || !obj.assignments) {
      alert("Invalid JSON: no labels / assignments.");
      return;
    }
    if (obj.mapFile && obj.mapFile !== SVG_FILENAME) {
      const proceed = confirm(
        `JSON was exported for "${obj.mapFile}", but current map is "${SVG_FILENAME}".\n` +
        `Continue to apply labels?`
      );
      if (!proceed) return;
    }
    labels = obj.labels;
    roiAssignments = obj.assignments;
    activeLabelId = labels.length ? labels[0].id : null;
    refreshLabelList();
    refreshAllRoisAppearance();
    updateGlobalStats();
  }

  exportJsonBtn.addEventListener("click", exportLabels);

  labelsFileInput.addEventListener("change", (e) => {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (ev) => {
      try {
        const obj = JSON.parse(ev.target.result);
        importLabelsFromObject(obj);
      } catch (err) {
        console.error(err);
        alert("Failed to parse JSON.");
      }
    };
    reader.readAsText(file);
  });

  clearAssignmentsBtn.addEventListener("click", () => {
    roiAssignments = {};
    refreshAllRoisAppearance();
    updateGlobalStats();
  });

  // ----------- 数据表 & 分析入口 -----------
  function deriveIndexColumns(cols){
    const meta = new Set(["roi_id","label","zone","layer","treatment","batch","z_position","x","y"]);
    return cols.filter(c => !meta.has(c));
  }

  function updateDataStatus(msg, stats=null){
    if (!stats) {
      dataStatus.innerHTML = msg;
      return;
    }
    dataStatus.innerHTML = `
      <div><strong>${msg}</strong></div>
      <div>Rows: ${stats.rows} · Labels: ${stats.labels.join(", ") || "-"}</div>
      <div>Indices: ${stats.indices.length ? stats.indices.join(", ") : "(none detected)"}</div>
      <div>Metadata: ${stats.meta.join(", ") || "(none)"}</div>
    `;
  }

  function detectDelimiter(text){
    if (text.includes("\t") && !text.includes(",\t")) return "\t";
    return ",";
  }

  function parseDataText(text){
    const delimiter = detectDelimiter(text);
    const lines = text.split(/\r?\n/).filter(l => l.trim().length);
    if (!lines.length) throw new Error("Empty file");
    const header = lines.shift().split(delimiter).map(h => h.trim());
    const rows = lines.map(line => {
      const parts = line.split(delimiter);
      const obj = {};
      header.forEach((h, i) => { obj[h] = (parts[i] || "").trim(); });
      return obj;
    });
    return { header, rows, delimiter };
  }

  function coerceRow(row, indexCols){
    const obj = { ...row };
    if (obj.z_position !== undefined) obj.z_position = parseFloat(obj.z_position) || 0;
    ["x","y"].forEach(k => { if (obj[k] !== undefined) obj[k] = parseFloat(obj[k]); });
    indexCols.forEach(c => {
      if (obj[c] !== undefined) obj[c] = parseFloat(obj[c]);
    });
    return obj;
  }

  function loadDataFromFile(file){
    const reader = new FileReader();
    reader.onload = (ev) => {
      try {
        const { header, rows } = parseDataText(ev.target.result);
        tableColumns = header;
        const indices = deriveIndexColumns(header);
        cellTable = rows.map(r => coerceRow(r, indices));
        const labelSet = Array.from(new Set(cellTable.map(r => r.label).filter(Boolean)));
        const metaCols = header.filter(h => !deriveIndexColumns([h]).length && h !== "roi_id" && h !== "label");
        updateDataStatus("Data table loaded", {
          rows: cellTable.length,
          labels: labelSet,
          indices,
          meta: metaCols
        });
      } catch (err) {
        console.error(err);
        updateDataStatus("Failed to parse file: " + err.message);
      }
    };
    reader.readAsText(file);
  }

  function buildTemplateCsv(){
    const headers = ["roi_id","label","zone","layer","treatment","batch","z_position","x","y",
                    "index_density","index_bundling","index_connectivity","index_branching","index_anisotropy"];
    const labelMap = Object.fromEntries(labels.map(l => [l.id, l.name]));
    const rows = roiElements.map(el => {
      const roiId = el.id;
      const labelId = roiAssignments[roiId];
      const labelName = labelId ? (labelMap[labelId] || labelId) : "";
      return [
        roiId,
        labelName,
        "",
        "",
        "",
        "",
        0,
        "",
        "",
        "",
        "",
        "",
        "",
        ""
      ].join(",");
    });
    return headers.join(",") + "\n" + rows.join("\n");
  }

  function downloadTemplateFromLabels(){
    if (!roiElements.length) {
      alert("SVG map not ready. Load map first.");
      return;
    }
    const csv = buildTemplateCsv();
    const blob = new Blob([csv], {type: "text/csv"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "per_cell_template.csv";
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }

  function createAnalysisWindow(){
    if (!cellTable.length) {
      alert("Load a per-cell table first.");
      return;
    }
    const payload = {
      rows: cellTable,
      columns: tableColumns,
      indices: deriveIndexColumns(tableColumns)
    };
    const w = window.open("", "root-analysis" + Date.now());
    if (!w) {
      alert("Pop-up blocked. Please allow pop-ups for this site.");
      return;
    }
    const html = buildAnalysisHtml(payload);
    w.document.open();
    w.document.write(html);
    w.document.close();
  }

  function buildAnalysisHtml(payload){
    const payloadStr = JSON.stringify(payload);
    return `<!DOCTYPE html>
    <html lang="en">
    <head>
      <meta charset="UTF-8" />
      <title>Root multi-parameter analysis</title>
      <style>
        :root {
          --bg: #0b1221;
          --panel: #0f172a;
          --panel2: #111827;
          --border: #1f2937;
          --accent: #60a5fa;
          --text: #e5e7eb;
          --muted: #9ca3af;
        }
        body { margin:0; background: radial-gradient(circle at top, #161c2a 0, #0b1221 60%); color: var(--text); font-family: system-ui, -apple-system, "Segoe UI", sans-serif; min-height:100vh; }
        header { padding:0.8rem 1rem; border-bottom:1px solid var(--border); backdrop-filter: blur(6px); position:sticky; top:0; background:rgba(12,18,32,0.92); z-index:10; }
        h1 { margin:0; font-size:1.1rem; letter-spacing:0.06em; color:#bfdbfe; }
        main { display:grid; grid-template-columns: 320px minmax(0,1.5fr); gap:0.8rem; padding:0.8rem; }
        @media (max-width: 1080px) { main { grid-template-columns: minmax(0,1fr); } }
        .panel { background:var(--panel); border:1px solid var(--border); border-radius:0.75rem; padding:0.8rem; }
        .panel h3 { margin:0 0 0.2rem 0; font-size:0.95rem; letter-spacing:0.04em; color:#cbd5f5; }
        .panel small { color:var(--muted); }
        .pill { display:inline-flex; align-items:center; gap:0.35rem; border:1px solid var(--border); padding:0.18rem 0.55rem; border-radius:999px; font-size:0.78rem; color:var(--muted); background:var(--panel2); }
        .grid { display:grid; grid-template-columns: repeat(auto-fit, minmax(240px,1fr)); gap:0.6rem; }
        .card { border:1px solid var(--border); border-radius:0.65rem; padding:0.6rem; background:var(--panel2); }
        .card h4 { margin:0 0 0.2rem 0; font-size:0.85rem; color:#e5e7eb; }
        .text-muted { color:var(--muted); font-size:0.82rem; }
        .tag { display:inline-block; padding:0.15rem 0.45rem; border-radius:0.45rem; border:1px solid var(--border); font-size:0.75rem; color:#cbd5f5; }
        table { width:100%; border-collapse:collapse; font-size:0.85rem; }
        th, td { padding:0.35rem 0.25rem; text-align:left; border-bottom:1px dashed #1f2937; }
        th { color:#cbd5f5; font-weight:600; }
        .bar { height:8px; border-radius:999px; background:linear-gradient(90deg,#3b82f6,#14b8a6); }
        .heatmap { display:grid; gap:2px; }
        .heat-cell { padding:6px; text-align:center; border-radius:4px; font-size:0.8rem; }
        .mini-chart { height:120px; width:100%; }
        .controls { display:flex; gap:0.4rem; flex-wrap:wrap; margin:0.4rem 0; }
        select, input[type=number] { background:var(--panel2); border:1px solid var(--border); color:var(--text); border-radius:0.45rem; padding:0.3rem 0.5rem; }
        .info-list { display:flex; flex-wrap:wrap; gap:0.35rem; }
      </style>
    </head>
    <body>
      <header>
        <h1>Root multi-parameter analysis workspace</h1>
        <div class="pill">接口式布局：可扩展新的分析模块</div>
      </header>
      <main>
        <section class="panel" id="controlPanel">
          <h3>Data settings</h3>
          <small id="metaSummary"></small>
          <div class="controls">
            <label>Choose index
              <select id="indexSelector"></select>
            </label>
            <label>Bins along z
              <input type="number" id="binInput" min="3" max="50" value="10" />
            </label>
            <label>k-means k
              <input type="number" id="clusterInput" min="2" max="10" value="3" />
            </label>
          </div>
          <div class="controls">
            <label>Color by metadata
              <select id="colorSelector"></select>
            </label>
          </div>
          <div class="text-muted">更复杂的模型/图表可以在下方接口处追加模块。</div>
        </section>
        <section class="panel" id="analysisPanel">
          <h3>Analysis outputs</h3>
          <div id="analysisGrid" class="grid"></div>
        </section>
      </main>
      <script>
        const payload = ${payloadStr};
        const rows = payload.rows || [];
        const indexColumns = payload.indices || [];
        const metaCols = payload.columns.filter(c => !indexColumns.includes(c));

        function mean(arr){ return arr.reduce((a,b)=>a+b,0)/arr.length; }
        function stddev(arr){ const m = mean(arr); return Math.sqrt(mean(arr.map(v => (v-m)**2))); }
        function quantile(arr, q){ if(!arr.length) return NaN; const a=[...arr].sort((a,b)=>a-b); const pos=(a.length-1)*q; const base=Math.floor(pos); const rest=pos-base; if(a[base+1]!==undefined) return a[base]+rest*(a[base+1]-a[base]); return a[base]; }

        function groupBy(key){
          const map = new Map();
          rows.forEach(r => {
            const k = r[key] || "(missing)";
            if (!map.has(k)) map.set(k, []);
            map.get(k).push(r);
          });
          return map;
        }

        function renderMeta(){
          const meta = document.getElementById('metaSummary');
          meta.textContent = `${rows.length} rows · ${indexColumns.length} indices · metadata: ${metaCols.join(', ')}`;
          const idxSel = document.getElementById('indexSelector');
          indexColumns.forEach(c => {
            const opt = document.createElement('option');
            opt.value = c; opt.textContent = c; idxSel.appendChild(opt);
          });
          const colorSel = document.getElementById('colorSelector');
          ['label','zone','layer','treatment','batch'].filter(c => metaCols.includes(c)).forEach(c => {
            const opt = document.createElement('option');
            opt.value = c; opt.textContent = c; colorSel.appendChild(opt);
          });
        }

        function makeCard(title, content){
          const div = document.createElement('div');
          div.className = 'card';
          div.innerHTML = `<h4>${title}</h4>${content}`;
          return div;
        }

        function renderQC(index){
          const vals = rows.map(r => Number(r[index])).filter(v => !isNaN(v));
          const q1 = quantile(vals,0.25), q3 = quantile(vals,0.75);
          const iqr = q3 - q1;
          const low = q1 - 1.5*iqr, high = q3 + 1.5*iqr;
          const outliers = vals.filter(v => v < low || v > high).length;
          const content = `
            <div class="text-muted">IQR: ${iqr.toFixed(3)} · Whisker: [${low.toFixed(3)}, ${high.toFixed(3)}] · Outliers: ${outliers}</div>
            <div class="bar" style="width:${Math.min(100, (vals.length/rows.length)*100)}%"></div>
          `;
          return makeCard('基础 QC / outlier', content);
        }

        function renderDistributions(index){
          const vals = rows.map(r => Number(r[index])).filter(v => !isNaN(v));
          const bins = 12;
          const min = Math.min(...vals), max = Math.max(...vals);
          const step = (max-min || 1)/bins;
          const counts = Array.from({length:bins}, ()=>0);
          vals.forEach(v => { const i=Math.min(bins-1, Math.floor((v-min)/step)); counts[i]++; });
          const maxCount = Math.max(...counts,1);
          const bars = counts.map((c,i)=>{
            const w = (c/maxCount)*100;
            return `<div class="text-muted">Bin ${i+1}: ${c}</div><div class="bar" style="width:${w}%; margin-bottom:6px;"></div>`;
          }).join('');
          return makeCard('分布 (histogram-like)', bars);
        }

        function renderGrouped(index){
          const groups = ['zone','layer','treatment'].filter(k => metaCols.includes(k));
          if (!groups.length) return makeCard('分组统计', '<div class="text-muted">No zone/layer/treatment columns.</div>');
          const tables = groups.map(g => {
            const map = groupBy(g);
            const rowsHtml = Array.from(map.entries()).map(([key,list]) => {
              const vals = list.map(r => Number(r[index])).filter(v=>!isNaN(v));
              return `<tr><td>${key}</td><td>${quantile(vals,0.25).toFixed(2)}</td><td>${quantile(vals,0.5).toFixed(2)}</td><td>${quantile(vals,0.75).toFixed(2)}</td><td>${vals.length}</td></tr>`;
            }).join('');
            return `<div class="text-muted" style="margin:0.2rem 0;">${g}</div><table><thead><tr><th>${g}</th><th>Q1</th><th>Median</th><th>Q3</th><th>n</th></tr></thead><tbody>${rowsHtml}</tbody></table>`;
          }).join('');
          return makeCard('按 zone/layer/treatment 盒须信息', tables);
        }

        function renderGradient(index, bins){
          const zVals = rows.map(r => Number(r.z_position)).filter(v => !isNaN(v));
          if (!zVals.length) return makeCard('梯度分析', '<div class="text-muted">z_position 缺失</div>');
          const min = Math.min(...zVals), max = Math.max(...zVals);
          const step = (max-min || 1)/bins;
          const series = Array.from({length:bins}, (_,i)=>({
            bin: i+1,
            start: min + i*step,
            end: min + (i+1)*step,
            values: []
          }));
          rows.forEach(r => {
            const z = Number(r.z_position);
            const v = Number(r[index]);
            if (isNaN(z) || isNaN(v)) return;
            const idx = Math.min(bins-1, Math.floor((z-min)/step));
            series[idx].values.push(v);
          });
          const points = series.map(s => ({
            bin: s.bin,
            mean: s.values.length ? mean(s.values) : NaN
          }));
          const spark = points.map(p => isNaN(p.mean)?'' : `${p.bin},${p.mean.toFixed(3)}`).filter(Boolean).join(' | ');
          const list = series.map(s => `<div class="text-muted">Bin ${s.bin} (${s.start.toFixed(2)}-${s.end.toFixed(2)}): n=${s.values.length}, mean=${s.values.length?mean(s.values).toFixed(3):'NA'}</div>`).join('');
          return makeCard('沿根轴梯度 (z binned)', `<div class="tag">${spark}</div>${list}`);
        }

        function correlationMatrix(features){
          const n = features.length;
          const vals = features.map(f => rows.map(r => Number(r[f])).filter(v=>!isNaN(v)));
          const means = vals.map(v => mean(v));
          const mat = Array.from({length:n}, ()=>Array(n).fill(0));
          for (let i=0;i<n;i++){
            for (let j=i;j<n;j++){
              let num=0, denomA=0, denomB=0;
              for (let k=0;k<rows.length;k++){
                const a = Number(rows[k][features[i]]);
                const b = Number(rows[k][features[j]]);
                if (isNaN(a) || isNaN(b)) continue;
                num += (a-means[i])*(b-means[j]);
                denomA += (a-means[i])**2;
                denomB += (b-means[j])**2;
              }
              const corr = num / Math.sqrt((denomA||1)*(denomB||1));
              mat[i][j] = mat[j][i] = corr;
            }
          }
          return mat;
        }

        function renderCorrelation(features){
          if (!features.length) return makeCard('相关矩阵', '<div class="text-muted">No indices detected.</div>');
          const mat = correlationMatrix(features);
          const size = features.length;
          const heat = document.createElement('div');
          heat.className = 'heatmap';
          heat.style.gridTemplateColumns = `repeat(${size}, 1fr)`;
          mat.forEach((row,i)=>{
            row.forEach((v,j)=>{
              const cell = document.createElement('div');
              cell.className = 'heat-cell';
              const hue = v >=0 ? 200 : 0;
              const alpha = Math.min(1, Math.abs(v));
              cell.style.background = `rgba(${v>=0?59:239}, ${v>=0?130:68}, ${v>=0?246:68}, ${0.15 + 0.6*alpha})`;
              cell.textContent = v.toFixed(2);
              if (i===0) cell.setAttribute('data-col', features[j]);
              heat.appendChild(cell);
            });
          });
          const legend = `<div class="text-muted">含模块聚类接口：目前按相关性着色，可在此处接入层次聚类/partial correlation。</div>`;
          const wrapper = document.createElement('div');
          wrapper.appendChild(heat);
          const card = makeCard('相关矩阵 / heatmap', heat.outerHTML + legend);
          return card;
        }

        function covarianceMatrix(features){
          const n = features.length;
          const means = features.map(f => mean(rows.map(r => Number(r[f])||0)));
          const mat = Array.from({length:n}, ()=>Array(n).fill(0));
          rows.forEach(r => {
            const vals = features.map((f,i)=> Number(r[f]) - means[i]);
            for (let i=0;i<n;i++){
              for (let j=i;j<n;j++){
                mat[i][j] += vals[i]*vals[j];
              }
            }
          });
          const denom = Math.max(1, rows.length-1);
          for (let i=0;i<n;i++){
            for (let j=i;j<n;j++){
              const v = mat[i][j]/denom;
              mat[i][j]=mat[j][i]=v;
            }
          }
          return mat;
        }

        function jacobiEigen(matrix, maxIter=100){
          const n = matrix.length;
          let a = matrix.map(row => row.slice());
          let v = Array.from({length:n}, (_,i)=>{
            const row = Array(n).fill(0); row[i]=1; return row; });
          for (let iter=0; iter<maxIter; iter++){
            let p=0,q=1, max=0;
            for (let i=0;i<n;i++){
              for (let j=i+1;j<n;j++){
                if (Math.abs(a[i][j]) > Math.abs(max)) { max=a[i][j]; p=i; q=j; }
              }
            }
            if (Math.abs(max) < 1e-9) break;
            const phi = 0.5 * Math.atan2(2*a[p][q], a[q][q]-a[p][p]);
            const c = Math.cos(phi), s = Math.sin(phi);
            const app = c*c*a[p][p] - 2*s*c*a[p][q] + s*s*a[q][q];
            const aqq = s*s*a[p][p] + 2*s*c*a[p][q] + c*c*a[q][q];
            a[p][p]=app; a[q][q]=aqq; a[p][q]=a[q][p]=0;
            for (let k=0;k<n;k++){
              if (k!==p && k!==q){
                const apk = c*a[p][k] - s*a[q][k];
                const aqk = s*a[p][k] + c*a[q][k];
                a[p][k]=a[k][p]=apk; a[q][k]=a[k][q]=aqk;
              }
              const vkp = c*v[k][p] - s*v[k][q];
              const vkq = s*v[k][p] + c*v[k][q];
              v[k][p]=vkp; v[k][q]=vkq;
            }
          }
          const eigenvalues = a.map((row,i)=>row[i]);
          const eigenvectors = v;
          const pairs = eigenvalues.map((val,i)=>({val, vec: eigenvectors.map(r=>r[i])})).sort((a,b)=>b.val-a.val);
          return pairs;
        }

        function projectPCA(features){
          if (!features.length) return { components: [], projections: [] };
          const cov = covarianceMatrix(features);
          const eig = jacobiEigen(cov);
          const comps = eig.slice(0, Math.min(3, eig.length));
          const matrix = comps.map(c => c.vec);
          const projections = rows.map(r => {
            const vals = features.map(f => Number(r[f])||0);
            return {
              roi: r.roi_id,
              coords: matrix.map(vec => vec.reduce((sum, v, idx)=> sum + v*vals[idx], 0)),
              meta: r
            };
          });
          const totalVar = eig.reduce((a,b)=>a+b.val,0)||1;
          const explained = comps.map(c => c.val/totalVar*100);
          return { components: comps, projections, explained };
        }

        function kmeans(points, k=3, iter=25){
          if (!points.length) return [];
          const centroids = points.slice(0,k).map(p => p.coords.slice());
          for (let it=0; it<iter; it++){
            const clusters = Array.from({length:k}, ()=>[]);
            points.forEach(p => {
              let best=0, bestDist=Infinity;
              centroids.forEach((c,i)=>{
                const d = c.reduce((s,v,idx)=> s + (v-p.coords[idx])**2, 0);
                if (d<bestDist){ bestDist=d; best=i; }
              });
              clusters[best].push(p);
            });
            centroids.forEach((c,i)=>{
              if (!clusters[i].length) return;
              for (let d=0; d<c.length; d++){
                c[d] = mean(clusters[i].map(p=>p.coords[d]));
              }
            });
          }
          return points.map(p => {
            let best=0, bestDist=Infinity;
            centroids.forEach((c,i)=>{
              const d = c.reduce((s,v,idx)=> s + (v-p.coords[idx])**2, 0);
              if (d<bestDist){ bestDist=d; best=i; }
            });
            return { ...p, cluster: best+1 };
          });
        }

        function renderPCA(features, k){
          const { components, projections, explained } = projectPCA(features);
          if (!components.length) return makeCard('PCA / clustering', '<div class="text-muted">No numeric indices.</div>');
          const clustered = kmeans(projections, k);
          const compText = components.map((c,i)=>`PC${i+1}: ${explained[i].toFixed(2)}%`).join(' · ');
          const clusterCounts = clustered.reduce((acc,p)=>{
            acc[p.cluster] = (acc[p.cluster]||0)+1; return acc; }, {});
          const clusterList = Object.entries(clusterCounts).map(([k,v])=>`C${k}: ${v}`).join(' | ');
          const content = `
            <div class="tag">${compText}</div>
            <div class="text-muted">Clusters in PC space → actin states: ${clusterList}</div>
            <div class="text-muted">可将 cluster 与 zone/layer/treatment 交叉：${JSON.stringify(clusterCounts)}</div>
          `;
          return makeCard('PCA + 聚类', content);
        }

        function renderModuleScores(features){
          const modules = {
            Density: ['index_density'],
            Bundling: ['index_bundling'],
            Connectivity: ['index_connectivity'],
            Branching: ['index_branching'],
            Anisotropy: ['index_anisotropy']
          };
          const cards = Object.entries(modules).map(([name, fList]) => {
            const available = fList.filter(f => features.includes(f));
            if (!available.length) return `<div class="text-muted">${name}: 缺少相关指数，暂为空。</div>`;
            const vals = rows.map(r => mean(available.map(f => Number(r[f])||0)));
            const content = `<div class="text-muted">局部 PCA / 因子分析可接入此处。目前使用简单均值作为 ${name} 模块得分。均值=${mean(vals).toFixed(3)}, SD=${stddev(vals).toFixed(3)}</div>`;
            return content;
          }).join('');
          return makeCard('模块 score（可替代多指标）', cards);
        }

        function renderAll(){
          const grid = document.getElementById('analysisGrid');
          grid.innerHTML = '';
          if (!indexColumns.length) {
            grid.appendChild(makeCard('No numeric indices', '<div class="text-muted">请在表格中提供至少一个指数列。</div>'));
            return;
          }
          const index = document.getElementById('indexSelector').value || indexColumns[0];
          const bins = Number(document.getElementById('binInput').value) || 10;
          const k = Number(document.getElementById('clusterInput').value) || 3;
          grid.appendChild(renderQC(index));
          grid.appendChild(renderDistributions(index));
          grid.appendChild(renderGrouped(index));
          grid.appendChild(renderGradient(index, bins));
          grid.appendChild(renderCorrelation(indexColumns.slice(0,10)));
          grid.appendChild(renderPCA(indexColumns, k));
          grid.appendChild(renderModuleScores(indexColumns));
        }

        renderMeta();
        document.getElementById('indexSelector').addEventListener('change', renderAll);
        document.getElementById('binInput').addEventListener('change', renderAll);
        document.getElementById('clusterInput').addEventListener('change', renderAll);
        renderAll();
      </script>
    </body>
    </html>`;
  }

  dataFileInput.addEventListener("change", (e) => {
    const file = e.target.files[0];
    if (!file) return;
    loadDataFromFile(file);
  });

  downloadTemplateBtn.addEventListener("click", downloadTemplateFromLabels);
  openAnalysisBtn.addEventListener("click", createAnalysisWindow);

  addLabelBtn.addEventListener("click", () => {
    const name = labelNameInput.value.trim();
    const color = labelColorInput.value || getNextColor();
    const id = "L" + (labels.length + 1);
    labels.push({
      id,
      name: name || `Label ${labels.length + 1}`,
      color
    });
    activeLabelId = id;
    labelNameInput.value = "";
    labelColorInput.value = getNextColor();
    refreshLabelList();
    updateGlobalStats();
  });

  clearAllLabelsBtn.addEventListener("click", () => {
    const ok = confirm("Delete all labels and clear assignments?");
    if (!ok) return;
    labels = [];
    roiAssignments = {};
    activeLabelId = null;
    refreshLabelList();
    refreshAllRoisAppearance();
    updateGlobalStats();
  });

  // ----------- 初始化 -----------
  (function init(){
    labelColorInput.value = getNextColor();
    refreshLabelList();
    updateGlobalStats();
    setInteractionMode("move");
    hoverInfo.textContent = "Loading SVG map…";
    loadSvgMap();
  })();
</script>
</body>
</html>
