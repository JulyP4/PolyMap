<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Root ROI Map Annotator v4 (Vector-style)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    :root {
      --bg: #020617;
      --panel: #0f172a;
      --panel2: #111827;
      --border: #1f2937;
      --accent: #3b82f6;
      --accent-soft: rgba(59, 130, 246, 0.16);
      --text: #e5e7eb;
      --muted: #9ca3af;
      --danger: #f97373;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
        sans-serif;
      background: radial-gradient(circle at top, #111827 0, #020617 55%);
      color: var(--text);
      height: 100vh;
      display: flex;
      flex-direction: column;
    }

    header {
      padding: 0.6rem 1rem;
      border-bottom: 1px solid var(--border);
      background: rgba(15, 23, 42, 0.95);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    header h1 {
      margin: 0;
      font-size: 1rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: #93c5fd;
    }

    header span {
      font-size: 0.8rem;
      color: var(--muted);
    }

    .pill {
      font-size: 0.75rem;
      padding: 0.2rem 0.6rem;
      border-radius: 999px;
      border: 1px solid var(--border);
      color: var(--muted);
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
      background: rgba(15, 23, 42, 0.85);
    }

    main {
      flex: 1;
      display: grid;
      grid-template-columns: 260px minmax(0, 1.2fr) 260px;
      gap: 0.6rem;
      padding: 0.6rem;
      min-height: 0;
    }

    @media (max-width: 1024px) {
      main {
        grid-template-columns: minmax(0, 1fr);
        grid-template-rows: auto auto auto;
      }
    }

    .panel {
      background: var(--panel);
      border-radius: 0.75rem;
      border: 1px solid var(--border);
      padding: 0.7rem;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }

    .panel-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.5rem;
    }

    .panel-title {
      font-size: 0.85rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--muted);
    }

    .panel-subtitle {
      font-size: 0.75rem;
      color: var(--muted);
    }

    .panel-body {
      flex: 1;
      overflow: auto;
      padding-right: 0.3rem;
    }

    .section {
      margin-bottom: 0.8rem;
      padding-bottom: 0.6rem;
      border-bottom: 1px dashed #1f2937;
    }

    .section:last-child {
      border-bottom: none;
      margin-bottom: 0;
      padding-bottom: 0;
    }

    .section-title {
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: var(--muted);
      margin-bottom: 0.3rem;
    }

    label {
      display: block;
      font-size: 0.8rem;
      color: var(--muted);
      margin-bottom: 0.2rem;
    }

    input[type="file"],
    input[type="text"] {
      width: 100%;
      font-size: 0.8rem;
      padding: 0.3rem 0.4rem;
      border-radius: 0.45rem;
      border: 1px solid var(--border);
      background: var(--panel2);
      color: var(--text);
      outline: none;
    }

    input[type="file"] {
      padding: 0.2rem 0.3rem;
    }

    input[type="text"]:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 1px var(--accent-soft);
    }

    input[type="color"] {
      width: 100%;
      height: 1.8rem;
      border-radius: 0.4rem;
      border: 1px solid var(--border);
      background: transparent;
      padding: 0;
      cursor: pointer;
    }

    .button {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 0.8rem;
      padding: 0.28rem 0.6rem;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: #020617;
      color: var(--text);
      cursor: pointer;
      gap: 0.3rem;
      transition: all 0.12s ease;
    }

    .button.primary {
      background: linear-gradient(135deg, #2563eb, #4f46e5);
      border-color: transparent;
      color: white;
    }

    .button.small {
      font-size: 0.75rem;
      padding: 0.18rem 0.5rem;
    }

    .button.danger {
      border-color: rgba(248, 113, 113, 0.8);
      color: #fecaca;
    }

    .button.icon {
      padding: 0.15rem 0.35rem;
    }

    .button:hover {
      border-color: var(--accent);
      background: #020617;
    }

    .button.primary:hover {
      box-shadow: 0 10px 25px rgba(37, 99, 235, 0.6);
      transform: translateY(-1px);
    }

    .button.danger:hover {
      background: rgba(185, 28, 28, 0.45);
    }

    .row {
      display: flex;
      gap: 0.4rem;
      margin-bottom: 0.4rem;
    }

    .row > * {
      flex: 1;
    }

    .hint {
      font-size: 0.72rem;
      color: var(--muted);
      line-height: 1.4;
      margin-top: 0.25rem;
    }

    #canvasContainer {
      flex: 1;
      min-height: 0;
      border-radius: 0.7rem;
      border: 1px solid var(--border);
      background: radial-gradient(circle at center, #020617 0, #020617 60%);
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }

    #maskCanvas {
      border-radius: 0.6rem;
      box-shadow: 0 14px 35px rgba(0, 0, 0, 0.75);
      position: absolute;
      top: 0;
      left: 0;
    }

    #overlayCanvas {
      position: absolute;
      top: 0;
      left: 0;
      pointer-events: none;
    }

    .empty-state {
      text-align: center;
      color: var(--muted);
      font-size: 0.8rem;
      padding: 1.2rem;
    }

    .status-line {
      font-size: 0.72rem;
      color: var(--muted);
      margin-top: 0.3rem;
    }

    #labelList {
      display: flex;
      flex-direction: column;
      gap: 0.3rem;
      margin-top: 0.3rem;
    }

    .label-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0.25rem 0.4rem;
      background: rgba(15, 23, 42, 0.95);
      border-radius: 0.5rem;
      border: 1px solid transparent;
      cursor: pointer;
      gap: 0.4rem;
      transition: all 0.12s ease;
    }

    .label-item:hover {
      border-color: var(--border);
    }

    .label-item.active {
      border-color: var(--accent);
      box-shadow: 0 0 0 1px var(--accent-soft);
      background: radial-gradient(circle at top, var(--accent-soft), #020617);
    }

    .label-color-dot {
      width: 14px;
      height: 14px;
      border-radius: 999px;
      border: 1px solid #020617;
      flex-shrink: 0;
    }

    .label-main {
      flex: 1;
      min-width: 0;
    }

    .label-main div:first-child {
      font-size: 0.8rem;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .label-main div:last-child {
      font-size: 0.7rem;
      color: var(--muted);
    }

    .badge {
      font-size: 0.7rem;
      padding: 0.05rem 0.35rem;
      border-radius: 999px;
      border: 1px solid #475569;
      color: var(--muted);
    }

    footer {
      padding: 0.3rem 0.8rem;
      font-size: 0.72rem;
      color: var(--muted);
      border-top: 1px solid var(--border);
      background: rgba(15, 23, 42, 0.96);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
  </style>
</head>
<body>
  <header>
    <div>
      <h1>Root ROI Map Annotator v4</h1>
      <span>Template image → high-res segmentation → vector-style ROI map + labels → single-file JSON/PNG</span>
    </div>
    <div class="pill">
      <span>Click: label / clear</span>
      <span>Box: batch label / clear</span>
      <span>Move: drag canvas</span>
      <span>Wheel: zoom at mouse</span>
    </div>
  </header>

  <main>
    <!-- Left panel -->
    <aside class="panel">
      <div class="panel-header">
        <div class="panel-title">Input & Files</div>
      </div>
      <div class="panel-body">
        <div class="section">
          <div class="section-title">1. Root template image</div>
          <label for="maskFileInput">PNG / JPEG / SVG (black outlines + white background)</label>
          <input type="file" id="maskFileInput" accept=".png,.jpg,.jpeg,.svg,image/png,image/jpeg,image/svg+xml" />
          <div class="hint">
            The image is only used once to extract ROI shapes (high-res).
            Display uses rebuilt vector-style ROIs, not the original raster.
          </div>
          <div id="maskInfo" class="status-line"></div>
        </div>

        <div class="section">
          <div class="section-title">2. Import / Export</div>
          <div class="row">
            <button class="button small primary" id="exportJsonBtn">Export full project (JSON)</button>
            <button class="button small" id="exportPngBtn">Export map (PNG)</button>
          </div>
          <label for="annotationFileInput">Import project JSON</label>
          <input type="file" id="annotationFileInput" accept="application/json,.json" />
          <div class="hint">
            JSON stores: high-res ROI map, vector polygons, centroids, labels, and assignments.
            You can reload it later without the original image.
          </div>
        </div>

        <div class="section">
          <div class="section-title">3. Interaction mode</div>
          <div class="row">
            <button class="button small primary" id="modeClickBtn">Click mode</button>
            <button class="button small" id="modeBoxBtn">Box mode</button>
            <button class="button small" id="modeMoveBtn">Move mode</button>
          </div>
          <div id="modeStatus" class="status-line"></div>
        </div>
      </div>
    </aside>

    <!-- Center: canvas -->
    <section class="panel">
      <div class="panel-header">
        <div>
          <div class="panel-title">Vector-style ROI Map View</div>
          <div class="panel-subtitle">
            Each ROI is redrawn as a smooth vector-style region with its own border. Interiors are kept blank (light).
          </div>
        </div>
        <div id="hoverInfo" class="pill">No image loaded</div>
      </div>
      <div id="canvasContainer">
        <canvas id="maskCanvas"></canvas>
        <canvas id="overlayCanvas"></canvas>
        <div id="emptyState" class="empty-state">
          Upload a root template image (black outlines + white background).<br /><br />
          The image is upscaled for segmentation, then converted into:<br />
          · High-res ROI ID map<br />
          · Vector-like polygons for each closed region<br />
          Only closed white regions become ROIs; open lines are ignored as boundaries.
        </div>
      </div>
    </section>

    <!-- Right panel: labels & stats -->
    <aside class="panel">
      <div class="panel-header">
        <div class="panel-title">Labels & Stats</div>
        <button class="button small danger" id="clearAllBtn">Clear labels</button>
      </div>
      <div class="panel-body">
        <div class="section">
          <div class="section-title">1. Create label</div>
          <label for="labelNameInput">Label name</label>
          <input type="text" id="labelNameInput" placeholder="e.g. Meristem / Cortex / QC" />
          <label for="labelColorInput">Label color (border)</label>
          <input type="color" id="labelColorInput" />
          <button class="button primary" id="addLabelBtn" style="margin-top:0.4rem;width:100%;">Add label</button>
          <div class="hint">
            Click a label to set it as active (click again to deactivate).<br/>
            · With an active label: click/box → set/overwrite that label on selected ROIs.<br/>
            · With no active label: click/box → clear labels on selected ROIs.
          </div>
        </div>

        <div class="section">
          <div class="section-title">2. Label list</div>
          <div id="labelList"></div>
          <div id="labelEmptyHint" class="hint">
            No labels yet. Please create at least one label.
          </div>
        </div>

        <div class="section">
          <div class="section-title">3. Global stats</div>
          <div id="globalStats" class="hint">No image/project loaded yet.</div>
        </div>
      </div>
    </aside>
  </main>

  <footer>
    <div>Largest white connected region is treated as outside background and removed.</div>
    <div id="selectionStatus">No ROI selected</div>
  </footer>

  <script>
    // ===== DOM references =====
    const maskCanvas = document.getElementById("maskCanvas");
    const overlayCanvas = document.getElementById("overlayCanvas");
    const ctx = maskCanvas.getContext("2d");
    const overlayCtx = overlayCanvas.getContext("2d");
    const canvasContainer = document.getElementById("canvasContainer");
    const emptyState = document.getElementById("emptyState");

    const maskFileInput = document.getElementById("maskFileInput");
    const annotationFileInput = document.getElementById("annotationFileInput");
    const maskInfo = document.getElementById("maskInfo");
    const hoverInfo = document.getElementById("hoverInfo");
    const globalStats = document.getElementById("globalStats");
    const selectionStatus = document.getElementById("selectionStatus");
    const modeStatus = document.getElementById("modeStatus");

    const modeClickBtn = document.getElementById("modeClickBtn");
    const modeBoxBtn = document.getElementById("modeBoxBtn");
    const modeMoveBtn = document.getElementById("modeMoveBtn");

    const addLabelBtn = document.getElementById("addLabelBtn");
    const labelNameInput = document.getElementById("labelNameInput");
    const labelColorInput = document.getElementById("labelColorInput");
    const labelListEl = document.getElementById("labelList");
    const labelEmptyHint = document.getElementById("labelEmptyHint");
    const clearAllBtn = document.getElementById("clearAllBtn");

    const exportJsonBtn = document.getElementById("exportJsonBtn");
    const exportPngBtn = document.getElementById("exportPngBtn");

    // ===== Global state =====
    let imgWidth = 0;
    let imgHeight = 0;
    let maskLoaded = false;

    // ROI ID per pixel in high-res grid
    let roiLabelData = null; // Uint16Array
    let roiCount = 0;

    // ROI → pixels, polygons, centroids
    let roiPixelMap = {};    // roiId -> { pixels: [{x,y}], cx, cy }
    let roiPolygons = {};    // roiId -> [[x,y], ...]
    let roiCentroids = {};   // roiId -> {cx, cy}

    // Labels
    let labels = [];         // {id, name, color}
    let activeLabelId = null;
    let roiAssignments = {}; // roiId -> labelId

    const defaultColors = [
      "#ef4444","#f97316","#facc15","#22c55e","#14b8a6",
      "#0ea5e9","#6366f1","#8b5cf6","#ec4899","#f97373"
    ];
    let colorIndex = 0;

    // Interaction
    let interactionMode = "click"; // "click" | "box" | "move"
    let isDragging = false;
    let dragStart = null;
    let dragCurrent = null;

    // View transform
    let baseScale = 1;
    let viewScale = 1;
    const minScale = 0.3;
    const maxScale = 5;
    let panX = 0;
    let panY = 0;

    let isPanning = false;
    let panStartClientX = 0;
    let panStartClientY = 0;
    let panStartX = 0;
    let panStartY = 0;

    // Hover animation
    let hoveredRoiId = 0;
    let hoverScaleCurrent = 1.0;
    let hoverScaleTarget = 1.0;
    const hoverScaleMax = 1.06;
    const hoverAnimSpeed = 8.0;

    // ===== Utilities =====
    function hexToRgb(hex) {
      hex = hex.replace("#", "");
      if (hex.length === 3) {
        hex = hex.split("").map(c => c + c).join("");
      }
      const num = parseInt(hex, 16);
      return {
        r: (num >> 16) & 255,
        g: (num >> 8) & 255,
        b: num & 255,
      };
    }

    function getNextColor() {
      const color = defaultColors[colorIndex % defaultColors.length];
      colorIndex++;
      return color;
    }

    function setMaskInfo(text) {
      maskInfo.textContent = text || "";
    }

    function setInteractionMode(mode) {
      interactionMode = mode;
      modeClickBtn.classList.toggle("primary", mode === "click");
      modeBoxBtn.classList.toggle("primary", mode === "box");
      modeMoveBtn.classList.toggle("primary", mode === "move");

      if (mode === "click") {
        modeStatus.innerHTML = "Mode: <strong>Click</strong>. With active label: set/overwrite. Without label: clear.";
      } else if (mode === "box") {
        modeStatus.innerHTML = "Mode: <strong>Box</strong>. Drag to apply the same logic to multiple ROIs.";
      } else {
        modeStatus.innerHTML = "Mode: <strong>Move</strong>. Drag to pan, wheel to zoom at mouse.";
      }
    }

    function updateGlobalStats() {
      if (!maskLoaded || !roiLabelData) {
        globalStats.textContent = "No image/project loaded yet.";
        return;
      }
      const used = new Set();
      for (let i = 0; i < roiLabelData.length; i++) {
        if (roiLabelData[i] > 0) used.add(roiLabelData[i]);
      }
      const total = used.size;
      const labeledSet = new Set(
        Object.keys(roiAssignments)
          .filter(k => roiAssignments[k])
          .map(k => parseInt(k, 10))
      );
      const labeled = labeledSet.size;
      globalStats.innerHTML = `Total ROIs: <strong>${total}</strong><br/>Labeled ROIs: <strong>${labeled}</strong> (${
        total ? (labeled / total * 100).toFixed(1) : 0
      }%)`;
    }

    function updateSelectionStatus(text) {
      selectionStatus.textContent = text || "No ROI selected";
    }

    function resizeCanvases(width, height) {
      maskCanvas.width = width;
      maskCanvas.height = height;
      overlayCanvas.width = width;
      overlayCanvas.height = height;

      maskCanvas.style.width = width + "px";
      maskCanvas.style.height = height + "px";
      overlayCanvas.style.width = width + "px";
      overlayCanvas.style.height = height + "px";

      computeBaseScale();
      viewScale = 1;
      panX = 0;
      panY = 0;
      updateViewTransform();
    }

    function computeBaseScale() {
      const rect = canvasContainer.getBoundingClientRect();
      if (!imgWidth || !imgHeight || !rect.width || !rect.height) return;
      baseScale = Math.min(rect.width / imgWidth, rect.height / imgHeight);
    }

    function updateViewTransform() {
      if (!imgWidth || !imgHeight) return;
      if (!baseScale) computeBaseScale();

      const rect = canvasContainer.getBoundingClientRect();
      const scale = baseScale * viewScale;

      const tx = (rect.width - imgWidth * scale) / 2 + panX;
      const ty = (rect.height - imgHeight * scale) / 2 + panY;

      const transform = `translate(${tx}px, ${ty}px) scale(${scale})`;

      maskCanvas.style.transformOrigin = "top left";
      overlayCanvas.style.transformOrigin = "top left";
      maskCanvas.style.transform = transform;
      overlayCanvas.style.transform = transform;
    }

    function refreshLabelList() {
      labelListEl.innerHTML = "";
      if (!labels.length) {
        labelEmptyHint.style.display = "block";
        return;
      }
      labelEmptyHint.style.display = "none";

      const counts = {};
      for (const [roiId, labelId] of Object.entries(roiAssignments)) {
        if (!labelId) continue;
        counts[labelId] = (counts[labelId] || 0) + 1;
      }

      labels.forEach(label => {
        const item = document.createElement("div");
        item.className = "label-item" + (label.id === activeLabelId ? " active" : "");
        item.dataset.labelId = label.id;

        const colorDot = document.createElement("div");
        colorDot.className = "label-color-dot";
        colorDot.style.backgroundColor = label.color;

        const main = document.createElement("div");
        main.className = "label-main";
        const nameDiv = document.createElement("div");
        nameDiv.textContent = label.name || "(Untitled)";
        const metaDiv = document.createElement("div");
        metaDiv.textContent = `ID: ${label.id} · ROIs: ${counts[label.id] || 0}`;

        main.appendChild(nameDiv);
        main.appendChild(metaDiv);

        const rightBox = document.createElement("div");
        rightBox.style.display = "flex";
        rightBox.style.alignItems = "center";
        rightBox.style.gap = "0.25rem";

        const badge = document.createElement("div");
        badge.className = "badge";
        badge.textContent = "Active";
        if (label.id !== activeLabelId) badge.style.visibility = "hidden";

        const delBtn = document.createElement("button");
        delBtn.className = "button small icon";
        delBtn.textContent = "×";
        delBtn.title = "Delete label";
        delBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          deleteLabel(label.id);
        });

        rightBox.appendChild(badge);
        rightBox.appendChild(delBtn);

        item.appendChild(colorDot);
        item.appendChild(main);
        item.appendChild(rightBox);

        item.addEventListener("click", () => {
          if (activeLabelId === label.id) {
            activeLabelId = null;
          } else {
            activeLabelId = label.id;
          }
          refreshLabelList();
        });

        labelListEl.appendChild(item);
      });
    }

    function deleteLabel(labelId) {
      labels = labels.filter(l => l.id !== labelId);
      if (activeLabelId === labelId) activeLabelId = null;
      for (const [roiId, lid] of Object.entries(roiAssignments)) {
        if (lid === labelId) delete roiAssignments[roiId];
      }
      refreshLabelList();
      updateGlobalStats();
      renderBase();
      renderOverlay();
    }

    function addLabel(name, colorInputValue) {
      const color = colorInputValue || getNextColor();
      const id = "L" + (labels.length + 1);
      labels.push({ id, name: name || `Label ${labels.length + 1}`, color });
      activeLabelId = id;
      refreshLabelList();
      labelColorInput.value = getNextColor();
    }

    // ----- Base64 encode/decode for Uint16 ROI map -----
    function encodeUint16ToBase64(arr) {
      const bytes = new Uint8Array(arr.length * 2);
      const dv = new DataView(bytes.buffer);
      for (let i = 0; i < arr.length; i++) {
        dv.setUint16(i * 2, arr[i], true);
      }
      let bin = "";
      for (let i = 0; i < bytes.length; i++) bin += String.fromCharCode(bytes[i]);
      return btoa(bin);
    }

    function decodeUint16FromBase64(b64) {
      const bin = atob(b64);
      const len = bin.length;
      const bytes = new Uint8Array(len);
      for (let i = 0; i < len; i++) bytes[i] = bin.charCodeAt(i);
      const dv = new DataView(bytes.buffer);
      const arr = new Uint16Array(len / 2);
      for (let i = 0; i < arr.length; i++) {
        arr[i] = dv.getUint16(i * 2, true);
      }
      return arr;
    }

    // ===== High-res segmentation =====
    function segmentImageHighRes(img) {
      // Choose high-res grid
      const maxDim = 2000;
      const scaleCandidate = maxDim / Math.max(img.width, img.height);
      const segScale = Math.min(4, Math.max(1, scaleCandidate)); // 1–4x
      const segW = Math.round(img.width * segScale);
      const segH = Math.round(img.height * segScale);

      // Hidden canvas for segmentation
      const segCanvas = document.createElement("canvas");
      segCanvas.width = segW;
      segCanvas.height = segH;
      const segCtx = segCanvas.getContext("2d");
      segCtx.imageSmoothingEnabled = true;
      segCtx.setTransform(segScale, 0, 0, segScale, 0, 0);
      segCtx.drawImage(img, 0, 0);

      imgWidth = segW;
      imgHeight = segH;
      resizeCanvases(imgWidth, imgHeight);

      const imageData = segCtx.getImageData(0, 0, segW, segH);
      const data = imageData.data;
      const pixels = segW * segH;

      const labelsArr = new Int32Array(pixels);
      const isBoundary = new Uint8Array(pixels);

      // Dark pixels = boundary
      for (let i = 0; i < pixels; i++) {
        const r = data[i * 4];
        const g = data[i * 4 + 1];
        const b = data[i * 4 + 2];
        const a = data[i * 4 + 3];
        const brightness = (r + g + b) / 3;
        if (a > 0 && brightness < 220) {
          isBoundary[i] = 1;
        }
      }

      let currentLabel = 0;
      const stack = [];

      function pushIfValid(idx) {
        if (idx < 0 || idx >= pixels) return;
        if (isBoundary[idx]) return;
        if (labelsArr[idx] !== 0) return;
        labelsArr[idx] = currentLabel;
        stack.push(idx);
      }

      for (let i = 0; i < pixels; i++) {
        if (isBoundary[i]) continue;
        if (labelsArr[i] !== 0) continue;
        currentLabel++;
        labelsArr[i] = currentLabel;
        stack.length = 0;
        stack.push(i);
        while (stack.length > 0) {
          const idx = stack.pop();
          const x = idx % segW;
          const y = (idx / segW) | 0;
          if (x > 0) pushIfValid(idx - 1);
          if (x < segW - 1) pushIfValid(idx + 1);
          if (y > 0) pushIfValid(idx - segW);
          if (y < segH - 1) pushIfValid(idx + segW);
        }
      }

      const areas = new Array(currentLabel + 1).fill(0);
      for (let i = 0; i < pixels; i++) {
        const l = labelsArr[i];
        if (l > 0) areas[l]++;
      }

      let largestLabel = 0;
      let largestArea = 0;
      for (let l = 1; l <= currentLabel; l++) {
        if (areas[l] > largestArea) {
          largestArea = areas[l];
          largestLabel = l;
        }
      }

      const labelMap = new Int32Array(currentLabel + 1);
      let newId = 1;
      for (let l = 1; l <= currentLabel; l++) {
        if (l === largestLabel) labelMap[l] = 0;
        else labelMap[l] = newId++;
      }

      roiLabelData = new Uint16Array(pixels);
      roiCount = newId - 1;
      roiPixelMap = {};
      roiPolygons = {};
      roiCentroids = {};

      for (let i = 0; i < pixels; i++) {
        const old = labelsArr[i];
        const newVal = labelMap[old];
        roiLabelData[i] = newVal;
        if (newVal > 0) {
          const x = i % segW;
          const y = (i / segW) | 0;
          if (!roiPixelMap[newVal]) {
            roiPixelMap[newVal] = { pixels: [], cx: 0, cy: 0 };
          }
          roiPixelMap[newVal].pixels.push({ x, y });
        }
      }

      // Centroids
      for (const [idStr, obj] of Object.entries(roiPixelMap)) {
        const arr = obj.pixels;
        let sx = 0, sy = 0;
        for (const p of arr) { sx += p.x; sy += p.y; }
        const n = arr.length || 1;
        const cx = sx / n;
        const cy = sy / n;
        obj.cx = cx;
        obj.cy = cy;
        roiCentroids[idStr] = { cx, cy };
      }

      // Polygons
      buildRoiPolygonsFromPixels(segW, segH);

      setMaskInfo(`Segmentation: high-res grid ${segW} × ${segH}, ROIs: ${roiCount} (outer background removed).`);
      updateGlobalStats();

      // clear visible canvas; we will draw vector-style
      ctx.clearRect(0, 0, imgWidth, imgHeight);
    }

    function buildRoiPolygonsFromPixels(width, height) {
      roiPolygons = {};
      for (const [idStr, obj] of Object.entries(roiPixelMap)) {
        const pixels = obj.pixels;
        if (!pixels || !pixels.length) continue;
        const pixelSet = new Set(pixels.map(p => p.x + "," + p.y));
        const boundary = [];
        for (const p of pixels) {
          const neighbors = [
            (p.x - 1) + "," + p.y,
            (p.x + 1) + "," + p.y,
            p.x + "," + (p.y - 1),
            p.x + "," + (p.y + 1)
          ];
          let isBoundaryPix = false;
          for (const nb of neighbors) {
            if (!pixelSet.has(nb)) {
              isBoundaryPix = true;
              break;
            }
          }
          if (isBoundaryPix) boundary.push({ x: p.x, y: p.y });
        }
        if (!boundary.length) continue;

        const { cx, cy } = roiCentroids[idStr];
        boundary.sort((a, b) => {
          const ta = Math.atan2(a.y - cy, a.x - cx);
          const tb = Math.atan2(b.y - cy, b.x - cx);
          return ta - tb;
        });

        const step = Math.max(1, Math.floor(boundary.length / 1200));
        const poly = [];
        for (let i = 0; i < boundary.length; i += step) {
          poly.push([boundary[i].x + 0.5, boundary[i].y + 0.5]);
        }
        roiPolygons[idStr] = poly;
      }
    }

    // ===== Base render: blank interior + colored borders =====
    function renderBase() {
      if (!maskLoaded || !roiLabelData) return;

      ctx.clearRect(0, 0, imgWidth, imgHeight);

      // Background outside ROIs
      ctx.save();
      ctx.fillStyle = "#020617";
      ctx.fillRect(0, 0, imgWidth, imgHeight);
      ctx.restore();

      ctx.save();
      ctx.lineJoin = "round";
      ctx.lineCap = "round";
      ctx.miterLimit = 2;

      for (let id = 1; id <= roiCount; id++) {
        const poly = roiPolygons[id];
        if (!poly || poly.length < 3) continue;

        const labelId = roiAssignments[id];
        let borderColor;
        if (labelId) {
          const label = labels.find(l => l.id === labelId);
          borderColor = label ? label.color : "#6366f1";
        } else {
          borderColor = "#9ca3af";
        }

        // interior light/blank
        ctx.beginPath();
        ctx.moveTo(poly[0][0], poly[0][1]);
        for (let i = 1; i < poly.length; i++) {
          ctx.lineTo(poly[i][0], poly[i][1]);
        }
        ctx.closePath();

        ctx.fillStyle = "#f9fafb"; // blank interior (light)
        ctx.strokeStyle = borderColor;
        ctx.lineWidth = 1.1;

        ctx.fill();
        ctx.stroke();
      }

      ctx.restore();
      updateGlobalStats();
      refreshLabelList();
    }

    // ===== Overlay: box selection + hover float =====
    function renderOverlay() {
      overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);

      // box selection
      if (isDragging && dragStart && dragCurrent && interactionMode === "box") {
        overlayCtx.save();
        overlayCtx.setLineDash([4, 3]);
        overlayCtx.lineWidth = 1.5;
        overlayCtx.strokeStyle = "rgba(96,165,250,0.9)";
        overlayCtx.fillStyle = "rgba(37,99,235,0.18)";

        const x = Math.min(dragStart.x, dragCurrent.x);
        const y = Math.min(dragStart.y, dragCurrent.y);
        const w = Math.abs(dragCurrent.x - dragStart.x);
        const h = Math.abs(dragCurrent.y - dragStart.y);

        overlayCtx.fillRect(x, y, w, h);
        overlayCtx.strokeRect(x, y, w, h);
        overlayCtx.restore();
      }

      // hover float
      if (hoveredRoiId > 0 && roiPolygons[hoveredRoiId]) {
        const poly = roiPolygons[hoveredRoiId];
        const center = roiCentroids[hoveredRoiId];
        if (poly && center) {
          const { cx, cy } = center;
          const labelId = roiAssignments[hoveredRoiId];
          let baseColor = labelId
            ? (labels.find(l => l.id === labelId)?.color || "#6366f1")
            : "#94a3b8";
          const { r, g, b } = hexToRgb(baseColor);

          overlayCtx.save();
          overlayCtx.translate(cx, cy);
          overlayCtx.scale(hoverScaleCurrent, hoverScaleCurrent);
          overlayCtx.translate(-cx, -cy);

          overlayCtx.beginPath();
          overlayCtx.moveTo(poly[0][0], poly[0][1]);
          for (let i = 1; i < poly.length; i++) {
            overlayCtx.lineTo(poly[i][0], poly[i][1]);
          }
          overlayCtx.closePath();

          overlayCtx.shadowColor = "rgba(15,23,42,0.9)";
          overlayCtx.shadowBlur = 12;
          overlayCtx.shadowOffsetY = 4;

          overlayCtx.fillStyle = `rgba(${Math.min(r+30,255)},${Math.min(g+30,255)},${Math.min(b+30,255)},0.92)`;
          overlayCtx.strokeStyle = "rgba(248,250,252,0.95)";
          overlayCtx.lineWidth = 1.6;

          overlayCtx.fill();
          overlayCtx.stroke();

          overlayCtx.restore();
        }
      }
    }

    // ===== Coordinate helpers =====
    function canvasPixelFromEvent(evt) {
      const rect = maskCanvas.getBoundingClientRect();
      const scaleX = maskCanvas.width / rect.width;
      const scaleY = maskCanvas.height / rect.height;
      const x = Math.floor((evt.clientX - rect.left) * scaleX);
      const y = Math.floor((evt.clientY - rect.top) * scaleY);
      if (x < 0 || y < 0 || x >= maskCanvas.width || y >= maskCanvas.height) return null;
      return { x, y };
    }

    function getRoiIdAt(x, y) {
      if (!roiLabelData) return 0;
      const idx = y * imgWidth + x;
      if (idx < 0 || idx >= roiLabelData.length) return 0;
      return roiLabelData[idx];
    }

    function applyLabelToRois(roiIds) {
      roiIds.forEach(roiId => {
        if (roiId <= 0) return;
        if (activeLabelId) {
          roiAssignments[roiId] = activeLabelId;
        } else {
          delete roiAssignments[roiId];
        }
      });
    }

    function applyLabelToSingleRoi(roiId) {
      if (roiId <= 0) return;
      if (activeLabelId) {
        roiAssignments[roiId] = activeLabelId;
      } else {
        delete roiAssignments[roiId];
      }
    }

    function getRoiIdsInRect(x1, y1, x2, y2) {
      const minX = Math.max(0, Math.min(x1, x2));
      const maxX = Math.min(imgWidth - 1, Math.max(x1, x2));
      const minY = Math.max(0, Math.min(y1, y2));
      const maxY = Math.min(imgHeight - 1, Math.max(y1, y2));
      const set = new Set();
      for (let y = minY; y <= maxY; y++) {
        const rowOffset = y * imgWidth;
        for (let x = minX; x <= maxX; x++) {
          const roiId = roiLabelData[rowOffset + x];
          if (roiId > 0) set.add(roiId);
        }
      }
      return Array.from(set);
    }

    // ===== Load image & segment =====
    maskFileInput.addEventListener("change", e => {
      const file = e.target.files[0];
      if (!file) return;

      const img = new Image();
      img.onload = () => {
        emptyState.style.display = "none";
        maskLoaded = true;

        segmentImageHighRes(img);
        roiAssignments = {};
        renderBase();
        renderOverlay();
        hoverInfo.textContent = `High-res grid: ${imgWidth} × ${imgHeight} · ROIs: ${roiCount}`;
        updateSelectionStatus("No ROI selected");
      };
      img.onerror = () => {
        alert("Failed to load image. Please use a black-outline + white-background PNG/JPEG/SVG.");
      };

      const url = URL.createObjectURL(file);
      img.src = url;
    });

    // ===== Import project JSON =====
    annotationFileInput.addEventListener("change", e => {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = evt => {
        try {
          const json = JSON.parse(evt.target.result);
          if (!json.roiLabelData) {
            alert("This JSON does not contain a full project (roiLabelData missing).");
            return;
          }
          imgWidth = json.imgWidth;
          imgHeight = json.imgHeight;
          resizeCanvases(imgWidth, imgHeight);
          roiLabelData = decodeUint16FromBase64(json.roiLabelData);
          roiCount = json.roiCount || 0;
          roiPolygons = json.roiPolygons || {};
          roiCentroids = json.roiCentroids || {};

          // If polygons/centroids missing, rebuild from pixels
          if (!Object.keys(roiPolygons).length || !Object.keys(roiCentroids).length) {
            roiPixelMap = {};
            for (let i = 0; i < roiLabelData.length; i++) {
              const id = roiLabelData[i];
              if (id <= 0) continue;
              const x = i % imgWidth;
              const y = (i / imgWidth) | 0;
              if (!roiPixelMap[id]) roiPixelMap[id] = { pixels: [], cx: 0, cy: 0 };
              roiPixelMap[id].pixels.push({ x, y });
            }
            for (const [idStr, obj] of Object.entries(roiPixelMap)) {
              const arr = obj.pixels;
              let sx = 0, sy = 0;
              for (const p of arr) { sx += p.x; sy += p.y; }
              const n = arr.length || 1;
              const cx = sx / n;
              const cy = sy / n;
              obj.cx = cx;
              obj.cy = cy;
              roiCentroids[idStr] = { cx, cy };
            }
            buildRoiPolygonsFromPixels(imgWidth, imgHeight);
          }

          labels = json.labels || [];
          roiAssignments = json.roiAssignments || {};
          activeLabelId = labels.length ? labels[0].id : null;

          maskLoaded = true;
          emptyState.style.display = "none";
          renderBase();
          renderOverlay();
          hoverInfo.textContent = `Project loaded: ${imgWidth} × ${imgHeight} · ROIs: ${roiCount}`;
          setMaskInfo("Project JSON loaded.");
          updateSelectionStatus("No ROI selected");
        } catch (err) {
          console.error(err);
          alert("Failed to parse JSON. Please check that this is a project file exported from this tool.");
        }
      };
      reader.readAsText(file);
    });

    // ===== Label creation / clearing =====
    addLabelBtn.addEventListener("click", () => {
      const name = labelNameInput.value.trim();
      const color = labelColorInput.value || getNextColor();
      addLabel(name, color);
      labelNameInput.value = "";
      renderBase();
      renderOverlay();
    });

    clearAllBtn.addEventListener("click", () => {
      labels = [];
      roiAssignments = {};
      activeLabelId = null;
      refreshLabelList();
      updateGlobalStats();
      renderBase();
      renderOverlay();
    });

    // ===== Modes =====
    modeClickBtn.addEventListener("click", () => setInteractionMode("click"));
    modeBoxBtn.addEventListener("click", () => setInteractionMode("box"));
    modeMoveBtn.addEventListener("click", () => setInteractionMode("move"));

    // ===== Zoom =====
    canvasContainer.addEventListener("wheel", e => {
      if (!maskLoaded) return;
      e.preventDefault();
      const rect = canvasContainer.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;

      const oldScale = baseScale * viewScale;
      const factor = e.deltaY > 0 ? 0.9 : 1.1;
      let newViewScale = viewScale * factor;
      if (newViewScale < minScale) newViewScale = minScale;
      if (newViewScale > maxScale) newViewScale = maxScale;
      const newScale = baseScale * newViewScale;

      const tx = (rect.width - imgWidth * oldScale) / 2 + panX;
      const ty = (rect.height - imgHeight * oldScale) / 2 + panY;
      const imgX = (mouseX - tx) / oldScale;
      const imgY = (mouseY - ty) / oldScale;

      const newTx = mouseX - imgX * newScale;
      const newTy = mouseY - imgY * newScale;

      panX = newTx - (rect.width - imgWidth * newScale) / 2;
      panY = newTy - (rect.height - imgHeight * newScale) / 2;
      viewScale = newViewScale;
      updateViewTransform();
    }, { passive: false });

    // ===== Move mode (pan) =====
    canvasContainer.addEventListener("mousedown", e => {
      if (!maskLoaded) return;
      if (e.button !== 0) return;
      if (interactionMode !== "move") return;
      isPanning = true;
      panStartClientX = e.clientX;
      panStartClientY = e.clientY;
      panStartX = panX;
      panStartY = panY;
    });

    window.addEventListener("mousemove", e => {
      if (isPanning) {
        const dx = e.clientX - panStartClientX;
        const dy = e.clientY - panStartClientY;
        panX = panStartX + dx;
        panY = panStartY + dy;
        updateViewTransform();
      }
    });

    window.addEventListener("mouseup", e => {
      if (isPanning && e.button === 0) {
        isPanning = false;
      }
    });

    // ===== Click & box selection =====
    maskCanvas.addEventListener("mousemove", e => {
      if (!maskLoaded || !roiLabelData) return;
      const p = canvasPixelFromEvent(e);
      if (!p) return;
      const roiId = getRoiIdAt(p.x, p.y);
      if (roiId === 0) {
        hoverInfo.textContent = `Pos: (${p.x}, ${p.y}) · Background`;
      } else {
        const labelId = roiAssignments[roiId];
        const labelName = labelId ? (labels.find(l => l.id === labelId)?.name || labelId) : "Unlabeled";
        hoverInfo.textContent = `Pos: (${p.x}, ${p.y}) · ROI ID: ${roiId} · Label: ${labelName}`;
      }

      if (roiId !== hoveredRoiId) {
        hoveredRoiId = roiId;
        hoverScaleTarget = roiId > 0 ? hoverScaleMax : 1.0;
      }

      if (interactionMode === "box" && isDragging && dragStart) {
        dragCurrent = p;
      }

      renderOverlay();
    });

    maskCanvas.addEventListener("mouseleave", () => {
      if (!maskLoaded) return;
      hoverInfo.textContent = "Mouse left ROI view";
      hoveredRoiId = 0;
      hoverScaleTarget = 1.0;
      if (isDragging && interactionMode === "box") {
        isDragging = false;
        dragStart = null;
        dragCurrent = null;
      }
      renderOverlay();
    });

    maskCanvas.addEventListener("mousedown", e => {
      if (!maskLoaded || !roiLabelData) return;
      if (e.button !== 0) return;
      const p = canvasPixelFromEvent(e);
      if (!p) return;

      if (interactionMode === "click") {
        const roiId = getRoiIdAt(p.x, p.y);
        if (roiId === 0) {
          updateSelectionStatus("Clicked background (no ROI).");
        } else {
          applyLabelToSingleRoi(roiId);
          renderBase();
          renderOverlay();
          const current = roiAssignments[roiId];
          if (current) {
            updateSelectionStatus(`ROI ${roiId} set to label ${current}.`);
          } else {
            updateSelectionStatus(`ROI ${roiId} cleared.`);
          }
        }
      } else if (interactionMode === "box") {
        isDragging = true;
        dragStart = p;
        dragCurrent = p;
        renderOverlay();
      }
      // Move mode handled by container
    });

    maskCanvas.addEventListener("mouseup", e => {
      if (e.button !== 0) return;
      if (!maskLoaded || !roiLabelData) return;
      if (interactionMode !== "box") return;
      if (!isDragging || !dragStart) return;

      const p = canvasPixelFromEvent(e);
      if (!p) {
        isDragging = false;
        dragStart = null;
        dragCurrent = null;
        renderOverlay();
        return;
      }
      dragCurrent = p;

      const roiIds = getRoiIdsInRect(dragStart.x, dragStart.y, dragCurrent.x, dragCurrent.y);
      applyLabelToRois(roiIds);

      isDragging = false;
      dragStart = null;
      dragCurrent = null;

      renderBase();
      renderOverlay();

      if (roiIds.length) {
        updateSelectionStatus(
          `Box selection affected ${roiIds.length} ROIs (set/cleared according to active label).`
        );
      } else {
        updateSelectionStatus("No ROI in box selection.");
      }
    });

    // ===== Export project =====
    exportJsonBtn.addEventListener("click", () => {
      if (!maskLoaded || !roiLabelData) {
        alert("Please load a template image or project first.");
        return;
      }
      const obj = {
        version: 3,
        imgWidth,
        imgHeight,
        roiCount,
        roiLabelData: encodeUint16ToBase64(roiLabelData),
        roiPolygons,
        roiCentroids,
        labels,
        roiAssignments,
        timestamp: new Date().toISOString(),
      };
      const blob = new Blob([JSON.stringify(obj, null, 2)], {
        type: "application/json",
      });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "root_roi_project.json";
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    });

    // ===== Export PNG =====
    exportPngBtn.addEventListener("click", () => {
      if (!maskLoaded || !roiLabelData) {
        alert("Please load a template image or project first.");
        return;
      }
      maskCanvas.toBlob(blob => {
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "root_roi_vector_map.png";
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }, "image/png", 1.0);
    });

    // ===== Resize =====
    window.addEventListener("resize", () => {
      if (!maskLoaded) return;
      computeBaseScale();
      updateViewTransform();
    });

    // ===== Hover animation loop =====
    function hoverAnimLoop() {
      const dt = 1 / 60;
      const diff = hoverScaleTarget - hoverScaleCurrent;
      hoverScaleCurrent += diff * Math.min(1, hoverAnimSpeed * dt);
      if (Math.abs(diff) < 0.001) hoverScaleCurrent = hoverScaleTarget;
      renderOverlay();
      requestAnimationFrame(hoverAnimLoop);
    }

    // ===== Init =====
    (function init() {
      setInteractionMode("click");
      updateGlobalStats();
      refreshLabelList();
      labelColorInput.value = getNextColor();
      hoverAnimLoop();
    })();
  </script>
</body>
</html>
